<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>height:auto的理解</title>
    <url>/2020/04/06/css/heightauto/</url>
    <content><![CDATA[<p>height：auto</p>
<p>首先第一层理解是他根据元素的内容自己给了高度</p>
<p>同时，还有一层如果父元素的高度发生变化，他就会自动按照100%时候的比例变化，但是有的时候不是这样，到时候遇到再说把</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>阮一峰</tag>
      </tags>
  </entry>
  <entry>
    <title>空格px问题</title>
    <url>/2020/04/20/css/%E7%A9%BA%E6%A0%BCpx%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>设计师给了一张图</p>
<p>没有标边距收的就算了，我自己算</p>
<p>他，他，他给了四个空格！！</p>
<p>四个空格！！</p>
<p><img src="https://s1.ax1x.com/2020/04/20/JQbKpD.jpg" alt="JQbKpD.jpg"></p>
<p>四个空格怎么量化，是多少px？</p>
<p>经过我一顿激烈的百度，html5常用的有四种空格</p>
<ul>
<li><p>&amp;nbsp；</p>
<p>这个是按下space产下的空格</p>
</li>
<li><p>&amp; ensp;</p>
<p>这里加个空是因为md他会编译出空格，半角空格，二分一个中文宽度，基本不受字体影响</p>
</li>
<li><p>&amp;emsp</p>
<p>全角空格，宽度是一个中文宽度，基本不受字体影响</p>
</li>
<li><p>&amp; thinsp;</p>
<p>瘦空格，比较小，em的6份之一宽</p>
</li>
</ul>
<p>但是我这里不是html，要用css 写，html无法解决！！！</p>
<p>我吐了</p>
<p>图是这样的</p>
<p>最后我是用ps导出图片一个个像素数的</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>吐槽</tag>
      </tags>
  </entry>
  <entry>
    <title>边距百分比问题</title>
    <url>/2020/04/24/css/%E8%BE%B9%E8%B7%9D%E7%99%BE%E5%88%86%E6%AF%94%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>众所周知，边距的百分比是以宽度计算的（并不），如果我宽度不变，但是我top与bottom想要百分比怎么办？</p>
<p><img src="https://s1.ax1x.com/2020/04/24/J0X4f0.jpg" alt="J0X4f0.jpg"></p>
<p>其实很简单，只有外面容器的宽度不要写死，用百分比，里面的元素写死宽度，那么外面的容器即使变小了，默认的overflow都会吧撑出来的内容显示出来</p>
<p>上图</p>
<p><img src="https://s1.ax1x.com/2020/04/24/J0Xjt1.png" alt="J0Xjt1.png"></p>
<p>是不是很简单呢（老营销号了）</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>css/设计软件中的粗细对应bold</title>
    <url>/2020/04/21/css/%E8%AE%BE%E8%AE%A1%E8%BD%AF%E4%BB%B6%E4%B8%AD%E7%9A%84%E7%B2%97%E7%BB%86%E5%AF%B9%E5%BA%94bold/</url>
    <content><![CDATA[<p>看到软件中的字体粗细，也是个不好量化的东西，经过我努力的百度</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">字体粗细：‘font-weight’属性</span><br><span class="line">名称： font-weight</span><br><span class="line">取值： normal | bold | bolder | lighter | 100 | 200 | 300 | 400 | 500 | 600 | 700 | 800 | 900</span><br><span class="line">初始： normal</span><br><span class="line">适用于：    所有元素</span><br><span class="line">继承： 是</span><br><span class="line">百分比：    （不适用）</span><br><span class="line">媒介： 视觉</span><br><span class="line">计算值：    详见描述</span><br><span class="line">动画： -</span><br><span class="line">‘font-weight’属性执行字体中字形的重量，这取决于黑度等级或笔划粗细。</span><br><span class="line">其值的意义如下：</span><br><span class="line">100至900</span><br><span class="line">这些有序排列中的每个值，表示至少与其起身拥有相同黑度的重量。其大致符合下列通用重量名称：</span><br><span class="line">100 - Thin</span><br><span class="line">200 - Extra Light (Ultra Light)</span><br><span class="line">300 - Light</span><br><span class="line">400 - Regular (Normal、Book、Roman)</span><br><span class="line">500 - Medium</span><br><span class="line">600 - Semi Bold (Demi Bold)</span><br><span class="line">700 - Bold</span><br><span class="line">800 - Extra Bold (Ultra Bold)</span><br><span class="line">900 - Black (Heavy)</span><br><span class="line"></span><br><span class="line">normal、regular与&#39;400&#39;相同。</span><br><span class="line">bold与&#39;700&#39;相同。</span><br><span class="line">bolder指定外观的重量大于继承的值。</span><br><span class="line">lighter 指定外观的重量小于继承的值。</span><br></pre></td></tr></table></figure>

<p>可以看到regular与400是一样的 ，但是看起来完全不一样呀混蛋</p>
<p>先不管了，工作好多嘤嘤嘤</p>
<p><img src="https://s1.ax1x.com/2020/04/21/J3cVeS.jpg" alt="J3cVeS.jpg"></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>js中的循环</title>
    <url>/2020/04/28/js/js%E4%B8%AD%E7%9A%84%E5%BE%AA%E7%8E%AF/</url>
    <content><![CDATA[<p>原文地址</p>
<blockquote>
<p><a href="https://juejin.im/post/5c40484bf265da61171cfb4d#comment" target="_blank" rel="noopener">https://juejin.im/post/5c40484bf265da61171cfb4d#comment</a></p>
</blockquote>
<p>先放原文，因为这个东西就不是现在的我能误出来的，先放原文</p>
<h2 id="for-of"><a href="#for-of" class="headerlink" title="for  of"></a>for  of</h2><p>forof在js中最常用的就是遍历数组，其实也可以遍历String、Maps、Sets、arguents，但是除了对象，没错就是除了对象</p>
<p>对象一般用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> xxx) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类数组对象"><a href="#类数组对象" class="headerlink" title="类数组对象"></a>类数组对象</h3><p>上面的原因是for  of只能用于遍历类数组对象，什么是类数组对象呢，简单理解是key是012等数字的对象，其实不然</p>
<p>是因为他们都实现了iteratorr</p>
<p>iterator是个什么东西，来看看</p>
<p><img src="http://zezeze-note.oss-cn-hongkong.aliyuncs.com/%E7%AC%94%E8%AE%B0%E6%88%AA%E5%9B%BE/js/js%E4%B8%AD%E7%9A%84%E5%BE%AA%E7%8E%AF/Snipaste_2020-04-29_20-14-13.png?OSSAccessKeyId=LTAI4GCeVHegRoadhkK6mc12&Expires=1588166069&Signature=gyydaCFtEZB6KE9BoI801WS41ow%3D" alt="Gj87TK.png"></p>
<p>可以看到是写在原型链里面的，再看看这个方法里面有什么</p>
<p><img src="http://zezeze-note.oss-cn-hongkong.aliyuncs.com/%E7%AC%94%E8%AE%B0%E6%88%AA%E5%9B%BE/js/js%E4%B8%AD%E7%9A%84%E5%BE%AA%E7%8E%AF/Snipaste_2020-04-29_20-19-40.png?OSSAccessKeyId=LTAI4GCeVHegRoadhkK6mc12&Expires=1588166399&Signature=Puf761BrBBAOm8354yEqUxo8FhU%3D" alt=""></p>
<p>啊哈，有个next方法，执行他</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">iterator.next(); <span class="comment">// 输出 &#123;value: 1, done: false&#125;</span></span><br><span class="line">iterator.next(); <span class="comment">// 输出 &#123;value: 2, done: false&#125;</span></span><br><span class="line">iterator.next(); <span class="comment">// 输出 &#123;value: 3, done: false&#125;</span></span><br><span class="line">iterator.next(); <span class="comment">// 输出 &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>

<p>可以看到他轮着把下标输出了，而done代表是否循环结束的标志</p>
<p>最后超出下标的话，他直接把done标志为true，然后下标输出为undefined</p>
<p>为什么这样设计？</p>
<p>因为这是迭代器协议呀<code>The iterator protocol</code>（迭代协议）</p>
<p>说明这个迭代器是根据迭代协议设计的，那没事了</p>
<p>我们回头看我们js的对象里面是没有迭代器的，所以他不能循环</p>
<p>那么问题来了，为什么不给对象装一个迭代器</p>
<h2 id="object为什么没有迭代器"><a href="#object为什么没有迭代器" class="headerlink" title="object为什么没有迭代器"></a>object为什么没有迭代器</h2><p>因为没必要，我们有forin可以遍历key了呀</p>
<p>为什么说没必要，我们遍历一个对象的时候，想要的是什么</p>
<ul>
<li>一是遍历他的属性</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	a:<span class="number">1</span>,</span><br><span class="line">	b:<span class="number">2</span>,</span><br><span class="line">	c:<span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我想把abc的值都拿到，就是遍历他的属性</p>
<ul>
<li>而是遍历数据，这就是我们一般遍历的数组【0,5,8,9】，我们关心他的数据，而不是他的下标嘛（其实有的情况我们也会关心）</li>
</ul>
<p>所以forof用来解决第二种，forin我们用来解决第一种</p>
<h2 id="Generators"><a href="#Generators" class="headerlink" title="Generators"></a>Generators</h2><p>es6的写法，用来实例化出一个iterator，并且可以配合yield语句来中断代码的执行，因为是一个迭代器，就是会有next啦</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span>* gen2();</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iterator = gen();</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()); <span class="comment">// &#123;value:1,don:false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());<span class="comment">// &#123;value:4,don:false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());<span class="comment">// &#123;value:5,don:false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());<span class="comment">// &#123;value:undefined,don:true&#125;</span></span><br></pre></td></tr></table></figure>

<p>这里是一个嵌套Generators的写法，可以看到，他进了第二个里面，还是被yield停止啦，</p>
<p>同时我们可以注意到，return停止了整个genreator</p>
<h2 id="generator的应用"><a href="#generator的应用" class="headerlink" title="generator的应用"></a>generator的应用</h2><p>es6加这个是为了干嘛，当然是为了异步啦</p>
<p>假设我们有两个异步函数a与b，b的参数是a的返回值，如果a没有执行结束，我们不能执行b</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">effect</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; param &#125; = <span class="keyword">yield</span> A();</span><br><span class="line">  <span class="keyword">const</span> &#123; result &#125; = <span class="keyword">yield</span> B(param);</span><br><span class="line">  <span class="built_in">console</span>.table(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> iterator = effect()</span><br><span class="line">iterator.next()</span><br><span class="line">iterator.next()</span><br></pre></td></tr></table></figure>

<p>这种写法就会在a执行完再执行b</p>
<p>但是我们这样不会太笨b了吗，要自己next他，我们可以包装他一下的嘛</p>
<h2 id="语法糖async-await"><a href="#语法糖async-await" class="headerlink" title="语法糖async/await"></a>语法糖async/await</h2><p>这是es6提供的，返回是一个promise，内部有一个generator的哦</p>
<p>用法是这样的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getStockPriceByName</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> symbol = <span class="keyword">await</span> getStockSymbol(name);</span><br><span class="line">  <span class="keyword">const</span> stockPrice = <span class="keyword">await</span> getStockPrice(symbol);</span><br><span class="line">  <span class="keyword">return</span> stockPrice;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getStockPriceByName(<span class="string">'goog'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>因为有promise，可以用then的写法，看起来就好看多啦,同时也是包含了generator哒！</p>
<p>其实我们最常用的就是这个哒2</p>
<p>今天的学习就到这里哒</p>
<p><img src="http://zezeze-note.oss-cn-hongkong.aliyuncs.com/%E8%A1%A8%E6%83%85%E5%8C%85/119042e9166f0e7c60df59d765b72197_t.gif?OSSAccessKeyId=LTAI4GCeVHegRoadhkK6mc12&Expires=1588168605&Signature=LSGnttkAxTQFKoOxaHhsTiJsgHw%3D" alt=""></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title>js中的位运算</title>
    <url>/2020/04/07/js/js%E4%B8%AD%E7%9A%84%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<p>看vue刚好看到，补一补</p>
<p>我以为我一辈子都不会用到位运算，结果，苍天绕过谁！</p>
<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p>直接进行二进制的运算，比一般运算效率更高啦</p>
<h3 id="amp"><a href="#amp" class="headerlink" title="&amp;"></a>&amp;</h3><p>将数据二进制一一对比，只有都是1才返回1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例子 1&amp;3</span><br><span class="line">  0001</span><br><span class="line">&amp; 0011</span><br><span class="line">-----------</span><br><span class="line">  0001</span><br><span class="line">  结果返回1</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title="|"></a>|</h3><p>将数据二进制一一对比，只要有1就返回1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例子 1|3</span><br><span class="line">  0001</span><br><span class="line">&amp; 0011</span><br><span class="line">-----------</span><br><span class="line">  0011</span><br><span class="line">  结果返回3</span><br></pre></td></tr></table></figure>

<h3 id="-1"><a href="#-1" class="headerlink" title="~"></a>~</h3><p>取反</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例子 ~1</span><br><span class="line">  0001</span><br><span class="line">~ </span><br><span class="line">-----------</span><br><span class="line">  1110</span><br><span class="line">  结果返回14</span><br></pre></td></tr></table></figure>

<p>要特别说明一下js数字默认有符号，32为二进制最高位为符号位，就是为0为正1负</p>
<h3 id="-2"><a href="#-2" class="headerlink" title="^"></a>^</h3><p>只有其中一个为1 时返回，其他返回0</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例子 1^3</span><br><span class="line">  0001</span><br><span class="line">^ 0011</span><br><span class="line">-----------</span><br><span class="line">  0010</span><br><span class="line">  结果返回2</span><br></pre></td></tr></table></figure>

<h3 id="lt-lt"><a href="#lt-lt" class="headerlink" title="&lt;&lt;"></a>&lt;&lt;</h3><p>有符号左移,将32位二进制的所有位向左移动指定位数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例子 2 &lt;&lt; 5</span><br><span class="line">10 -&gt; 1000000(64)</span><br></pre></td></tr></table></figure>

<h3 id="gt-gt"><a href="#gt-gt" class="headerlink" title="&gt;&gt;"></a>&gt;&gt;</h3><p>有符号右移，将32位二进制所有位向右移动指定位数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例子 64 &gt;&gt; 5</span><br><span class="line">1000000 -&gt; 10(2)</span><br></pre></td></tr></table></figure>

<h3 id="gt-gt-gt"><a href="#gt-gt-gt" class="headerlink" title="&gt;&gt;&gt;"></a>&gt;&gt;&gt;</h3><p>无符号右移，正数结果跟上面&gt;&gt;一样，负数结果连符号位一起移动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例子 -64 &gt;&gt;&gt; 5</span><br><span class="line">11000000 -&gt; 0000011000000（192）</span><br></pre></td></tr></table></figure>

<p>符号负1莫了变0了</p>
<h3 id="lt-lt-lt"><a href="#lt-lt-lt" class="headerlink" title="&lt;&lt;&lt;"></a>&lt;&lt;&lt;</h3><p>无符号右移，跟上吗差不多</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例子 -64 </span><br><span class="line">11000000 -&gt; 1100000000000(-1024)</span><br></pre></td></tr></table></figure>

<h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断奇偶</span></span><br><span class="line"><span class="keyword">if</span> (n&amp;<span class="number">2</span> === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 奇数 </span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 偶数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 浮点数向下取整</span></span><br><span class="line"><span class="number">1.1</span> | <span class="number">0</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调换数字的值</span></span><br><span class="line"><span class="keyword">var</span> num1 = <span class="number">1</span>,num = <span class="number">2</span></span><br><span class="line">num1 ^= num2</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2的n次方</span></span><br><span class="line"><span class="number">1</span> &lt;&lt; n</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求一个数的二分之1</span></span><br><span class="line">n &gt;&gt; <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断政府</span></span><br><span class="line">n &gt;&gt;&gt; <span class="number">0</span> <span class="literal">true</span>正数，<span class="literal">false</span>负数</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title>思维导图总结</title>
    <url>/2020/04/13/vue%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/01-1.%E8%AE%BE%E8%AE%A1%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>看到patch的时候已经对前面的细节有点忘了，写个思维导图复习一下</p>
<p>0.0</p>
<p>写完思维导图了 怎么传呢</p>
<p><a href="./理解.xmind">xmind下载</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>源码</tag>
        <tag>flag</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>flag</title>
    <url>/2020/04/10/vue%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/01.flag/</url>
    <content><![CDATA[<h2 id="flag"><a href="#flag" class="headerlink" title="flag"></a>flag</h2><p>跟的是大佬的逐行分析</p>
<blockquote>
<p><a href="https://github.com/lalaze/vue-design" target="_blank" rel="noopener">https://github.com/lalaze/vue-design</a></p>
<p><a href="http://hcysun.me/vue-design/zh/" target="_blank" rel="noopener">http://hcysun.me/vue-design/zh/</a></p>
</blockquote>
<p>dev分支才是代码分析哦</p>
<p>本来想跟海螺的，但还是有人带着看一遍先</p>
<p> 先看设计思路，再返回去看源码，是长线作战哦0.0</p>
<p><b>flag每天记录看过的东西，保底一篇</b></p>
<p>就是那种无论看多少都记一下，当写日记，然后后面有大知识点总体整理</p>
<p>我看书看文章喜欢一边看一边敲，手不动看不进去，但是我懒，写了之后没有后续整理的过程，希望以后改善吧</p>
<p>同时看这个复制的代码放在一个专门的仓库吧</p>
<p>仓库不要钱23333</p>
<p>依靠webpack的</p>
<blockquote>
</blockquote>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>源码</tag>
        <tag>flag</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>css变量入门</title>
    <url>/2020/04/06/css/css%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<p>还是吃阮一峰大佬的好看</p>
<blockquote>
<p><a href="http://www.ruanyifeng.com/blog/2017/05/css-variables.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2017/05/css-variables.html</a></p>
</blockquote>
<h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">	<span class="attribute">--foo</span>:<span class="number">#7F583F</span></span><br><span class="line">	--bar:<span class="number">#F7EFD2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>又叫做css自定义属性哟</p>
<p>正常来说，css变量里面可以放各种值，注意css变量大小写敏感</p>
<h2 id="var-变量"><a href="#var-变量" class="headerlink" title="var()变量"></a>var()变量</h2><p>用于读取变量</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">	<span class="attribute">color</span>:<span class="built_in">var</span>(--foo)</span><br><span class="line">     text-decoration-color:<span class="built_in">var</span>(--bar)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以用第二个参数表示默认值</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">color</span><span class="selector-pseudo">:var(--foo</span>,<span class="selector-id">#7F583F</span>)</span><br><span class="line"></span><br><span class="line">第二个参数不出来内部的东西，逗号与空格都可以</span><br><span class="line"><span class="selector-tag">var</span>(<span class="selector-tag">--font-stack</span>,"<span class="selector-tag">Roboto</span>", "<span class="selector-tag">Helvetica</span>")</span><br></pre></td></tr></table></figure>

<p>可以变量套变量</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">:root &#123;   //:root选择匹配文档的根元素</span><br><span class="line">    <span class="selector-tag">--primary-color</span><span class="selector-pseudo">:red</span></span><br><span class="line">    <span class="selector-tag">--logo-text</span><span class="selector-pseudo">:var(--primary-color)</span></span><br><span class="line">&#125;</span><br><span class="line">但是变量不能做属性名</span><br><span class="line">var(--side):20px  //这个是错的</span><br></pre></td></tr></table></figure>

<h2 id="变量值的类型"><a href="#变量值的类型" class="headerlink" title="变量值的类型"></a>变量值的类型</h2><ul>
<li>变量值可以是字符串与其他字符串拼接</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">--bar</span><span class="selector-pseudo">:'hello'</span>;</span><br><span class="line">--foo:var(--bar)' world'</span><br></pre></td></tr></table></figure>

<ul>
<li>如果是数值，不能与数值单位直接连用</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.foo</span> &#123;</span><br><span class="line"><span class="attribute">--gap</span>:<span class="number">20</span></span><br><span class="line">// 无效</span><br><span class="line">margin-top：<span class="built_in">var</span>(--gap)<span class="built_in">px</span>;</span><br><span class="line">    </span><br><span class="line">// 但是用calc可以</span><br><span class="line"><span class="selector-tag">margin-top</span><span class="selector-pseudo">:calc(var(--gap)</span> * 1<span class="selector-tag">px</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果变量值有单位，就不能写成字符串了</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">//无效</span><br><span class="line"><span class="selector-class">.foo</span> &#123;</span><br><span class="line">    <span class="attribute">--foo</span>:<span class="string">'20px'</span>;</span><br><span class="line">    <span class="attribute">font-size</span>:<span class="built_in">var</span>(--foo)</span><br><span class="line">&#125;</span><br><span class="line">//正确用法</span><br><span class="line"><span class="selector-class">.foo</span> &#123;</span><br><span class="line">    <span class="attribute">--foo</span>:<span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">font-size</span>:<span class="built_in">var</span>(--foo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>同一个css变量，可以在多个选择器声明，读取的时候，优先级最高的声明生效，与css的层叠规则一样</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-pseudo">:root</span> &#123;<span class="attribute">--color</span>:blue&#125;</span></span><br><span class="line"><span class="css"><span class="selector-tag">div</span> &#123;<span class="attribute">--color</span>:green&#125;</span></span><br><span class="line"><span class="css"><span class="selector-id">#alert</span> &#123;<span class="attribute">--color</span>:red&#125;</span></span><br><span class="line"><span class="css">* &#123;<span class="attribute">color</span>:<span class="built_in">var</span>(--color)&#125;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>蓝色<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>绿色<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span> = <span class="string">"alert"</span>&gt;</span>红色<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>变量的作用域是他选择器生效的有效范围</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">	<span class="attribute">--for</span>:<span class="number">#7F583F</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.content</span> &#123;</span><br><span class="line">	<span class="attribute">--bar</span>:<span class="number">#F7EFD2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>for的范围是body选择器的范围，bar的范围是.content的范围</p>
<p>因此全局变量一般放在根元素里面，方便访问修改</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">	<span class="attribute">--main-color</span>:<span class="number">#06c</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h2><p>使用css变量来做响应式布局，挺方便的</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">--primary</span>:<span class="number">#7F583F</span>;</span><br><span class="line">    <span class="attribute">--secondary</span>:<span class="number">#F7EFD2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>:<span class="built_in">var</span>(--primary);</span><br><span class="line">    <span class="attribute">text-decoration-color</span>:<span class="built_in">var</span>(--secondary);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@meida</span> screen <span class="keyword">and</span> (<span class="attribute">min-width:</span><span class="number">768px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">body</span> &#123;</span><br><span class="line">     <span class="attribute">--primary</span>:  <span class="number">#F7EFD2</span>;</span><br><span class="line">    <span class="attribute">--secondary</span>: <span class="number">#7F583F</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>像这个例子，只要屏幕变小了，对应的css变量变了，下面的基于此变量的css代码都会变，有点方便</p>
<h2 id="兼容性处理"><a href="#兼容性处理" class="headerlink" title="兼容性处理"></a>兼容性处理</h2><p>普通方式</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#7F583F</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">var</span>(--primary);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用@support命令进行检测</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@supports</span> ( (<span class="attribute">--a:</span> <span class="number">0</span>)) &#123;</span><br><span class="line">  <span class="comment">/* supported */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@supports</span> ( <span class="keyword">not</span> (<span class="attribute">--a:</span> <span class="number">0</span>)) &#123;</span><br><span class="line">  <span class="comment">/* not supported */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="js操作"><a href="#js操作" class="headerlink" title="js操作"></a>js操作</h2><p>检测当前浏览器是否支持css</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> isSupported =</span><br><span class="line">  <span class="built_in">window</span>.CSS &amp;&amp;</span><br><span class="line">  <span class="built_in">window</span>.CSS.supports &amp;&amp;</span><br><span class="line">  <span class="built_in">window</span>.CSS.supports(<span class="string">'--a'</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isSupported) &#123;</span><br><span class="line">  <span class="comment">/* supported */</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">/* not supported */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>js可以直接操作css变量</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 设置变量</span></span><br><span class="line"><span class="built_in">document</span>.body.style.setProperty(<span class="string">'--primary'</span>, <span class="string">'#7F583F'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取变量</span></span><br><span class="line"><span class="built_in">document</span>.body.style.getPropertyValue(<span class="string">'--primary'</span>).trim();</span><br><span class="line"><span class="comment">// '#7F583F'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除变量</span></span><br><span class="line"><span class="built_in">document</span>.body.style.removeProperty(<span class="string">'--primary'</span>);</span><br></pre></td></tr></table></figure>

<p>理论上任意值都能放进去，当储存用，但是最好不要</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>阮一峰</tag>
      </tags>
  </entry>
  <entry>
    <title>理解组件</title>
    <url>/2020/04/07/vue%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/02.%E7%90%86%E8%A7%A3%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<h3 id="判断参数的写法"><a href="#判断参数的写法" class="headerlink" title="判断参数的写法"></a>判断参数的写法</h3><p>史诗级疑惑，今天解决了，具体看例子就懂了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b = &#123;</span><br><span class="line">    <span class="comment">// a:1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = b == <span class="number">2</span> || (a=<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a)  <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">1</span> <span class="comment">// 无论基本类型还是引用类型，都要有定义才可以</span></span><br><span class="line"><span class="keyword">var</span> a = b == <span class="number">2</span> || (a=<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a)  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h3 id="组件的定义"><a href="#组件的定义" class="headerlink" title="组件的定义"></a>组件的定义</h3><h4 id="模板引擎的年代"><a href="#模板引擎的年代" class="headerlink" title="模板引擎的年代"></a>模板引擎的年代</h4><p>这个我用的比较多（其实很少），模板引擎将字符串转成模板生成器，然后加上数据变成html字符串输出到页面上</p>
<p>模板+数据=html字符串</p>
<h3 id="如今"><a href="#如今" class="headerlink" title="如今"></a>如今</h3><p>模板+数据=虚拟DOM(Virtual DOM)</p>
<p>再用虚拟DOM替换(patch)真实的html（不是真实替换）</p>
<p>当数据变化的时候，重新产出新的虚拟DOM替换</p>
<h3 id="使用Virtual-DOM的原因"><a href="#使用Virtual-DOM的原因" class="headerlink" title="使用Virtual DOM的原因"></a>使用Virtual DOM的原因</h3><p>为什么用虚拟DOM不用html，因为虚拟DOM带来了抽象的接入点，可以实现分层设计，也正是这个设计，可以渲染到除网页之外的地方去，例如手机等，理解是这样的，反正我生成对应的虚拟dom，最后一步看不同的平台不同的方法挂载上去</p>
<p>至于虚拟DOM的性能，肯定是比不上原生的，但是抽象是程序员最大的武器</p>
<h2 id="Virtual-DOM"><a href="#Virtual-DOM" class="headerlink" title="Virtual DOM"></a>Virtual DOM</h2><h3 id="如何表示"><a href="#如何表示" class="headerlink" title="如何表示"></a>如何表示</h3><p>比较普通一点的想法，我们用一个对象描述这个dom的特点，然后通过render方法挂载到页面上，render方法也比较简单</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">vnode, container</span>) </span>&#123;</span><br><span class="line">  mountElement(vnode, container)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountElement</span>(<span class="params">vnode, container</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建元素</span></span><br><span class="line">  <span class="keyword">const</span> el = <span class="built_in">document</span>.createElement(vnode.tag)</span><br><span class="line">  <span class="comment">// 将元素添加到容器</span></span><br><span class="line">  container.appendChild(el)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就两个参数，一个你描述vnode的对象，一个你要挂载的地方嘛，然后根据你的vnode插入</p>
<p>但是我们的vndom一般都很复杂这里的render只是最基础的一层，再次抽象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用tag表示标签名</span></span><br><span class="line"><span class="keyword">const</span> elementVnode = &#123;</span><br><span class="line">  tag: <span class="string">'div'</span>  <span class="comment">//这是html自带的标签</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> componentVnode = &#123;</span><br><span class="line">  tag: MyComponent  <span class="comment">// 自己定义的标签</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// render判断是不是原生的，走不同的挂载方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">vnode, container</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> vnode.tag === <span class="string">'string'</span>) &#123;</span><br><span class="line">    <span class="comment">// html 标签</span></span><br><span class="line">    mountElement(vnode, container)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 组件</span></span><br><span class="line">    mountComponent(vnode, container)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件的挂载方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountComponent</span>(<span class="params">vnode, container</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建组件实例</span></span><br><span class="line">  <span class="keyword">const</span> instance = <span class="keyword">new</span> vnode.tag()</span><br><span class="line">  <span class="comment">// 渲染</span></span><br><span class="line">  instance.$vnode = instance.render()</span><br><span class="line">  <span class="comment">// 挂载</span></span><br><span class="line">  mountElement(instance.$vnode, container)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以看到是走的模板引擎那套</span></span><br></pre></td></tr></table></figure>

<p>这里要思考一个问题，使用tag分开的意义</p>
<p>我的思考：还是那句，抽象是最大的武器，我一个vnode可以有很多的标签在里面的，统一成一个组件再一起挂载，是一个比较好的选择</p>
<p>也就是我我这个vnode里面可能有很多东西，到最后直接就是html标签，这样写可以不管是一个真实的dom还是vnode都key挂载到</p>
<h3 id="组件的种类"><a href="#组件的种类" class="headerlink" title="组件的种类"></a>组件的种类</h3><p>设计了两种方式描述组件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 普通的函数  </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params">props</span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 一个类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>他们分别是函数式组件与状态组件</p>
<ul>
<li>函数式组件(Functional component)        <ul>
<li>一个纯函数</li>
<li>没有自身状态，只接受外部数据</li>
<li>单纯函数调用产出vnode</li>
</ul>
</li>
<li>状态组件(Stateful component)<ul>
<li>是一个类，可实例化</li>
<li>有自身状态</li>
<li>要实例化，再调用render函数产出vnode</li>
</ul>
</li>
</ul>
<blockquote>
<p>因为放网上了，还是放原链接</p>
<p><a href="http://hcysun.me/vue-design/zh/" target="_blank" rel="noopener">http://hcysun.me/vue-design/zh/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>源码</tag>
        <tag>读书笔记</tag>
        <tag>框架设计</tag>
      </tags>
  </entry>
  <entry>
    <title>设计vnode</title>
    <url>/2020/04/07/vue%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/03.%E8%AE%BE%E8%AE%A1vnode/</url>
    <content><![CDATA[<h2 id="设计VNode"><a href="#设计VNode" class="headerlink" title="设计VNode"></a>设计VNode</h2><p>vnode的设计是挺重要的，后面所有设计都要有关他的</p>
<h3 id="Vnode描述真实DOM"><a href="#Vnode描述真实DOM" class="headerlink" title="Vnode描述真实DOM"></a>Vnode描述真实DOM</h3><p>其实就是现在浏览器描述节点的那一套类似，但是又有一些不一样</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 元素节点</span></span><br><span class="line"><span class="keyword">const</span> elementVNode = &#123;</span><br><span class="line">    tag: <span class="string">'div'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        style: &#123;</span><br><span class="line">            width: <span class="string">'100px'</span>,</span><br><span class="line">            height: <span class="string">'100px'</span>,</span><br><span class="line">            backgroundColor: <span class="string">'red'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    children: [&#123;</span><br><span class="line">            tag: <span class="string">'h1'</span>,</span><br><span class="line">            data: <span class="literal">null</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            tag: <span class="string">'p'</span>,</span><br><span class="line">            data: <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*  tag名字</span></span><br><span class="line"><span class="comment">data是数据,可以看到里面有study</span></span><br><span class="line"><span class="comment">children是字节点的数据哦，因为有多个所以用了数组表示</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 文本节点</span></span><br><span class="line"><span class="keyword">const</span> textVNode = &#123;</span><br><span class="line">  tag: <span class="literal">null</span>,</span><br><span class="line">  data: <span class="literal">null</span>,</span><br><span class="line">  children: <span class="string">'文本内容'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// tag为null，文本不为任何节点</span></span><br><span class="line"><span class="comment">// 可以考虑新建一个text属性来放文本，但是已经有children属性了，不多加</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//一个有文本节点的div标签</span></span><br><span class="line"><span class="keyword">const</span> elementVNode = &#123;</span><br><span class="line">  tag: <span class="string">'div'</span>,</span><br><span class="line">  data: <span class="literal">null</span>,</span><br><span class="line">  children: &#123;</span><br><span class="line">    tag: <span class="literal">null</span>,</span><br><span class="line">    data: <span class="literal">null</span>,</span><br><span class="line">    children: <span class="string">'文本内容'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Vnode描述抽象内容"><a href="#Vnode描述抽象内容" class="headerlink" title="Vnode描述抽象内容"></a>Vnode描述抽象内容</h4><p>上面说的是真实的dom，现在要描述虚拟的内容，例如一个组件</p>
<p>首先加一个区分条件，区分真实dom与组件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> elementVNode = &#123;</span><br><span class="line">  tag: <span class="string">'div'</span>,</span><br><span class="line">  data: <span class="literal">null</span>,</span><br><span class="line">  children: &#123;</span><br><span class="line">    tag: MyComponent,  <span class="comment">//用了一个已经有的children里面的tag分开</span></span><br><span class="line">    data: <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="除了组件之外的抽象内容"><a href="#除了组件之外的抽象内容" class="headerlink" title="除了组件之外的抽象内容"></a>除了组件之外的抽象内容</h4><h5 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h5><p>代码片段Fragment，抽象一段代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*　&lt;template&gt;</span></span><br><span class="line"><span class="comment">  &lt;td&gt;&lt;/td&gt;</span></span><br><span class="line"><span class="comment">  &lt;td&gt;&lt;/td&gt;</span></span><br><span class="line"><span class="comment">  &lt;td&gt;&lt;/td&gt;</span></span><br><span class="line"><span class="comment">&lt;/template&gt;</span></span><br><span class="line"><span class="comment">将这个片段抽象出来　*/</span></span><br><span class="line"><span class="keyword">const</span> Fragment = <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="keyword">const</span> fragmentVNode = &#123;</span><br><span class="line">  <span class="comment">// tag 属性值是一个唯一标识</span></span><br><span class="line">  tag: Fragment,</span><br><span class="line">  data: <span class="literal">null</span>,</span><br><span class="line">  children: [</span><br><span class="line">    &#123;</span><br><span class="line">      tag: <span class="string">'td'</span>,</span><br><span class="line">      data: <span class="literal">null</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      tag: <span class="string">'td'</span>,</span><br><span class="line">      data: <span class="literal">null</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      tag: <span class="string">'td'</span>,</span><br><span class="line">      data: <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以理解为与组件不同的抽象层次，互相包含</p>
<p>如果我们的渲染器遇到了Fragment，就将这个东西的子节点全部渲染就行了</p>
<h5 id="Portal"><a href="#Portal" class="headerlink" title="Portal"></a>Portal</h5><p>抽象protal的原因，是因为有些时候我们想这个节点脱离父子关系渲染，要提供这样的一个方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* &lt;template&gt;</span></span><br><span class="line"><span class="comment">  &lt;div id="box" style="z-index: -1;"&gt;</span></span><br><span class="line"><span class="comment">    &lt;Overlay /&gt;</span></span><br><span class="line"><span class="comment">  &lt;/div&gt;</span></span><br><span class="line"><span class="comment">&lt;/template&gt;</span></span><br><span class="line"><span class="comment">我这个overlay想渲染到#box外面</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&lt;template&gt;</span></span><br><span class="line"><span class="comment">  &lt;Portal target="#app-root"&gt;</span></span><br><span class="line"><span class="comment">    &lt;div class="overlay"&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="comment">  &lt;/Portal&gt;</span></span><br><span class="line"><span class="comment">&lt;/template&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Portal = <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="keyword">const</span> portalVNode = &#123;</span><br><span class="line">  tag: Portal,</span><br><span class="line">  data: &#123;</span><br><span class="line">    target: <span class="string">'#app-root'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  children: &#123;</span><br><span class="line">    tag: <span class="string">'div'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">      class: 'overlay'</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>意思就是设计一种特殊的tag，这个tag固定有一个参数target，遇到这种tag就将他的children渲染到他指定的target上面</p>
<h2 id="Vnode的种类"><a href="#Vnode的种类" class="headerlink" title="Vnode的种类"></a>Vnode的种类</h2><p>根据我们上面的写法，分为五个嘛</p>
<p><img src="http://zezeze-note.oss-cn-hongkong.aliyuncs.com/%E7%AC%94%E8%AE%B0%E6%88%AA%E5%9B%BE/vue%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/03%E8%AE%BE%E8%AE%A1vnode/GcqYwt.png?OSSAccessKeyId=LTAI4GCeVHegRoadhkK6mc12&Expires=1588221770&Signature=ErwkbNz%2BfhYZ9Wzm9Zhdj0atnOw%3D" alt="GcqYwt.png"></p>
<p>这个keepalive后面会说</p>
<h2 id="识别各种Vnode"><a href="#识别各种Vnode" class="headerlink" title="识别各种Vnode"></a>识别各种Vnode</h2><p>在哪个阶段辨别各种Vnode与怎么分辨与我们值得思考的地方</p>
<p>vue2是这样区分vnode的</p>
<ul>
<li>拿到vnode后尝试去作为处理，如果成功，说明改vnode是组件的vnode</li>
<li>不成功就去检查vnode.tag，有定义当普通标签</li>
<li>没有tag检查是否为注释</li>
<li>不是注释当文本</li>
</ul>
<p>问题是这个判断vue2加在了挂载（patch），只有到了挂载我才知道他是什么vnode，不太好优化</p>
<p>我们可以直接多加个flags属性（可能对应为多种vnode），就不用每次都走这个判断拉，优化了一点</p>
<p>那么我们的判断可以写出这种亚子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (flags &amp; VNodeFlags.ELEMENT) &#123;</span><br><span class="line">  <span class="comment">// VNode 是普通标签</span></span><br><span class="line">  mountElement(<span class="comment">/* ... */</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (flags &amp; VNodeFlags.COMPONENT) &#123;</span><br><span class="line">  <span class="comment">// VNode 是组件</span></span><br><span class="line">  mountComponent(<span class="comment">/* ... */</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (flags &amp; VNodeFlags.TEXT) &#123;</span><br><span class="line">  <span class="comment">// VNode 是纯文本</span></span><br><span class="line">  mountText(<span class="comment">/* ... */</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里用的是位运算，优化判断的速度，因为可能有大量的判断同时进行</span></span><br><span class="line"><span class="comment">// &amp;为运算AND,将两个变量二进制形式对齐比对  这里理解为根&amp;&amp;一样就行啦</span></span><br></pre></td></tr></table></figure>

<h2 id="Flag枚举设计"><a href="#Flag枚举设计" class="headerlink" title="Flag枚举设计"></a>Flag枚举设计</h2><p>用枚举对象来命名flags</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> VNodeFlags = &#123;</span><br><span class="line">  <span class="comment">// html 标签</span></span><br><span class="line">  ELEMENT_HTML: <span class="number">1</span>,</span><br><span class="line">  <span class="comment">// SVG 标签</span></span><br><span class="line">  ELEMENT_SVG: <span class="number">1</span> &lt;&lt; <span class="number">1</span>,  <span class="comment">// 10 </span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 普通有状态组件</span></span><br><span class="line">  COMPONENT_STATEFUL_NORMAL: <span class="number">1</span> &lt;&lt; <span class="number">2</span>, <span class="comment">//100</span></span><br><span class="line">  <span class="comment">// 需要被keepAlive的有状态组件</span></span><br><span class="line">  COMPONENT_STATEFUL_SHOULD_KEEP_ALIVE: <span class="number">1</span> &lt;&lt; <span class="number">3</span>, <span class="comment">//1000</span></span><br><span class="line">  <span class="comment">// 已经被keepAlive的有状态组件</span></span><br><span class="line">  COMPONENT_STATEFUL_KEPT_ALIVE: <span class="number">1</span> &lt;&lt; <span class="number">4</span>, <span class="comment">//10000</span></span><br><span class="line">  <span class="comment">// 函数式组件</span></span><br><span class="line">  COMPONENT_FUNCTIONAL: <span class="number">1</span> &lt;&lt; <span class="number">5</span>, <span class="comment">//100000</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 纯文本</span></span><br><span class="line">  TEXT: <span class="number">1</span> &lt;&lt; <span class="number">6</span>, <span class="comment">//1000000</span></span><br><span class="line">  <span class="comment">// Fragment</span></span><br><span class="line">  FRAGMENT: <span class="number">1</span> &lt;&lt; <span class="number">7</span>, <span class="comment">//10000000</span></span><br><span class="line">  <span class="comment">// Portal</span></span><br><span class="line">  PORTAL: <span class="number">1</span> &lt;&lt; <span class="number">8</span> <span class="comment">//100000000</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里用了为运算，对应上面的判断哦，都是为了加快速度</span></span><br><span class="line"><span class="comment">// 可以看到都是直接用1位移不同位数得到的，根据这个特性有三个派生值，就是分类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> VNodeFlags = &#123; </span><br><span class="line">    <span class="comment">// html 和 svg 都是标签元素，可以用 ELEMENT 表示</span></span><br><span class="line">    VNodeFlags.ELEMENT = VNodeFlags.ELEMENT_HTML | VNodeFlags.ELEMENT_SVG</span><br><span class="line">    <span class="comment">// 1 | 10 = 11</span></span><br><span class="line">    <span class="comment">// 普通有状态组件、需要被keepAlive的有状态组件、已经被keepAlice的有状态组件 都是“有状态组件”，统一用 COMPONENT_STATEFUL 表示</span></span><br><span class="line">    VNodeFlags.COMPONENT_STATEFUL =</span><br><span class="line">      VNodeFlags.COMPONENT_STATEFUL_NORMAL |</span><br><span class="line">      VNodeFlags.COMPONENT_STATEFUL_SHOULD_KEEP_ALIVE |</span><br><span class="line">      VNodeFlags.COMPONENT_STATEFUL_KEPT_ALIVE</span><br><span class="line">    <span class="comment">// 000011100</span></span><br><span class="line">    <span class="comment">// 有状态组件 和  函数式组件都是“组件”，用 COMPONENT 表示</span></span><br><span class="line">    VNodeFlags.COMPONENT = VNodeFlags.COMPONENT_STATEFUL | VNodeFlags.COMPONENT_FUNCTIONAL</span><br><span class="line">    <span class="comment">// 000111100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>插播位运算知识点复习</p>
<p><a href="[https://lalaze.github.io/2020/04/07/js/js%E4%B8%AD%E7%9A%84%E4%BD%8D%E8%BF%90%E7%AE%97/#more](https://lalaze.github.io/2020/04/07/js/js中的位运算/#more)">js中的位运算</a>{:target=”_blank”}</p>
<p>然后这些flagkey用于节点的flags属性判断他是什么节点了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 例子，判断他是否为vnode</span></span><br><span class="line"><span class="comment">// 使用按位与(&amp;)运算</span></span><br><span class="line">functionalComponentVnode.flags &amp; VNodeFlags.COMPONENT <span class="comment">// 真</span></span><br><span class="line">normalComponentVnode.flags &amp; VNodeFlags.COMPONENT <span class="comment">// 真</span></span><br><span class="line">htmlVnode.flags &amp; VNodeFlags.COMPONENT <span class="comment">// 假</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的运算可以理解成</span></span><br><span class="line">functionalComponentVnode.flags &amp; VNodeFlags.COMPONENT_STATEFUL | VNodeFlags.COMPONENT_FUNCTIONAL </span><br><span class="line"><span class="comment">// 如果这个flags是他们其中的一个，就等于flags&amp;flags就抵掉了</span></span><br></pre></td></tr></table></figure>

<p>这里是用了要判断的vnode的flag属性与上面的衍生属性&amp;了,为真才是那一个衍生属性下面的</p>
<h2 id="children和ChildrenFlags"><a href="#children和ChildrenFlags" class="headerlink" title="children和ChildrenFlags"></a>children和ChildrenFlags</h2><p>我们计划用children属性来表示vnode之间的父子关系的话，我们想一下vnode的children有多少种情况</p>
<ul>
<li>没子节点</li>
<li>只有一个子节点</li>
<li>多个字节点<ul>
<li>有key</li>
<li>无key</li>
</ul>
</li>
<li>不知道啥情况</li>
</ul>
<p>同样用一个childrenFlags来表示这些情况,跟上面那个同理的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ChildrenFlags = &#123;</span><br><span class="line">  <span class="comment">// 未知的 children 类型</span></span><br><span class="line">  UNKNOWN_CHILDREN: <span class="number">0</span>,</span><br><span class="line">  <span class="comment">// 没有 children</span></span><br><span class="line">  NO_CHILDREN: <span class="number">1</span>,</span><br><span class="line">  <span class="comment">// children 是单个 VNode</span></span><br><span class="line">  SINGLE_VNODE: <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// children 是多个拥有 key 的 VNode</span></span><br><span class="line">  KEYED_VNODES: <span class="number">1</span> &lt;&lt; <span class="number">2</span>,</span><br><span class="line">  <span class="comment">// children 是多个没有 key 的 VNode</span></span><br><span class="line">  NONE_KEYED_VNODES: <span class="number">1</span> &lt;&lt; <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  一样有派生节点  这个派生是判断是否为多个子节点的</span></span><br><span class="line">ChildrenFlags.MULTIPLE_VNODES = ChildrenFlags.KEYED_VNODES | ChildrenFlags.NONE_KEYED_VNODES</span><br></pre></td></tr></table></figure>

<h2 id="Vnote的data属性"><a href="#Vnote的data属性" class="headerlink" title="Vnote的data属性"></a>Vnote的data属性</h2><p>data属性放的是data的数据</p>
<p>不论他是组件还是普通节点，我们都可以用这个data来放他相关的数据</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 普通节点</span></span><br><span class="line">&#123;</span><br><span class="line">  flags: VNodeFlags.ELEMENT_HTML,</span><br><span class="line">  tag: <span class="string">'div'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    class: ['class-a', 'active'],</span><br><span class="line">    style: &#123;</span><br><span class="line">      background: <span class="string">'red'</span>,</span><br><span class="line">      color: <span class="string">'green'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 其他数据...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件的data</span></span><br><span class="line">&#123;</span><br><span class="line">  flags: VNodeFlags.COMPONENT_STATEFUL,</span><br><span class="line">  tag: <span class="string">'div'</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    on: &#123;</span><br><span class="line">      <span class="string">'some-event'</span>: handler</span><br><span class="line">    &#125;,</span><br><span class="line">    propA: <span class="string">'1'</span></span><br><span class="line">    <span class="comment">// 其他数据...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="我们的Vnote"><a href="#我们的Vnote" class="headerlink" title="我们的Vnote"></a>我们的Vnote</h2><p>经过一顿操作，我们的Vnote变成了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> interface VNode &#123;</span><br><span class="line">  <span class="comment">// _isVNode 属性在上文中没有提到，它是一个始终为 true 的值，有了它，我们就可以判断一个对象是否是 VNode 对象</span></span><br><span class="line">  _isVNode: <span class="literal">true</span></span><br><span class="line">  <span class="comment">// el 属性在上文中也没有提到，当一个 VNode 被渲染为真实 DOM 之后，el 属性的值会引用该真实DOM</span></span><br><span class="line">  el: Element | <span class="literal">null</span></span><br><span class="line">  flags: VNodeFlags</span><br><span class="line">  tag: string | FunctionalComponent | ComponentClass | <span class="literal">null</span></span><br><span class="line">  data: VNodeData | <span class="literal">null</span></span><br><span class="line">  children: VNodeChildren</span><br><span class="line">  childFlags: ChildrenFlags</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>因为放网上了，还是放原链接</p>
<p><a href="http://hcysun.me/vue-design/zh/" target="_blank" rel="noopener">http://hcysun.me/vue-design/zh/</a></p>
</blockquote>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>源码</tag>
        <tag>读书笔记</tag>
        <tag>框架设计</tag>
      </tags>
  </entry>
  <entry>
    <title>vnode相关函数</title>
    <url>/2020/04/08/vue%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/04.vnode%E7%9A%84%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0h/</url>
    <content><![CDATA[<h2 id="h函数的作用"><a href="#h函数的作用" class="headerlink" title="h函数的作用"></a>h函数的作用</h2><p>不用我们手写vnote，自动创建咯，但是有的情况下还是不要自动创建的好的，所以我们保留了模板与jsx的写法</p>
<p>简单理解，围绕我们设计好的vnote我们要设计一系列的函数来方便我们操作，包括封装函数呀，生成函数呀等等，好的函数可以有助于我们操作</p>
<p>这里我们是将构建vnode的函数为h函数</p>
<h2 id="Vnote创建函数"><a href="#Vnote创建函数" class="headerlink" title="Vnote创建函数"></a>Vnote创建函数</h2><p>一个简单的思路，写一个方法要一堆参数创建vnote</p>
<p>但是参数太多明显使用不方便，所以我们要取一个合适的参数值来让我们舒服使用</p>
<p>这里直接说了答案是三个tag、data、children</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">h</span>(<span class="params">tag, data = null, children = null</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么，先看看我们要啥参数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">h</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    _isVNode: <span class="literal">true</span>, <span class="comment">//默认true，不用管</span></span><br><span class="line">    flags: VNodeFlags.ELEMENT_HTML,  <span class="comment">//可以根据传入的tag判断得出flags</span></span><br><span class="line">    tag: <span class="string">'h1'</span>,</span><br><span class="line">    data: <span class="literal">null</span>,</span><br><span class="line">    children: <span class="literal">null</span>, <span class="comment">// 下面三个有children才有的</span></span><br><span class="line">    childFlags: ChildrenFlags.NO_CHILDREN,</span><br><span class="line">    el: <span class="literal">null</span> </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查flag的代码，如果是字符串就只能是普通便签与svg，否则是组件，当然组件再细分</span></span><br><span class="line"> <span class="keyword">let</span> flags = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> tag === <span class="string">'string'</span>) &#123;</span><br><span class="line">    flags = tag === <span class="string">'svg'</span> ? VNodeFlags.ELEMENT_SVG : VNodeFlags.ELEMENT_HTML</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="根据tag分辨flags"><a href="#根据tag分辨flags" class="headerlink" title="根据tag分辨flags"></a>根据tag分辨flags</h3><p>对于Fragment与文本类型的vnode，他的tag都是null，要区分，我们给h函数的tag增加一个表示，当tag等于这个表示，我们就说他是Fragment</p>
<p>而对于Portal，也可能是字符串，无法通过这个判断出来，所以我们一样增加一个标识</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 唯一标识</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Fragment = <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Portal = <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">h</span>(<span class="params">tag, data = null, children = null</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> flags = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> tag === <span class="string">'string'</span>) &#123;</span><br><span class="line">    flags = tag === <span class="string">'svg'</span> ? VNodeFlags.ELEMENT_SVG : VNodeFlags.ELEMENT_HTML</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tag === Fragment) &#123;</span><br><span class="line">    flags = VNodeFlags.FRAGMENT</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tag === Portal) &#123;</span><br><span class="line">    flags = VNodeFlags.PORTAL</span><br><span class="line">    tag = data &amp;&amp; data.target <span class="comment">//data如果有target，tag变为普通的true</span></span><br><span class="line">      <span class="comment">// portal类型编译好的数据要放在vnodeData里面</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不是上面三种，那他就是组件了，为什么不考虑文本呢，我们一般不直接创建文本节点，直接用字符串，字符串在编译的时候我们判断他是文本字符串，再将他变成文本节点</p>
<p>那么其实是组件的话还是有细分的，下面是代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 省略...</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">h</span>(<span class="params">tag, data = null, children = null</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> flags = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> tag === <span class="string">'string'</span>) &#123;</span><br><span class="line">    flags = tag === <span class="string">'svg'</span> ? VNodeFlags.ELEMENT_SVG : VNodeFlags.ELEMENT_HTML</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tag === Fragment) &#123;</span><br><span class="line">    flags = VNodeFlags.FRAGMENT</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tag === Portal) &#123;</span><br><span class="line">    flags = VNodeFlags.PORTAL</span><br><span class="line">    tag = data &amp;&amp; data.target</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 兼容 Vue2 的对象式组件</span></span><br><span class="line">    <span class="keyword">if</span> (tag !== <span class="literal">null</span> &amp;&amp; <span class="keyword">typeof</span> tag === <span class="string">'object'</span>) &#123;</span><br><span class="line">      flags = tag.functional</span><br><span class="line">        ? VNodeFlags.COMPONENT_FUNCTIONAL       <span class="comment">// 函数式组件</span></span><br><span class="line">        : VNodeFlags.COMPONENT_STATEFUL_NORMAL  <span class="comment">// 有状态组件</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> tag === <span class="string">'function'</span>) &#123;</span><br><span class="line">      <span class="comment">// Vue3 的类组件</span></span><br><span class="line">      flags = tag.prototype &amp;&amp; tag.prototype.render</span><br><span class="line">        ? VNodeFlags.COMPONENT_STATEFUL_NORMAL  <span class="comment">// 有状态组件</span></span><br><span class="line">        : VNodeFlags.COMPONENT_FUNCTIONAL       <span class="comment">// 函数式组件</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里vue2与vue3的区别是，vue2用对象来作为组件的描述，我已我们检查他的functional来查看他是否函数式组件。vue3是用类来表示组件了，有状态的组件会继承基类，所以我们可以用原型链来判断他是不是有状态的组件</p>
<h3 id="确定他的childrenFlags类型"><a href="#确定他的childrenFlags类型" class="headerlink" title="确定他的childrenFlags类型"></a>确定他的childrenFlags类型</h3><p>childrenFlags可能会有什么样的形式呢</p>
<p>数组、vnode对象、没有children、children是一个普通文本</p>
<p>下面是判断方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">h</span>(<span class="params">tag, data = null, children = null</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 省略用于确定 flags 相关的代码</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> childFlags = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(children)) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; length &#125; = children</span><br><span class="line">    <span class="keyword">if</span> (length === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 没有 children</span></span><br><span class="line">      childFlags = ChildrenFlags.NO_CHILDREN</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (length === <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// 单个子节点</span></span><br><span class="line">      childFlags = ChildrenFlags.SINGLE_VNODE</span><br><span class="line">      children = children[<span class="number">0</span>]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 多个子节点，且子节点使用key</span></span><br><span class="line">      childFlags = ChildrenFlags.KEYED_VNODES</span><br><span class="line">      children = normalizeVNodes(children)</span><br><span class="line">		<span class="comment">// 这里是直接给他制造key了，当他是用key的子节点了</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (children == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 没有子节点</span></span><br><span class="line">    childFlags = ChildrenFlags.NO_CHILDREN</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (children._isVNode) &#123;</span><br><span class="line">    <span class="comment">// 单个子节点</span></span><br><span class="line">    childFlags = ChildrenFlags.SINGLE_VNODE</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 其他情况都作为文本节点处理，即单个子节点，会调用 createTextVNode 创建纯文本类型的 VNode</span></span><br><span class="line">    childFlags = ChildrenFlags.SINGLE_VNODE</span><br><span class="line">    children = createTextVNode(children + <span class="string">''</span>)</span><br><span class="line">      <span class="comment">// 创建文本vnode的方法</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 人为制造key</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">normalizeVNodes</span>(<span class="params">children</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> newChildren = []</span><br><span class="line">  <span class="comment">// 遍历 children</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; children.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> child = children[i]</span><br><span class="line">    <span class="keyword">if</span> (child.key == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果原来的 VNode 没有key，则使用竖线(|)与该VNode在数组中的索引拼接而成的字符串作为key</span></span><br><span class="line">      child.key = <span class="string">'|'</span> + i</span><br><span class="line">    &#125;</span><br><span class="line">    newChildren.push(child)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回新的children，此时 children 的类型就是 ChildrenFlags.KEYED_VNODES</span></span><br><span class="line">  <span class="keyword">return</span> newChildren</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建纯文本节点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createTextVNode</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    _isVNode: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// flags 是 VNodeFlags.TEXT</span></span><br><span class="line">    flags: VNodeFlags.TEXT,</span><br><span class="line">    tag: <span class="literal">null</span>,</span><br><span class="line">    data: <span class="literal">null</span>,</span><br><span class="line">    <span class="comment">// 纯文本类型的 VNode，其 children 属性存储的是与之相符的文本内容</span></span><br><span class="line">    children: text,</span><br><span class="line">    <span class="comment">// 文本节点没有子节点</span></span><br><span class="line">    childFlags: ChildrenFlags.NO_CHILDREN,</span><br><span class="line">    el: <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上确定childFlags的代码都是针对非组件的，组件是没有子节点的，遇到组件类型的vnode，我们应该写个方法将children的内容变为slots，然后把他的children变为null，他说后面有讲</p>
<p>实际上这个组装方法还是不是完美的，后面会有改</p>
<p>例如</p>
<p>我们用来尝试一下渲染一个有状态组件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 有状态组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStatefulComponent</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> statefulComponentVNode = h(MyStatefulComponent, <span class="literal">null</span>, h(<span class="string">'div'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到</span></span><br><span class="line"><span class="keyword">const</span> statefulComponentVNode = &#123;</span><br><span class="line">  _isVNode: <span class="literal">true</span>,</span><br><span class="line">  flags: <span class="number">32</span>,  <span class="comment">// VNodeFlags.COMPONENT_FUNCTIONAL</span></span><br><span class="line">  tag: MyStatefulComponent,</span><br><span class="line">  data: <span class="literal">null</span>,</span><br><span class="line">  children: &#123;</span><br><span class="line">    _isVNode: <span class="literal">true</span>,</span><br><span class="line">    flags: <span class="number">1</span>,</span><br><span class="line">    tag: <span class="string">'div'</span>,</span><br><span class="line">    data: <span class="literal">null</span>,</span><br><span class="line">    children: <span class="literal">null</span>,</span><br><span class="line">    childFlags: <span class="number">1</span>,</span><br><span class="line">    el: <span class="literal">null</span></span><br><span class="line">  &#125;,</span><br><span class="line">  childFlags: <span class="number">2</span>,</span><br><span class="line">  el: <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>产出了函数式组件，因为我们的vnode没有继承render函数（看上面的分别方法）</p>
<p>这是因为前面02说的挂载组件方法,</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">mountElement(instance.$vnode, container)</span><br></pre></td></tr></table></figure>

<p>这个方法我们还没有实现，但是他是调用组件的render方法实现挂载的</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>源码</tag>
        <tag>读书笔记</tag>
        <tag>框架设计</tag>
      </tags>
  </entry>
  <entry>
    <title>阶段总结</title>
    <url>/2020/04/08/vue%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/05.%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>总结一下目前看到这里的vnode设计与vnode的辅助函数</p>
<p>如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> VNodeFlags = &#123;</span><br><span class="line">    <span class="comment">// html 标签</span></span><br><span class="line">    ELEMENT_HTML: <span class="number">1</span>,</span><br><span class="line">    <span class="comment">// SVG 标签</span></span><br><span class="line">    ELEMENT_SVG: <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</span><br><span class="line">    <span class="comment">// 普通有状态组件</span></span><br><span class="line">    COMPONENT_STATEFUL_NORMAL: <span class="number">1</span> &lt;&lt; <span class="number">2</span>,</span><br><span class="line">    <span class="comment">// 需要被keepAlive的有状态组件</span></span><br><span class="line">    COMPONENT_STATEFUL_SHOULD_KEEP_ALIVE: <span class="number">1</span> &lt;&lt; <span class="number">3</span>,</span><br><span class="line">    <span class="comment">// 已经被keepAlive的有状态组件</span></span><br><span class="line">    COMPONENT_STATEFUL_KEPT_ALIVE: <span class="number">1</span> &lt;&lt; <span class="number">4</span>,</span><br><span class="line">    <span class="comment">// 函数式组件</span></span><br><span class="line">    COMPONENT_FUNCTIONAL: <span class="number">1</span> &lt;&lt; <span class="number">5</span>,</span><br><span class="line">    <span class="comment">// 纯文本</span></span><br><span class="line">    TEXT: <span class="number">1</span> &lt;&lt; <span class="number">6</span>,</span><br><span class="line">    <span class="comment">// Fragment</span></span><br><span class="line">    FRAGMENT: <span class="number">1</span> &lt;&lt; <span class="number">7</span>,</span><br><span class="line">    <span class="comment">// Portal</span></span><br><span class="line">    PORTAL: <span class="number">1</span> &lt;&lt; <span class="number">8</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// html 和 svg 都是标签元素，可以用 ELEMENT 表示</span></span><br><span class="line">VNodeFlags.ELEMENT = VNodeFlags.ELEMENT_HTML | VNodeFlags.ELEMENT_SVG</span><br><span class="line"><span class="comment">// 普通有状态组件、需要被keepAlive的有状态组件、已经被keepAlice的有状态组件 都是“有状态组件”，统一用 COMPONENT_STATEFUL 表示</span></span><br><span class="line">VNodeFlags.COMPONENT_STATEFUL =</span><br><span class="line">    VNodeFlags.COMPONENT_STATEFUL_NORMAL |</span><br><span class="line">    VNodeFlags.COMPONENT_STATEFUL_SHOULD_KEEP_ALIVE |</span><br><span class="line">    VNodeFlags.COMPONENT_STATEFUL_KEPT_ALIVE</span><br><span class="line"><span class="comment">// 有状态组件 和  函数式组件都是“组件”，用 COMPONENT 表示</span></span><br><span class="line">VNodeFlags.COMPONENT = VNodeFlags.COMPONENT_STATEFUL | VNodeFlags.COMPONENT_FUNCTIONAL</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ChildrenFlags = &#123;</span><br><span class="line">    <span class="comment">// 未知的 children 类型</span></span><br><span class="line">    UNKNOWN_CHILDREN: <span class="number">0</span>,</span><br><span class="line">    <span class="comment">// 没有 children</span></span><br><span class="line">    NO_CHILDREN: <span class="number">1</span>,</span><br><span class="line">    <span class="comment">// children 是单个 VNode</span></span><br><span class="line">    SINGLE_VNODE: <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// children 是多个拥有 key 的 VNode</span></span><br><span class="line">    KEYED_VNODES: <span class="number">1</span> &lt;&lt; <span class="number">2</span>,</span><br><span class="line">    <span class="comment">// children 是多个没有 key 的 VNode</span></span><br><span class="line">    NONE_KEYED_VNODES: <span class="number">1</span> &lt;&lt; <span class="number">3</span>,</span><br><span class="line">&#125;</span><br><span class="line">ChildrenFlags.MULTIPLE_VNODES = ChildrenFlags.KEYED_VNODES | ChildrenFlags.NONE_KEYED_VNODES</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组建vnode的h函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件vnode的辅助函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 人为制造key</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">normalizeVNodes</span>(<span class="params">children</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> newChildren = []</span><br><span class="line">    <span class="comment">// 遍历 children</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; children.length; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> child = children[i]</span><br><span class="line">        <span class="keyword">if</span> (child.key == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果原来的 VNode 没有key，则使用竖线(|)与该VNode在数组中的索引拼接而成的字符串作为key</span></span><br><span class="line">            child.key = <span class="string">'|'</span> + i</span><br><span class="line">        &#125;</span><br><span class="line">        newChildren.push(child)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回新的children，此时 children 的类型就是 ChildrenFlags.KEYED_VNODES</span></span><br><span class="line">    <span class="keyword">return</span> newChildren</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创造文本节点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createTextVNode</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        _isVNode: <span class="literal">true</span>,</span><br><span class="line">        <span class="comment">// flags 是 VNodeFlags.TEXT</span></span><br><span class="line">        flags: VNodeFlags.TEXT,</span><br><span class="line">        tag: <span class="literal">null</span>,</span><br><span class="line">        data: <span class="literal">null</span>,</span><br><span class="line">        <span class="comment">// 纯文本类型的 VNode，其 children 属性存储的是与之相符的文本内容</span></span><br><span class="line">        children: text,</span><br><span class="line">        <span class="comment">// 文本节点没有子节点</span></span><br><span class="line">        childFlags: ChildrenFlags.NO_CHILDREN,</span><br><span class="line">        el: <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 唯一标识  为了如果有多个不同的vnode同时进行渲染</span></span><br><span class="line"><span class="keyword">const</span> Fragment = <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="keyword">const</span> Portal = <span class="built_in">Symbol</span>()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">h</span>(<span class="params">tag, data = null, children = null</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 根据tag得出flag</span></span><br><span class="line">    <span class="keyword">let</span> flags = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> tag === <span class="string">'string'</span>) &#123;</span><br><span class="line">        flags = tag === <span class="string">'svg'</span> ? VNodeFlags.ELEMENT_SVG : VNodeFlags.ELEMENT_HTML</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tag === Fragment) &#123;</span><br><span class="line">        flags = VNodeFlags.FRAGMENT</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tag === Portal) &#123;</span><br><span class="line">        flags = VNodeFlags.PORTAL</span><br><span class="line">        tag = data &amp;&amp; data.target</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 兼容 Vue2 的对象式组件</span></span><br><span class="line">        <span class="keyword">if</span> (tag !== <span class="literal">null</span> &amp;&amp; <span class="keyword">typeof</span> tag === <span class="string">'object'</span>) &#123;</span><br><span class="line">            flags = tag.functional ?</span><br><span class="line">                VNodeFlags.COMPONENT_FUNCTIONAL <span class="comment">// 函数式组件</span></span><br><span class="line">                :</span><br><span class="line">                VNodeFlags.COMPONENT_STATEFUL_NORMAL <span class="comment">// 有状态组件</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> tag === <span class="string">'function'</span>) &#123;</span><br><span class="line">            <span class="comment">// Vue3 的类组件</span></span><br><span class="line">            flags = tag.prototype &amp;&amp; tag.prototype.render ?</span><br><span class="line">                VNodeFlags.COMPONENT_STATEFUL_NORMAL <span class="comment">// 有状态组件</span></span><br><span class="line">                :</span><br><span class="line">                VNodeFlags.COMPONENT_FUNCTIONAL <span class="comment">// 函数式组件</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确定children Flagss</span></span><br><span class="line">    <span class="keyword">let</span> childFlags = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(children)) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;</span><br><span class="line">            length</span><br><span class="line">        &#125; = children</span><br><span class="line">        <span class="keyword">if</span> (length === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 没有 children</span></span><br><span class="line">            childFlags = ChildrenFlags.NO_CHILDREN</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (length === <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 单个子节点</span></span><br><span class="line">            childFlags = ChildrenFlags.SINGLE_VNODE</span><br><span class="line">            children = children[<span class="number">0</span>]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 多个子节点，且子节点使用key</span></span><br><span class="line">            childFlags = ChildrenFlags.KEYED_VNODES</span><br><span class="line">            children = normalizeVNodes(children)</span><br><span class="line">            <span class="comment">// 这里是直接给他制造key了，当他是用key的子节点了</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (children == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 没有子节点</span></span><br><span class="line">        childFlags = ChildrenFlags.NO_CHILDREN</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (children._isVNode) &#123;</span><br><span class="line">        <span class="comment">// 单个子节点</span></span><br><span class="line">        childFlags = ChildrenFlags.SINGLE_VNODE</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 其他情况都作为文本节点处理，即单个子节点，会调用 createTextVNode 创建纯文本类型的 VNode</span></span><br><span class="line">        childFlags = ChildrenFlags.SINGLE_VNODE</span><br><span class="line">        children = createTextVNode(children + <span class="string">''</span>)</span><br><span class="line">        <span class="comment">// 创建文本vnode的方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        _isVNode: <span class="literal">true</span>, <span class="comment">//默认true，不用管</span></span><br><span class="line">        flags: flags, <span class="comment">//可以根据传入的tag判断得出flags</span></span><br><span class="line">        tag: tag,</span><br><span class="line">        data: data,</span><br><span class="line">        children: children, <span class="comment">// 下面三个有children才有的</span></span><br><span class="line">        childFlags: childFlags,</span><br><span class="line">        el: <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> portalVNode = h(</span><br><span class="line">    Portal, &#123;</span><br><span class="line">        target: <span class="string">'#box'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    h(<span class="string">'h1'</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(h('div', null, h('span')))</span></span><br><span class="line"><span class="comment">// console.log(h('div', null, '我是文本'))</span></span><br><span class="line"><span class="comment">// console.log(portalVNode)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有状态要继承render函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">'组件缺少 render 函数'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStatefulComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> statefulComponentVNode = h(MyStatefulComponent, <span class="literal">null</span>, h(<span class="string">'div'</span>))</span><br><span class="line"><span class="built_in">console</span>.log(statefulComponentVNode)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>源码</tag>
        <tag>读书笔记</tag>
        <tag>框架设计</tag>
      </tags>
  </entry>
  <entry>
    <title>渲染器mount下</title>
    <url>/2020/04/09/vue%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/07.%E6%B8%B2%E6%9F%93%E5%99%A8mount%E4%B8%8B/</url>
    <content><![CDATA[<h2 id="有状态组件的挂载和原理"><a href="#有状态组件的挂载和原理" class="headerlink" title="有状态组件的挂载和原理"></a>有状态组件的挂载和原理</h2><p>组件分为有状态组件与函数式组件</p>
<blockquote>
<p>有状态组件可以更改数据，无状态组件不可以，因此有状态组件有生命周期函数，无状态组件没有生命周期函数，一句话无状态组件没有数据，只有逻辑</p>
</blockquote>
<p>moute函数就要开始区分这两个东西</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountComponent</span>(<span class="params">vnode, container, isSVG</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (vnode.flags &amp; VNodeFlags.COMPONENT_STATEFUL) &#123;</span><br><span class="line">    mountStatefulComponent(vnode, container, isSVG)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    mountFunctionalComponent(vnode, container, isSVG)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountStatefulComponent</span>(<span class="params">vnode, container, isSVG</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建组件实例</span></span><br><span class="line">  <span class="keyword">const</span> instance = <span class="keyword">new</span> vnode.tag()</span><br><span class="line">  <span class="comment">// 有状态组件的tag就是他要得组件，new一个</span></span><br><span class="line">  <span class="comment">// 渲染VNode</span></span><br><span class="line">  instance.$vnode = instance.render()</span><br><span class="line">    <span class="comment">//渲染出具体内容</span></span><br><span class="line">  <span class="comment">// 挂载</span></span><br><span class="line">  mount(instance.$vnode, container, isSVG)</span><br><span class="line">    <span class="comment">// 挂载</span></span><br><span class="line">  <span class="comment">// el 属性值 和 组件实例的 $el 属性都引用组件的根DOM元素</span></span><br><span class="line">  instance.$el = vnode.el = instance.$vnode.el</span><br><span class="line">    <span class="comment">// 绑定真实dom</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里还没有体现生命周期，就只是挂载而已</p>
</blockquote>
<h2 id="函数式组件的挂载与原来"><a href="#函数式组件的挂载与原来" class="headerlink" title="函数式组件的挂载与原来"></a>函数式组件的挂载与原来</h2><p>函数式组件就是返回vnode的函数</p>
<p>函数式组件本身就是一个函数，他会直接返回vnode</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountFunctionalComponent</span>(<span class="params">vnode, container, isSVG</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取 VNode</span></span><br><span class="line">  <span class="keyword">const</span> $vnode = vnode.tag()</span><br><span class="line">  <span class="comment">// new的时候就返回了vnode，直接挂载得了</span></span><br><span class="line">  <span class="comment">// 挂载</span></span><br><span class="line">  mount($vnode, container, isSVG)</span><br><span class="line">  <span class="comment">// el 元素引用该组件的根元素</span></span><br><span class="line">  vnode.el = $vnode.el</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重点是函数式组件没有了data，不用插入生命周期，watch等，就很好</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>源码</tag>
        <tag>读书笔记</tag>
        <tag>框架设计</tag>
      </tags>
  </entry>
  <entry>
    <title>渲染器mount上</title>
    <url>/2020/04/09/vue%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/06.%E6%B8%B2%E6%9F%93%E5%99%A8mount%E4%B8%8A/</url>
    <content><![CDATA[<h2 id="渲染器工作流程"><a href="#渲染器工作流程" class="headerlink" title="渲染器工作流程"></a>渲染器工作流程</h2><p>上一章写了一个组装vnode的函数，现在就讲怎么将组装好的vnode渲染为html的dom了</p>
<p>渲染器的工作一般分两个阶段</p>
<ul>
<li>mount：如果vnode不存在，直接将新的vnode挂载成全新的dom</li>
<li>patch：如果旧的vnode存在，将旧的vnode与新的vnode做比较，试图以最小的资源开销完成dom的更新</li>
</ul>
<p>一般渲染器接受两个参数，一个是要渲染的vnode，一个是要挂载的地点</p>
<p>具体流程如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">vnode, container</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> prevVNode = container.vnode</span><br><span class="line">  <span class="keyword">if</span> (prevVNode == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (vnode) &#123;</span><br><span class="line">      <span class="comment">// 没有旧的 VNode，只有新的 VNode。使用 `mount` 函数挂载全新的 VNode</span></span><br><span class="line">      mount(vnode, container)</span><br><span class="line">      <span class="comment">// 将新的 VNode 添加到 container.vnode 属性下，这样下一次渲染时旧的 VNode 就存在了</span></span><br><span class="line">      container.vnode = vnode</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (vnode) &#123;</span><br><span class="line">      <span class="comment">// 有旧的 VNode，也有新的 VNode。则调用 `patch` 函数打补丁</span></span><br><span class="line">      patch(prevVNode, vnode, container)</span><br><span class="line">      <span class="comment">// 更新 container.vnode</span></span><br><span class="line">      container.vnode = vnode</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 有旧的 VNode 但是没有新的 VNode，这说明应该移除 DOM，在浏览器中可以使用 removeChild 函数。</span></span><br><span class="line">      container.removeChild(prevVNode.el)</span><br><span class="line">      container.vnode = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上是渲染器最基本的操作，同时他还附带着</p>
<ul>
<li>控制组件的生命周期钩子函数调用</li>
<li>多端渲染的桥梁<ul>
<li>意思是我这个render方法可以做到适配到不同平台例如web与手机的中间层，render之后调用我想要的平台的方法挂载dom</li>
</ul>
</li>
<li>异步渲染<ul>
<li>究级加快速度，因为异步渲染好，组件的挂载，dom的变更，dom的时间等时机判断都不一样了，vue3是用调度器来完成得</li>
</ul>
</li>
<li>diff算法、<ul>
<li>就是比对新旧dom的算法</li>
</ul>
</li>
</ul>
<h2 id="挂载普通标签元素"><a href="#挂载普通标签元素" class="headerlink" title="挂载普通标签元素"></a>挂载普通标签元素</h2><p>我们先从最普通的标签元素开始</p>
<p>先从mount开始</p>
<h3 id="mount普通标签"><a href="#mount普通标签" class="headerlink" title="mount普通标签"></a>mount普通标签</h3><p>首先不同的vnode要有不同的挂载方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mount</span>(<span class="params">vnode, container</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; flags &#125; = vnode</span><br><span class="line">  <span class="keyword">if</span> (flags &amp; VNodeFlags.ELEMENT) &#123;  <span class="comment">// &amp; 二进制  这里相当于==</span></span><br><span class="line">    <span class="comment">// 挂载普通标签</span></span><br><span class="line">    mountElement(vnode, container)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flags &amp; VNodeFlags.COMPONENT) &#123;</span><br><span class="line">    <span class="comment">// 挂载组件</span></span><br><span class="line">    mountComponent(vnode, container)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flags &amp; VNodeFlags.TEXT) &#123;</span><br><span class="line">    <span class="comment">// 挂载纯文本</span></span><br><span class="line">    mountText(vnode, container)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flags &amp; VNodeFlags.FRAGMENT) &#123;</span><br><span class="line">    <span class="comment">// 挂载 Fragment</span></span><br><span class="line">    mountFragment(vnode, container)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flags &amp; VNodeFlags.PORTAL) &#123;</span><br><span class="line">    <span class="comment">// 挂载 Portal</span></span><br><span class="line">    mountPortal(vnode, container)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到是有不同的挂载函数的</p>
<p>还是先看最普通的标签挂载</p>
<p>各种情况的处理我直接写注释了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &lt;circle&gt; 是svg标签，但是我们前面写的vnode只匹配了svg，加入第三个参数isSVG</span></span><br><span class="line"><span class="comment">// 补 circle是只可能出现在svg标签里面的子标签，所以是为了解决svg的children没有按svg方法创建节点，传递isSVG</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountElement</span>(<span class="params">vnode, container,isSVG</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 兼容svg的创建节点方式</span></span><br><span class="line">  <span class="keyword">const</span> isSVG = vnode.flags &amp; VNodeFlags.ELEMENT_SVG</span><br><span class="line">  <span class="keyword">const</span> el = isSVG</span><br><span class="line">    ? <span class="built_in">document</span>.createElementNS(<span class="string">'http://www.w3.org/2000/svg'</span>, vnode.tag)</span><br><span class="line">    : <span class="built_in">document</span>.createElement(vnode.tag)</span><br><span class="line">  </span><br><span class="line">  vnode.el = el <span class="comment">// 保存创建的el节点</span></span><br><span class="line">  <span class="comment">// 挂载vnodeData style class等</span></span><br><span class="line">  <span class="keyword">const</span> data = vnode.data</span><br><span class="line">  <span class="keyword">if</span> (data) &#123;</span><br><span class="line">    <span class="comment">// 如果 VNodeData 存在，则遍历之</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> data) &#123;</span><br><span class="line">      <span class="comment">// key 可能是 class、style其他等等</span></span><br><span class="line">      <span class="keyword">switch</span>(key) &#123;  <span class="comment">//这里只写了一个case：style，还有其他情况</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">'style'</span>:</span><br><span class="line">          <span class="comment">// 如果 key 的值是 style，说明是内联样式，逐个将样式规则应用到 el</span></span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">let</span> k <span class="keyword">in</span> data.style) &#123;</span><br><span class="line">            el.style[k] = data.style[k]</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">         <span class="keyword">case</span> <span class="string">'class'</span>:</span><br><span class="line">          el.className = data[key]</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 递归挂载子节点</span></span><br><span class="line">  <span class="keyword">const</span> childFlags = vnode.childFlags</span><br><span class="line">  <span class="keyword">const</span> children = vnode.children</span><br><span class="line">  <span class="comment">// 检测如果没有子节点则无需递归挂载</span></span><br><span class="line">  <span class="keyword">if</span> (childFlags !== ChildrenFlags.NO_CHILDREN) &#123;</span><br><span class="line">    <span class="keyword">if</span> (childFlags &amp; ChildrenFlags.SINGLE_VNODE) &#123;</span><br><span class="line">      <span class="comment">// 如果是单个子节点则调用 mount 函数挂载</span></span><br><span class="line">      mount(children, el,isSVG)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childFlags &amp; ChildrenFlags.MULTIPLE_VNODES) &#123;</span><br><span class="line">      <span class="comment">// 如果是单多个子节点则遍历并调用 mount 函数挂载</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; children.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 调用moute是因为子节点是可能是不同类型，不是普通的html文本</span></span><br><span class="line">          mount(children[i], el,isSVG)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">      </span><br><span class="line">  container.appendChild(el)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到上面是加了class的，但是目前是直接字符串的设计，不能动态class，同时我们也要考虑数组、对象的结构形式</p>
<p>可以写一个算法将h编译前的传进来的各种数据结构的class进行转换</p>
<p>说明下动态变化进来的是已经定了的数据，不会再变了</p>
<p>算法如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">normalizeClass</span>(<span class="params">classValue</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// res 是最终要返回的类名字符串</span></span><br><span class="line">  <span class="keyword">let</span> res = <span class="string">''</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> classValue === <span class="string">'string'</span>) &#123;</span><br><span class="line">    res = classValue</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(classValue)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; classValue.length; i++) &#123;</span><br><span class="line">      res += normalizeClass(classValue[i]) + <span class="string">' '</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> classValue === <span class="string">'object'</span>) &#123;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> name <span class="keyword">in</span> classValue) &#123;</span><br><span class="line">      <span class="keyword">if</span> (classValue[name]) &#123;</span><br><span class="line">        res += name + <span class="string">' '</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res.trim()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里这个class体现的是你设计的使用方式与你最终代码之间的数据衔接转换，这个是我们要考虑的</p>
<h4 id="普通标签元素的Attributes和DOMProperties"><a href="#普通标签元素的Attributes和DOMProperties" class="headerlink" title="普通标签元素的Attributes和DOMProperties"></a>普通标签元素的Attributes和DOMProperties</h4><ul>
<li>attr指的是id、class等存在于标签上的属性</li>
<li>DOM prop 也是存在于标签上的属性，但是有一些不同，他是我们自定义的，跟上面的有什么区别呢？</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &lt;body id="page"&gt;&lt;/body&gt;  这个id就是attr</span></span><br><span class="line"><span class="comment">// &lt;body custom="val"&gt;&lt;/body&gt;  这个custom就是DOM prop</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.custom =&gt; <span class="literal">undefined</span>  dom prop无法这样读取</span><br><span class="line">可以用setAttribut方法设置，但是不能设置全部</span><br><span class="line"></span><br><span class="line"><span class="comment">// checkbox 元素</span></span><br><span class="line"><span class="keyword">const</span> checkboxEl = <span class="built_in">document</span>.querySelector(<span class="string">'input'</span>)</span><br><span class="line"><span class="comment">// 使用 setAttribute 设置 checked 属性为 false</span></span><br><span class="line">checkboxEl.setAttribute(<span class="string">'checked'</span>, <span class="literal">false</span>)</span><br><span class="line"><span class="comment">// 这个false设置的时候转换为了'false'设置进去，字符串就是true了</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(checkboxEl.checked) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>所以有些属性不能通过setAttribut设置。value、checked、selected、muted都不能用</p>
<p>我们由此的出同样是标签上的元素，也有两种，会有区别的</p>
<p>接下来我们想办法为我们的vnote可以挂载更多属性（前面设置了style与class）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 我们目前实现的有</span></span><br><span class="line">&#123;</span><br><span class="line">  style: ..., <span class="comment">// 内联样式数据</span></span><br><span class="line">  class: ..., // class 数据</span><br><span class="line">  target: ... <span class="comment">// Portal 的挂载目标</span></span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 我们要排除target，因为他是protal的属性</span></span><br><span class="line"> <span class="comment">// 用正则匹配不能用setAttribut的属性，原生dom自有的，直接等于就行</span></span><br><span class="line">  <span class="keyword">const</span> domPropsRE = <span class="regexp">/\[A-Z]|^(?:value|checked|selected|muted)$/</span></span><br><span class="line">  <span class="comment">// 这个正则同时匹配有大写字母的属性例如innHTML、textContent等做dom prop处理</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 在data的转换里面加情况</span></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">          <span class="keyword">if</span> (domPropsRE.test(key)) &#123;</span><br><span class="line">            <span class="comment">// 当作 DOM Prop 处理</span></span><br><span class="line">            el[key] = data[key]</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当作 Attr 处理</span></span><br><span class="line">            el.setAttribute(key, data[key])</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<p>说要处理target，但是好像没看到，不过target放上去好像也没什么影响，后面待定</p>
<h4 id="为dom添加事件"><a href="#为dom添加事件" class="headerlink" title="为dom添加事件"></a>为dom添加事件</h4><p>mount阶段添加时间直接用addEventListener就可以了</p>
<p>但是我们的vnote要设计好</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 我们的html写成这个亚子</span></span><br><span class="line"><span class="comment">// &lt;div @click="handler"&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="comment">// 对应我们的vnote设计</span></span><br><span class="line"><span class="keyword">const</span> elementVNode = h(<span class="string">'div'</span>, &#123;</span><br><span class="line">  onclick: handler</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有的事件都是on开头的，我们按照这个匹配对照属性上面给他加时间</span></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">if</span> (key[<span class="number">0</span>] === <span class="string">'o'</span> &amp;&amp; key[<span class="number">1</span>] === <span class="string">'n'</span>) &#123;</span><br><span class="line">    <span class="comment">// 事件</span></span><br><span class="line">    el.addEventListener(key.slice(<span class="number">2</span>), data[key])</span><br><span class="line">    <span class="comment">// addEventListener添加时间是没有on的去除</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (domPropsRE.test(key)) &#123;</span><br><span class="line">    <span class="comment">// 当作 DOM Prop 处理</span></span><br><span class="line">    el[key] = data[key]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 当作 Attr 处理</span></span><br><span class="line">    el.setAttribute(key, data[key])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<h2 id="挂载纯文本、Fragment、Portal"><a href="#挂载纯文本、Fragment、Portal" class="headerlink" title="挂载纯文本、Fragment、Portal"></a>挂载纯文本、Fragment、Portal</h2><h3 id="mount文本节点"><a href="#mount文本节点" class="headerlink" title="mount文本节点"></a>mount文本节点</h3><p>一个mouteText方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountText</span>(<span class="params">vnode, container</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> el = <span class="built_in">document</span>.createTextNode(vnode.children) <span class="comment">// 用原生的createTextNode方法</span></span><br><span class="line">  vnode.el = el</span><br><span class="line">  container.appendChild(el)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="挂载Fragment"><a href="#挂载Fragment" class="headerlink" title="挂载Fragment"></a>挂载Fragment</h3><p>理论上Fragment与一个vnode的children没有区别，只是他们外面的标签有区别</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Fragment</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Fragment</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>区别是Fragment不会被渲染出来，还有他们的flags不一样，Fragment是VNodeFlags.FRAGMENT，然后elementVNode的我flags是 VNodeFlags.ELEMENT_HTML</p>
<p>实现</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountFragment</span>(<span class="params">vnode, container, isSVG</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 拿到 children 和 childFlags</span></span><br><span class="line">  <span class="keyword">const</span> &#123; children, childFlags &#125; = vnode</span><br><span class="line">  <span class="keyword">switch</span> (childFlags) &#123;</span><br><span class="line">    <span class="keyword">case</span> ChildrenFlags.SINGLE_VNODE:</span><br><span class="line">      <span class="comment">// 如果是单个子节点，则直接调用 mount</span></span><br><span class="line">      mount(children, container, isSVG)</span><br><span class="line">          <span class="comment">// 单个子节点，指向这个节点</span></span><br><span class="line">          vnode.el = children.el</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> ChildrenFlags.NO_CHILDREN:</span><br><span class="line">      <span class="comment">// 如果没有子节点，等价于挂载空片段，会创建一个空的文本节点占位</span></span><br><span class="line">      <span class="keyword">const</span> placeholder = createTextVNode(<span class="string">''</span>)</span><br><span class="line">      mountText(placeholder, container)</span><br><span class="line">          <span class="comment">// 没有子节点指向占位的空文本节点</span></span><br><span class="line">          vnode.el = placeholder.el</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="comment">// 多个子节点，遍历挂载之</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; children.length; i++) &#123;</span><br><span class="line">        mount(children[i], container, isSVG)</span><br><span class="line">      &#125;</span><br><span class="line">          <span class="comment">// 多个子节点指向第一个子节点</span></span><br><span class="line">          vnode.el = children[<span class="number">0</span>].el</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意flagment不同情况下的el挂载点是不一样的</p>
<h3 id="挂载Portal"><a href="#挂载Portal" class="headerlink" title="挂载Portal"></a>挂载Portal</h3><p>实现Portal就是将Portal的vnode挂载到他的tag属性所指的挂载点上</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountPortal</span>(<span class="params">vnode, container</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; tag, children, childFlags &#125; = vnode</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取挂载点</span></span><br><span class="line">  <span class="keyword">const</span> target = <span class="keyword">typeof</span> tag === <span class="string">'string'</span> ? <span class="built_in">document</span>.querySelector(tag) : tag</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (childFlags &amp; ChildrenFlags.SINGLE_VNODE) &#123;</span><br><span class="line">    <span class="comment">// 将 children 挂载到 target 上，而非 container</span></span><br><span class="line">    mount(children, target)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childFlags &amp; ChildrenFlags.MULTIPLE_VNODES) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; children.length; i++) &#123;</span><br><span class="line">      <span class="comment">// 将 children 挂载到 target 上，而非 container</span></span><br><span class="line">      mount(children[i], target)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="comment">// 占位的空文本节点</span></span><br><span class="line">  <span class="keyword">const</span> placeholder = createTextVNode(<span class="string">''</span>)</span><br><span class="line">  <span class="comment">// 将该节点挂载到 container 中</span></span><br><span class="line">  mountText(placeholder, container, <span class="literal">null</span>)</span><br><span class="line">    <span class="comment">// 注意这里是挂载到container下了，而不是target，空节点在container下</span></span><br><span class="line">  <span class="comment">// el 属性引用该节点</span></span><br><span class="line">  vnode.el = placeholder.el</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思考为什么要展位的空节点文本，我们设计的portal是希望他可以挂载到任何位置，但是他的行为应该像普通的dom元素一样，有事件有属性，我们就需要一个dom结构来承接这个事件与属性了，所以这里用了一个空的文本节点</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>源码</tag>
        <tag>读书笔记</tag>
        <tag>框架设计</tag>
      </tags>
  </entry>
  <entry>
    <title>vue源码学习/09.diff1</title>
    <url>/2020/04/13/vue%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/09.diff1/</url>
    <content><![CDATA[<h2 id="没有key时候的diff"><a href="#没有key时候的diff" class="headerlink" title="没有key时候的diff"></a>没有key时候的diff</h2><p>在patch里面，我们说只有遇到了新旧vnode都是多个子节点的情况下我们才要用到diff算法进行同层级的比较，现在就来说说</p>
<p>我们之前写的代码是</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">patchChildren</span><br><span class="line">---</span><br><span class="line"><span class="comment">// 遍历旧的子节点，将其全部移除</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; prevChildren.length; i++) &#123;</span><br><span class="line">	container.removeChild(prevChildren[i].el)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 遍历新的子节点，将其全部添加</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nextChildren.length; i++) &#123;</span><br><span class="line">    mount(nextChildren[i], container)</span><br><span class="line">&#125;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>这个亚子不是最优解，肯定开销比较大，正确应该是只要他们是同个标签，我们就比对新旧vnode的区别，达到节省资源的目的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">patchChildren</span><br><span class="line">---</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; prevChildren.length; i++) &#123;</span><br><span class="line">	patch(prevChildren[i], nextChildren[i], container)</span><br><span class="line">&#125;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>但是这个写法是假定他们长度一定的，如果新旧vnode的childrens长度不一定，就是有新增或者删除的情况，不能这样写，改为</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取公共长度，取新旧 children 长度较小的那一个</span></span><br><span class="line"><span class="keyword">const</span> prevLen = prevChildren.length</span><br><span class="line"><span class="keyword">const</span> nextLen = nextChildren.length</span><br><span class="line"><span class="keyword">const</span> commonLength = prevLen &gt; nextLen ? nextLen : prevLen</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; commonLength; i++) &#123;</span><br><span class="line">    patch(prevChildren[i], nextChildren[i], container)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果 nextLen &gt; prevLen，将多出来的元素添加</span></span><br><span class="line"><span class="keyword">if</span> (nextLen &gt; prevLen) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = commonLength; i &lt; nextLen; i++) &#123;</span><br><span class="line">        mount(nextChildren[i], container)</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (prevLen &gt; nextLen) &#123;</span><br><span class="line">    <span class="comment">// 如果 prevLen &gt; nextLen，将多出来的元素移除</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = commonLength; i &lt; prevLen; i++) &#123;</span><br><span class="line">        container.removeChild(prevChildren[i].el)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个比我们第一个好，但是踏实没有key的情况下采用，有key的话可以更快</p>
<h2 id="引入key"><a href="#引入key" class="headerlink" title="引入key"></a>引入key</h2><p>就是为了进一步加快，要更快，key一样的甚至可以通过移动解决 ，要通过移动来解决的话，就要添加唯一标识码，那就是key了</p>
<p>在创建vnode的时候就多给一个字段引入了key</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line"><span class="comment">// 返回 VNode 对象</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    _isVNode: <span class="literal">true</span>,</span><br><span class="line">    flags,</span><br><span class="line">    tag,</span><br><span class="line">    data,</span><br><span class="line">    key: data &amp;&amp; data.key ? data.key : <span class="literal">null</span>,</span><br><span class="line">    children,</span><br><span class="line">    childFlags,</span><br><span class="line">    el: <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>然后再patch的时候，遍历新children中的每一个节点，并去旧的children中寻找是否存在相同key的节点旧可以拉</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历新的 children</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nextChildren.length; i++) &#123;</span><br><span class="line">  <span class="keyword">const</span> nextVNode = nextChildren[i]</span><br><span class="line">  <span class="keyword">let</span> j = <span class="number">0</span></span><br><span class="line">  <span class="comment">// 遍历旧的 children</span></span><br><span class="line">  <span class="keyword">for</span> (j; j &lt; prevChildren.length; j++) &#123;</span><br><span class="line">    <span class="keyword">const</span> prevVNode = prevChildren[j]</span><br><span class="line">    <span class="comment">// 如果找到了具有相同 key 值的两个节点，则调用 `patch` 函数更新之</span></span><br><span class="line">    <span class="keyword">if</span> (nextVNode.key === prevVNode.key) &#123;</span><br><span class="line">      patch(prevVNode, nextVNode, container)</span><br><span class="line">      <span class="keyword">break</span> <span class="comment">// 这里需要 break</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>双循环判断，如果有标识一样的就应用patch，同事patch里面会对比他们的vnodeData与子节点，如果都没有变化，那patch就什么都不做，所有的所有都是为了服务这一步增加速度</p>
<h2 id="找到需要移动的节点"><a href="#找到需要移动的节点" class="headerlink" title="找到需要移动的节点"></a>找到需要移动的节点</h2><p>怎么判断这个节点要不要移动，怎么移动是关键咯</p>
<p>首先在旧children中，所遇到的最大索引值，就是children最后一个，如果找的过程中发现比最大索引值小的节点说明他要移动，我们用一个叫lastIndex的变量放他</p>
<p>这里的解法是，因为我们是拿着新节点的key去按着旧的节点循环拿索引，如果顺序没变，就是0、1、2…这样子，如果我们循环的时候突然发现，不是012，非递增了，说明要移动了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用来存储寻找过程中遇到的最大索引值</span></span><br><span class="line"><span class="keyword">let</span> lastIndex = <span class="number">0</span></span><br><span class="line"><span class="comment">// 遍历新的 children</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nextChildren.length; i++) &#123;</span><br><span class="line">  <span class="keyword">const</span> nextVNode = nextChildren[i]</span><br><span class="line">  <span class="keyword">let</span> j = <span class="number">0</span></span><br><span class="line">  <span class="comment">// 遍历旧的 children</span></span><br><span class="line">  <span class="keyword">for</span> (j; j &lt; prevChildren.length; j++) &#123;</span><br><span class="line">    <span class="keyword">const</span> prevVNode = prevChildren[j]</span><br><span class="line">    <span class="comment">// 如果找到了具有相同 key 值的两个节点，则调用 `patch` 函数更新之</span></span><br><span class="line">    <span class="keyword">if</span> (nextVNode.key === prevVNode.key) &#123;</span><br><span class="line">      patch(prevVNode, nextVNode, container)</span><br><span class="line">      <span class="keyword">if</span> (j &lt; lastIndex) &#123;</span><br><span class="line">        <span class="comment">// 需要移动</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 更新 lastIndex</span></span><br><span class="line">        lastIndex = j</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span> <span class="comment">// 这里需要 break</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个就是react的做法，画个图吧</p>
<p><img src="http://zezeze-note.oss-cn-hongkong.aliyuncs.com/%E7%AC%94%E8%AE%B0%E6%88%AA%E5%9B%BE/vue%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/diff1/Gj87TK.png?OSSAccessKeyId=LTAI4GCeVHegRoadhkK6mc12&Expires=1588222103&Signature=CFajzOv2%2FJB71iXvolksOp2V5nY%3D" alt="Gj87TK.png"></p>
<p>以这个为例子，写个流程吧</p>
<ul>
<li>拿着lic去旧里面找，发现lic的索引是2，存起来</li>
<li>拿lia去旧里面找，发现是0，比2小，要换位置了</li>
</ul>
<p>思路就是这么个思路</p>
<h2 id="移动节点"><a href="#移动节点" class="headerlink" title="移动节点"></a>移动节点</h2><p>我们现在知道了他要不要移动，还有要移动到什么地方，接下来就是怎么移动了</p>
<p><img src="http://zezeze-note.oss-cn-hongkong.aliyuncs.com/%E7%AC%94%E8%AE%B0%E6%88%AA%E5%9B%BE/vue%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/diff1/Gj87TK.png?OSSAccessKeyId=LTAI4GCeVHegRoadhkK6mc12&Expires=1588222298&Signature=8RQBqaovrQxufTRKsNxX0L3bb3I%3D" alt="Gj87TK.png"></p>
<p>还是上面那个图为例子</p>
<ul>
<li>拿着lic找完，lic是新节点的第一个例子，不用移动，直接patch这个时候他们的关系是这样的</li>
</ul>
<p><img src="http://zezeze-note.oss-cn-hongkong.aliyuncs.com/%E7%AC%94%E8%AE%B0%E6%88%AA%E5%9B%BE/vue%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/diff1/GjJiHx.png?OSSAccessKeyId=LTAI4GCeVHegRoadhkK6mc12&Expires=1588222417&Signature=oxUiiCz7QgSI5p56OaPNlHC3Sm0%3D" alt="GjJiHx.png"></p>
<p>这个时候patch完，新的lic也指向了dom的lic</p>
<ul>
<li><p>然后到lia，我们一样操作，发现他是0，比c的2小，说明要移动，因为他的vnode里面存了真实的dom，我们直接将他的真实dom移动到lic后面</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (j &lt; lastIndex) &#123;</span><br><span class="line">    <span class="comment">// 需要移动</span></span><br><span class="line">    <span class="comment">// refNode 是为了下面调用 insertBefore 函数准备的</span></span><br><span class="line">    <span class="keyword">const</span> refNode = nextChildren[i - <span class="number">1</span>].el.nextSibling</span><br><span class="line">    <span class="comment">// 调用 insertBefore 函数移动 DOM</span></span><br><span class="line">    container.insertBefore(prevVNode.el, refNode)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br></pre></td></tr></table></figure>

<p>这个refNode是拿了在新的children里面这个要移动的元素的前一个节点的真实节点，然后再真实节点的后面insertBefore</p>
<p><img src="http://zezeze-note.oss-cn-hongkong.aliyuncs.com/%E7%AC%94%E8%AE%B0%E6%88%AA%E5%9B%BE/vue%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/diff1/Gjtlh8.png?OSSAccessKeyId=LTAI4GCeVHegRoadhkK6mc12&Expires=1588222514&Signature=2coKdsCkj7MCkdc1LauzG52sykU%3D" alt="Gjtlh8.png"></p>
</li>
</ul>
<h2 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h2><p>还是上面的例子，如果我们的新children中有旧children中无法找到的节点</p>
<p>这个时候要调用mount来搞一个新的节点挂在对的位置</p>
<ul>
<li><p>解决怎么知道这个节点到底有没有的问题</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> lastIndex = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nextChildren.length; i++) &#123;</span><br><span class="line">  <span class="keyword">const</span> nextVNode = nextChildren[i]</span><br><span class="line">  <span class="keyword">let</span> j = <span class="number">0</span>,</span><br><span class="line">    find = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">for</span> (j; j &lt; prevChildren.length; j++) &#123;</span><br><span class="line">    <span class="keyword">const</span> prevVNode = prevChildren[j]</span><br><span class="line">    <span class="keyword">if</span> (nextVNode.key === prevVNode.key) &#123;</span><br><span class="line">      find = <span class="literal">true</span></span><br><span class="line">      patch(prevVNode, nextVNode, container)</span><br><span class="line">      <span class="keyword">if</span> (j &lt; lastIndex) &#123;</span><br><span class="line">        <span class="comment">// 需要移动</span></span><br><span class="line">        <span class="keyword">const</span> refNode = nextChildren[i - <span class="number">1</span>].el.nextSibling</span><br><span class="line">        container.insertBefore(prevVNode.el, refNode)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 更新 lastIndex</span></span><br><span class="line">        lastIndex = j</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!find) &#123;</span><br><span class="line">    <span class="comment">// 挂载新节点</span></span><br><span class="line">    mount(nextVNode, container, <span class="literal">false</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用一个find标签来判断是否要挂载新的，如果循环中找到新的，就将他的值变为true，如果没有，我们循环完后执行挂载的方法，但是我们要改造我们的mount方法</p>
<p>修改我们的find插入代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 找到 refNode</span></span><br><span class="line">   <span class="keyword">const</span> refNode =</span><br><span class="line">     i - <span class="number">1</span> &lt; <span class="number">0</span></span><br><span class="line">       ? prevChildren[<span class="number">0</span>].el</span><br><span class="line">       : nextChildren[i - <span class="number">1</span>].el.nextSibling</span><br><span class="line">   mount(nextVNode, container, <span class="literal">false</span>, refNode)</span><br></pre></td></tr></table></figure>

<p>因为这个find的时候还在新children的循环中，我们判断他是不是第一个节点，然后挂上对应的前一个节点的el给他去mount，就ok了</p>
<p>这里为mount函数添加了第四个参数refNode，不要是在mountElement增加了这句</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">refNode ? container.insertBefore(el, refNode) : container.appendChild(el)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h2><p>我们目前写的方法无法应对新children比旧children短的情况，因为新children已经遍历完了，所以我们在遍历完后再重复遍历一次旧children去对比</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 移除已经不存在的节点</span></span><br><span class="line"><span class="comment">// 遍历旧的节点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; prevChildren.length; i++) &#123;</span><br><span class="line">  <span class="keyword">const</span> prevVNode = prevChildren[i]</span><br><span class="line">  <span class="comment">// 拿着旧 VNode 去新 children 中寻找相同的节点</span></span><br><span class="line">  <span class="keyword">const</span> has = nextChildren.find(</span><br><span class="line">    nextVNode =&gt; nextVNode.key === prevVNode.key</span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">if</span> (!has) &#123;</span><br><span class="line">    <span class="comment">// 如果没有找到相同的节点，则移除</span></span><br><span class="line">    container.removeChild(prevVNode.el)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们就写好了我们的diff算法了，当然好有优优化的空间</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>源码</tag>
        <tag>读书笔记</tag>
        <tag>框架设计</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack安装配置babel</title>
    <url>/2020/04/15/webpack/babel%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>把把都百度，记一下吧</p>
<p>首先我已经安装好webpack了，想引入babel</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>webpack</tag>
        <tag>babel</tag>
      </tags>
  </entry>
  <entry>
    <title>vue源码学习/10.diff2</title>
    <url>/2020/04/13/vue%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/10.diff2/</url>
    <content><![CDATA[<h2 id="索引把戏存在的问题"><a href="#索引把戏存在的问题" class="headerlink" title="索引把戏存在的问题"></a>索引把戏存在的问题</h2><p>索引把戏存在的问题</p>
<p>反映问题的例子</p>
<p><img src="https://s1.ax1x.com/2020/04/13/GjRYJe.png" alt="GjRYJe.png"></p>
<p>以我们目测，这个最简单的办法是将 c移到a前面，但是要索引把戏的话， 会移动两次</p>
<p><img src="https://s1.ax1x.com/2020/04/13/GjRtRH.png" alt="GjRtRH.png"></p>
<p>这个时候我们就要引入<strong>双端比较</strong>，同时从新旧两个children进行比较</p>
<h2 id="双端比较的实现"><a href="#双端比较的实现" class="headerlink" title="双端比较的实现"></a>双端比较的实现</h2><p>拿八个变量来存东西</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> oldStartIdx = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> oldEndIdx = prevChildren.length - <span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> newStartIdx = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> newEndIdx = nextChildren.length - <span class="number">1</span></span><br><span class="line"><span class="comment">// 四个点放新旧children的前后所有索引</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后再存他们对应的vnode</span></span><br><span class="line"><span class="keyword">let</span> oldStartVNode = prevChildren[oldStartIdx]</span><br><span class="line"><span class="keyword">let</span> oldEndVNode = prevChildren[oldEndIdx]</span><br><span class="line"><span class="keyword">let</span> newStartVNode = nextChildren[newStartIdx]</span><br><span class="line"><span class="keyword">let</span> newEndVNode = nextChildren[newEndIdx]</span><br></pre></td></tr></table></figure>

<p>开始比对</p>
<ul>
<li>旧的第一个比新的第一个</li>
<li>旧的最后一个比旧的最后一个</li>
<li>旧得头一个与新的最后一个</li>
<li>旧得最后一个与新的头一个</li>
</ul>
<p>这一步然后一步比对出他们两之间相等了，都会停止下面的比对了,如图</p>
<p><img src="https://s1.ax1x.com/2020/04/13/GjWsn1.png" alt="GjWsn1.png"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (oldStartVNode.key === newStartVNode.key) &#123;</span><br><span class="line">  <span class="comment">// 步骤一：oldStartVNode 和 newStartVNode 比对</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldEndVNode.key === newEndVNode.key) &#123;</span><br><span class="line">  <span class="comment">// 步骤二：oldEndVNode 和 newEndVNode 比对</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldStartVNode.key === newEndVNode.key) &#123;</span><br><span class="line">  <span class="comment">// 步骤三：oldStartVNode 和 newEndVNode 比对</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldEndVNode.key === newStartVNode.key) &#123;</span><br><span class="line">  <span class="comment">// 步骤四：oldEndVNode 和 newStartVNode 比对</span></span><br><span class="line">    <span class="comment">// 先调用 patch 函数完成更新</span></span><br><span class="line">  patch(oldEndVNode, newStartVNode, container)</span><br><span class="line">  <span class="comment">// 更新完成后，将容器中最后一个子节点移动到最前面，使其成为第一个子节点</span></span><br><span class="line">  container.insertBefore(oldEndVNode.el, oldStartVNode.el)</span><br><span class="line">  <span class="comment">// 更新索引，指向下一个位置</span></span><br><span class="line">  oldEndVNode = prevChildren[--oldEndIdx]</span><br><span class="line">  newStartVNode = nextChildren[++newStartIdx]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上面的例子，新的第一个与旧的最后一个相同，我们就将旧的对应的真实dom移动到最前方</p>
<p>更新完后的节点顺序如图</p>
<p><img src="https://s1.ax1x.com/2020/04/13/GjftKA.png" alt="GjftKA.png"></p>
<p>再继续重复比对直到结束，那么结束的标准在哪里呢</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">  <span class="keyword">if</span> (oldStartVNode.key === newStartVNode.key) &#123;</span><br><span class="line">    <span class="comment">// 步骤一：oldStartVNode 和 newStartVNode 比对</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldEndVNode.key === newEndVNode.key) &#123;</span><br><span class="line">    <span class="comment">// 步骤二：oldEndVNode 和 newEndVNode 比对</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldStartVNode.key === newEndVNode.key) &#123;</span><br><span class="line">    <span class="comment">// 步骤三：oldStartVNode 和 newEndVNode 比对</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldEndVNode.key === newStartVNode.key) &#123;</span><br><span class="line">    <span class="comment">// 步骤四：oldEndVNode 和 newStartVNode 比对</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用while装起来，直到旧与新的首尾大小关系互换了</p>
<p>把所有情况的代码补齐先</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">  <span class="keyword">if</span> (oldStartVNode.key === newStartVNode.key) &#123; <span class="comment">// 头相等的情况</span></span><br><span class="line">    <span class="comment">// 步骤一：oldStartVNode 和 newStartVNode 比对</span></span><br><span class="line">      </span><br><span class="line">          <span class="comment">// 调用 patch 函数更新</span></span><br><span class="line">    patch(oldStartVNode, newStartVNode, container)</span><br><span class="line">    <span class="comment">// 更新索引，指向下一个位置</span></span><br><span class="line">    oldStartVNode = prevChildren[++oldStartIdx]</span><br><span class="line">    newStartVNode = nextChildren[++newStartIdx]</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldEndVNode.key === newEndVNode.key) &#123; <span class="comment">// 旧的尾巴与新的尾巴相等的情况</span></span><br><span class="line">    <span class="comment">// 步骤二：oldEndVNode 和 newEndVNode 比对</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 patch 函数更新</span></span><br><span class="line">    patch(oldEndVNode, newEndVNode, container)</span><br><span class="line">    <span class="comment">// 更新索引，指向下一个位置</span></span><br><span class="line">    oldEndVNode = prevChildren[--oldEndIdx]</span><br><span class="line">    newEndVNode = nextChildren[--newEndIdx]</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldStartVNode.key === newEndVNode.key) &#123; <span class="comment">// 就戴尔头与新的尾巴相等的情况</span></span><br><span class="line">    <span class="comment">// 步骤三：oldStartVNode 和 newEndVNode 比对</span></span><br><span class="line">      </span><br><span class="line">       <span class="comment">// 调用 patch 函数更新</span></span><br><span class="line">    patch(oldStartVNode, newEndVNode, container)</span><br><span class="line">    <span class="comment">// 将 oldStartVNode.el 移动到 oldEndVNode.el 的后面，也就是 oldEndVNode.el.nextSibling 的前面</span></span><br><span class="line">    container.insertBefore(</span><br><span class="line">      oldStartVNode.el,</span><br><span class="line">      oldEndVNode.el.nextSibling</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// 更新索引，指向下一个位置</span></span><br><span class="line">    oldStartVNode = prevChildren[++oldStartIdx]</span><br><span class="line">    newEndVNode = nextChildren[--newEndIdx]</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldEndVNode.key === newStartVNode.key) &#123; <span class="comment">// 旧的尾巴与新的头相等的情况</span></span><br><span class="line">    <span class="comment">// 步骤四：oldEndVNode 和 newStartVNode 比对</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先调用 patch 函数完成更新</span></span><br><span class="line">    patch(oldEndVNode, newStartVNode, container)</span><br><span class="line">    <span class="comment">// 更新完成后，将容器中最后一个子节点移动到最前面，使其成为第一个子节点</span></span><br><span class="line">    container.insertBefore(oldEndVNode.el, oldStartVNode.el)</span><br><span class="line">    <span class="comment">// 更新索引，指向下一个位置</span></span><br><span class="line">    oldEndVNode = prevChildren[--oldEndIdx]</span><br><span class="line">    newStartVNode = nextChildren[++newStartIdx]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个就是双端比较的核心过程，key解决开始提的问题</p>
<p>明显双端的比较次数也比索引少，更快</p>
<h2 id="双端的优化"><a href="#双端的优化" class="headerlink" title="双端的优化"></a>双端的优化</h2><p>如果一轮比较发现啥都不相等了，咋办？那就用回索引把戏了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 遍历旧 children，试图寻找与 newStartVNode 拥有相同 key 值的元素</span></span><br><span class="line">    <span class="keyword">const</span> idxInOld = prevChildren.findIndex(</span><br><span class="line">      node =&gt; node.key === newStartVNode.key</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>遍历旧的child找出于新的相同的第一个的节点，存在idxInOld中，然后将这个节点移动到最前面，旧的就与新的第一个节点相同了</p>
<p><img src="http://zezeze-note.oss-cn-hongkong.aliyuncs.com/%E7%AC%94%E8%AE%B0%E6%88%AA%E5%9B%BE/vue%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/diff2/Gj4ou9.png?OSSAccessKeyId=LTAI4GCeVHegRoadhkK6mc12&Expires=1588222701&Signature=lh3OypqQJ3PyzQIkIbK%2BrtILFKU%3D" alt="Gj4ou9.png"></p>
<p>代码实现是这样的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 遍历旧 children，试图寻找与 newStartVNode 拥有相同 key 值的元素</span></span><br><span class="line">    <span class="keyword">const</span> idxInOld = prevChildren.findIndex(</span><br><span class="line">      node =&gt; node.key === newStartVNode.key</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">if</span> (idxInOld &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// vnodeToMove 就是在旧 children 中找到的节点，该节点所对应的真实 DOM 应该被移动到最前面</span></span><br><span class="line">      <span class="keyword">const</span> vnodeToMove = prevChildren[idxInOld]</span><br><span class="line">      <span class="comment">// 调用 patch 函数完成更新</span></span><br><span class="line">      patch(vnodeToMove, newStartVNode, container)</span><br><span class="line">      <span class="comment">// 把 vnodeToMove.el 移动到最前面，即 oldStartVNode.el 的前面</span></span><br><span class="line">      container.insertBefore(vnodeToMove.el, oldStartVNode.el)</span><br><span class="line">      <span class="comment">// 由于旧 children 中该位置的节点所对应的真实 DOM 已经被移动，所以将其设置为 undefined</span></span><br><span class="line">      prevChildren[idxInOld] = <span class="literal">undefined</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将 newStartIdx 下移一位</span></span><br><span class="line">    newStartVNode = nextChildren[++newStartIdx]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>处理完之后，将他原来的位置设置为undefined，然后再进行下一步比较，同时如果比较的时候遇到了undefined的话，就直接跳过，undefined的位置可能出现在新与旧的，改写我们上面的比较</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!oldStartVNode) &#123;</span><br><span class="line">    oldStartVNode = prevChildren[++oldStartIdx]</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!oldEndVNode) &#123;</span><br><span class="line">    oldEndVNode = prevChildren[--oldEndIdx]</span><br><span class="line">  &#125;</span><br><span class="line">    ---</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就变成了这种情况了</p>
<p><img src="http://zezeze-note.oss-cn-hongkong.aliyuncs.com/%E7%AC%94%E8%AE%B0%E6%88%AA%E5%9B%BE/vue%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/diff2/Gj5Xaq.png?OSSAccessKeyId=LTAI4GCeVHegRoadhkK6mc12&Expires=1588222746&Signature=UG73%2BBpXjI9ZhOSB6CsnSbSTxrs%3D" alt="Gj5Xaq.png"></p>
<h2 id="双端添加新元素"><a href="#双端添加新元素" class="headerlink" title="双端添加新元素"></a>双端添加新元素</h2><p>就是出现要添加新元素的情况</p>
<p><img src="http://zezeze-note.oss-cn-hongkong.aliyuncs.com/%E7%AC%94%E8%AE%B0%E6%88%AA%E5%9B%BE/vue%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/diff2/GjIWy4.png?OSSAccessKeyId=LTAI4GCeVHegRoadhkK6mc12&Expires=1588222778&Signature=bcwuJBh%2ByzYMEZiM%2BkrUe3yyzpg%3D" alt="GjIWy4.png"></p>
<p>就这个例子，我们双端比了发现不行，再循环拿也发现没有，就插入到他的oldStartVNode.el前面就行了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> idxInOld = prevChildren.findIndex(</span><br><span class="line">      node =&gt; node.key === newStartVNode.key</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">if</span> (idxInOld &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> vnodeToMove = prevChildren[idxInOld]</span><br><span class="line">      patch(vnodeToMove, newStartVNode, container)</span><br><span class="line">      prevChildren[idxInOld] = <span class="literal">undefined</span></span><br><span class="line">      container.insertBefore(vnodeToMove.el, oldStartVNode.el)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 使用 mount 函数挂载新节点</span></span><br><span class="line">      mount(newStartVNode, container, <span class="literal">false</span>, oldStartVNode.el)</span><br><span class="line">    &#125;</span><br><span class="line">    newStartVNode = nextChildren[++newStartIdx]</span><br><span class="line">  &#125;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>但是这样还是有一种情况没处理，就是新元素时新的第一个的时候</p>
<p><img src="http://zezeze-note.oss-cn-hongkong.aliyuncs.com/%E7%AC%94%E8%AE%B0%E6%88%AA%E5%9B%BE/vue%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/diff2/GjTHMD.png?OSSAccessKeyId=LTAI4GCeVHegRoadhkK6mc12&Expires=1588222825&Signature=IdSbXXOepLzTjQXf%2F3lA6ON5skE%3D" alt="GjTHMD.png"></p>
<p><img src="http://zezeze-note.oss-cn-hongkong.aliyuncs.com/%E7%AC%94%E8%AE%B0%E6%88%AA%E5%9B%BE/vue%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/diff2/GjTTxO.png?OSSAccessKeyId=LTAI4GCeVHegRoadhkK6mc12&Expires=1588231125&Signature=RvAYN%2FNK8ygL3guk84n1veRODL8%3D" alt="GjTTxO.png"></p>
<p>以我们目前的算法，最后lid无法比较了，漏了，我们的判断条件是oldEndIdx少于oldStartIdx，此时已经少于了，还是还有一个lid没处理，为了处理这种情况，我们对oldEndIdx与oldStartIdx检查，如果他的循环结束end小于start，说明还有一个漏的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">  <span class="comment">// 省略...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (oldEndIdx &lt; oldStartIdx) &#123;</span><br><span class="line">  <span class="comment">// 添加新节点</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = newStartIdx; i &lt;= newEndIdx; i++) &#123;</span><br><span class="line">    mount(nextChildren[i], container, <span class="literal">false</span>, oldStartVNode.el)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>因为oldEndIdx&lt;oldStartIdx只有在这种情况才会发生，也是就向他的开头添加元素，其他情况都是上面的添加情况了</p>
</blockquote>
<h2 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h2><p>还是先看图</p>
<p><img src="http://zezeze-note.oss-cn-hongkong.aliyuncs.com/%E7%AC%94%E8%AE%B0%E6%88%AA%E5%9B%BE/vue%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/diff2/Gj7W6S.png?OSSAccessKeyId=LTAI4GCeVHegRoadhkK6mc12&Expires=1588231165&Signature=24I5s7Qr9mXlY562Cltl0J1yFvg%3D" alt="Gj7W6S.png"></p>
<p>经过我们上面的算法，会变成这样</p>
<p><img src="https://s1.ax1x.com/2020/04/13/GjHyB4.png" alt="GjHyB4.png"></p>
<p>此时newEndIdx小于newStartIdx，普通情况下他们应该是相等的，所以我们认识到有节点要删除了，以此进行操作</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">  <span class="comment">// 省略...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (oldEndIdx &lt; oldStartIdx) &#123;</span><br><span class="line">  <span class="comment">// 添加新节点</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = newStartIdx; i &lt;= newEndIdx; i++) &#123;</span><br><span class="line">    mount(nextChildren[i], container, <span class="literal">false</span>, oldStartVNode.el)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (newEndIdx &lt; newStartIdx) &#123;</span><br><span class="line">  <span class="comment">// 移除操作</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = oldStartIdx; i &lt;= oldEndIdx; i++) &#123;</span><br><span class="line">    container.removeChild(prevChildren[i].el)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是vue2所采用的diff算法</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>源码</tag>
        <tag>读书笔记</tag>
        <tag>框架设计</tag>
      </tags>
  </entry>
  <entry>
    <title>mock使用模拟后端返回数据</title>
    <url>/2020/04/17/webpack/mock/</url>
    <content><![CDATA[<p>找到一个好东西，有mock与读取本地文件的功能</p>
<blockquote>
<p><a href="https://gitee.com/YukiJethro/QianHouDuanFenLiXiaDeShuJuMoNi" target="_blank" rel="noopener">https://gitee.com/YukiJethro/QianHouDuanFenLiXiaDeShuJuMoNi</a></p>
</blockquote>
<p>怎么使用看他说明就行</p>
<p>但是他没有跨域的</p>
<p>在app.js里面加上这段</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加解析post请求的依赖</span></span><br><span class="line"><span class="keyword">var</span> bodyParser = <span class="built_in">require</span>(<span class="string">'body-parser'</span>);<span class="comment">/*post方法*/</span></span><br><span class="line">app.use(bodyParser.json());<span class="comment">// 添加json解析</span></span><br><span class="line">app.use(bodyParser.urlencoded(&#123;<span class="attr">extended</span>: <span class="literal">false</span>&#125;));</span><br><span class="line"></span><br><span class="line"><span class="comment">//解决请求时的跨域问题</span></span><br><span class="line">app.all(<span class="string">'*'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  res.header(<span class="string">"Access-Control-Allow-Origin"</span>, <span class="string">"*"</span>);</span><br><span class="line">  res.header(<span class="string">"Access-Control-Allow-Headers"</span>, <span class="string">"X-Requested-With"</span>);</span><br><span class="line">  res.header(<span class="string">"Access-Control-Allow-Methods"</span>, <span class="string">"PUT,POST,GET,DELETE,OPTIONS"</span>);</span><br><span class="line">  res.header(<span class="string">"X-Powered-By"</span>, <span class="string">' 3.2.1'</span>)</span><br><span class="line">  res.header(<span class="string">"Content-Type"</span>, <span class="string">"application/json;charset=utf-8"</span>);</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>webpack</tag>
        <tag>mock</tag>
      </tags>
  </entry>
  <entry>
    <title>一次webpack配置</title>
    <url>/2020/04/16/webpack/%E4%B8%80%E6%AC%A1webpack%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>做项目的时候想用mock，要配置一下下下</p>
<p>用的插件：babel、mock、html-webpack-plugin、mock、webpack-dev-serve</p>
<p>直接放配置文件吧，反正能看懂</p>
<ul>
<li>packjage.json</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"map-overdata"</span>,</span><br><span class="line">  <span class="string">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="string">"description"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="string">"main"</span>: <span class="string">"index.js"</span>,</span><br><span class="line">  <span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span>,</span><br><span class="line">    <span class="string">"dev"</span>: <span class="string">"webpack-dev-server --inline --hot --config webpack.config.js"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"author"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="string">"license"</span>: <span class="string">"ISC"</span>,</span><br><span class="line">  <span class="string">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="string">"@babel/core"</span>: <span class="string">"^7.9.0"</span>,</span><br><span class="line">    <span class="string">"@babel/plugin-transform-runtime"</span>: <span class="string">"^7.9.0"</span>,</span><br><span class="line">    <span class="string">"@babel/preset-env"</span>: <span class="string">"^7.9.5"</span>,</span><br><span class="line">    <span class="string">"babel-loader"</span>: <span class="string">"^8.1.0"</span>,</span><br><span class="line">    <span class="string">"html-webpack-plugin"</span>: <span class="string">"^4.2.0"</span>,</span><br><span class="line">    <span class="string">"mocker-api"</span>: <span class="string">"^2.0.3"</span>,</span><br><span class="line">    <span class="string">"mockjs"</span>: <span class="string">"^1.1.0"</span>,</span><br><span class="line">    <span class="string">"webpack"</span>: <span class="string">"^4.42.1"</span>,</span><br><span class="line">    <span class="string">"webpack-cli"</span>: <span class="string">"^3.3.11"</span>,</span><br><span class="line">    <span class="string">"webpack-dev-server"</span>: <span class="string">"^3.10.3"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="string">"@babel/runtime"</span>: <span class="string">"^7.9.2"</span>,</span><br><span class="line">    <span class="string">"@babel/runtime-corejs3"</span>: <span class="string">"^7.9.2"</span>,</span><br><span class="line">    <span class="string">"babel-polyfill"</span>: <span class="string">"^6.26.0"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>webpack.config.js</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> apiMocker = <span class="built_in">require</span>(<span class="string">'mocker-api'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry : <span class="string">"./src/entry.js"</span>,<span class="comment">//入口文件</span></span><br><span class="line">    output : &#123;<span class="comment">//输出文件</span></span><br><span class="line">        filename : <span class="string">'mapData.js'</span>,<span class="comment">//输出文件名</span></span><br><span class="line">        <span class="comment">// path : __dirname + '/dist'//输出文件路径</span></span><br><span class="line">        path:path.resolve(__dirname,<span class="string">"dist"</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.jsx?$/</span>,</span><br><span class="line">                use: &#123;</span><br><span class="line">                    loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">                    options: &#123;</span><br><span class="line">                        presets: [<span class="string">"@babel/preset-env"</span>],</span><br><span class="line">                        plugins: [</span><br><span class="line">                            [</span><br><span class="line">                                <span class="string">"@babel/plugin-transform-runtime"</span>,</span><br><span class="line">                                &#123;</span><br><span class="line">                                    <span class="string">"corejs"</span>: <span class="number">3</span></span><br><span class="line">                                &#125;</span><br><span class="line">                            ]</span><br><span class="line">                        ]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                exclude: <span class="regexp">/node_modules/</span> <span class="comment">//排除 node_modules 目录</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    mode: <span class="string">"development"</span>,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="comment">//数组 放着所有的webpack插件</span></span><br><span class="line">        <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">            template: <span class="string">'./test/index.html'</span>,</span><br><span class="line">            filename: <span class="string">'index.html'</span>, <span class="comment">//打包后的文件名</span></span><br><span class="line">            inject:<span class="string">'head'</span>,</span><br><span class="line">            minify: &#123;</span><br><span class="line">                removeAttributeQuotes: <span class="literal">false</span>, <span class="comment">//是否删除属性的双引号</span></span><br><span class="line">                collapseWhitespace: <span class="literal">false</span>, <span class="comment">//是否折叠空白</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// hash: true //是否加上hash，默认是 false</span></span><br><span class="line">        &#125;)</span><br><span class="line">    ],</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        <span class="comment">// publicPath: path.resolve(__dirname,"dist"),</span></span><br><span class="line">        open: <span class="literal">true</span>,</span><br><span class="line">        <span class="comment">// openPage: '/dist/index',</span></span><br><span class="line">        before (app) &#123;</span><br><span class="line">          apiMocker(app, path.resolve(<span class="string">'./mock/mocker.js'</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用就是这么用的0.0</p>
<p>要引入jquery，这里用的是外部挂载的，看的webpack文档</p>
<blockquote>
<p><a href="https://webpack.js.org/configuration/externals/#externals" target="_blank" rel="noopener">https://webpack.js.org/configuration/externals/#externals</a></p>
</blockquote>
<p>就是这cdn有时候卡有时候ok，烦</p>
<p>html里面</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">script</span></span></span><br><span class="line"><span class="tag">         <span class="attr">src</span>=<span class="string">"https://code.jquery.com/jquery-3.1.0.js"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">integrity</span>=<span class="string">"sha256-slogkvB1K3VOkzAI8QITxV3VzpOnkeNVsKvtkYLMjfk="</span></span></span><br><span class="line"><span class="tag">         <span class="attr">crossorigin</span>=<span class="string">"anonymous"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后在你的js里面</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">'jquery'</span>;</span><br><span class="line"></span><br><span class="line">$(<span class="string">'.my-element'</span>).animate(<span class="comment">/* ... */</span>);</span><br></pre></td></tr></table></figure>

<p>至于为什么要导入jq，别问，问就是2020我还在写jq</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>webpack</tag>
        <tag>babel</tag>
      </tags>
  </entry>
  <entry>
    <title>自己写的地图插件</title>
    <url>/2020/04/20/%E5%95%A6%E5%95%A6%E6%B3%BD%E7%9A%84%E4%BA%A7%E5%87%BA/%E5%9C%B0%E5%9B%BEcanvas%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="map-overData"><a href="#map-overData" class="headerlink" title="map-overData"></a>map-overData</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>这个东西主要是为了往百度地图上画东西，要求大量数据不要卡，所以写了</p>
<p>目前效果就只有两种</p>
<p><img src="https://s1.ax1x.com/2020/04/20/JlHkNV.png" alt="JlHkNV.png"></p>
<p>可以看到是画图标与画多变形，这里是取随机数，所以有点乱问题不大，同时还有点击事件</p>
<p><img src="https://s1.ax1x.com/2020/04/20/JlqHB9.png" alt="JlqHB9.png"></p>
<p>完整例子在test文件夹</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p> 地图显示比较多数据的功能</p>
<p> 基本功能比较完善，写个文档</p>
<p>是依赖百度地图的，所以要先引入百度地图</p>
<p>先看个demo，在test文件夹里面有</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> BMap.Map(<span class="string">"map"</span>, &#123;</span><br><span class="line">    enableMapClick: <span class="literal">false</span></span><br><span class="line">&#125;); </span><br><span class="line">map.centerAndZoom(<span class="keyword">new</span> BMap.Point(<span class="number">113.300251</span>, <span class="number">22.810862</span>), <span class="number">13</span>);</span><br><span class="line">map.enableScrollWheelZoom(<span class="literal">true</span>); <span class="comment">//开启鼠标滚轮缩放</span></span><br><span class="line"><span class="keyword">var</span> mapData = <span class="keyword">new</span> MapData(map)</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    url: <span class="string">'http://localhost:8080/lapi/data1'</span>,</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> example1 = mapData.createDraw(<span class="string">'point'</span>, res, <span class="string">'cheche'</span>)</span><br><span class="line">        mapData.render(example1)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>前面就是创建百度地图实例然后设置中心点，十分简单</p>
<p>重点是后面</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mapData = <span class="keyword">new</span> MapData(map) <span class="comment">// 创建实例</span></span><br></pre></td></tr></table></figure>

<p>然后拿数据，数据的类型是</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[&#123;</span><br><span class="line">    <span class="string">"id"</span>: <span class="string">"1"</span>,  <span class="comment">// 为什么会有id后面会说</span></span><br><span class="line">    <span class="string">"lon"</span>: <span class="string">"113.303037"</span>,</span><br><span class="line">    <span class="string">"lat"</span>: <span class="string">"22.76938"</span></span><br><span class="line">&#125;</span><br><span class="line">....  <span class="comment">// 后面重复</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>然后创建画布用实例渲染画布</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> example1 = mapData.createDraw(<span class="string">'point'</span>, res, <span class="string">'cheche'</span>) <span class="comment">// 创建画布</span></span><br><span class="line">mapData.render(example1) <span class="comment">// 渲染画布</span></span><br></pre></td></tr></table></figure>

<p>大功告成</p>
<p>感觉是不是很简单呢(并不)</p>
<p><img src="https://s1.ax1x.com/2020/04/20/JlTXQJ.png" alt="JlTXQJ.png"></p>
<h2 id="api"><a href="#api" class="headerlink" title="api"></a>api</h2><ul>
<li><p>new MapData(map)  </p>
<p>创建实例，需要传入百度地图实例</p>
</li>
<li><p>createDraw(type,data,id)</p>
</li>
</ul>
<p>参数：type，data，id</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 目前就只有两个type参数point与polygon</span></span><br><span class="line"><span class="keyword">var</span> example1 = mapData.createDraw(<span class="string">'point'</span>, res, <span class="string">'cheche'</span>) <span class="comment">// 点</span></span><br><span class="line"><span class="keyword">var</span> example2 = mapData.createDraw(<span class="string">'polygon'</span>, res) <span class="comment">// 多边形</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果有id，返回的canvas会自带id</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(example1.id) <span class="comment">// cheche</span></span><br></pre></td></tr></table></figure>

<ul>
<li>click(callback)</li>
</ul>
<p>点击触发的回调函数，point专用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 点击返回函数</span></span><br><span class="line">example1.click(<span class="function"><span class="keyword">function</span> (<span class="params">item, map</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> point = <span class="keyword">new</span> BMap.Point(item.lon, item.lat);</span><br><span class="line">    <span class="keyword">var</span> marker = <span class="keyword">new</span> BMap.Marker(point);</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        url: <span class="string">'http://localhost:8080/mapi/clickData?id='</span> + item.id,</span><br><span class="line">        type: <span class="string">'get'</span>,</span><br><span class="line">        success: <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> sContent = res.data.data;</span><br><span class="line">            <span class="keyword">var</span> infoWindow = <span class="keyword">new</span> BMap.InfoWindow(sContent); <span class="comment">// 创建信息窗口对象</span></span><br><span class="line">            map.openInfoWindow(infoWindow, point); <span class="comment">//开启信息窗口</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 点击的时候会触发这个函数，函数有两个参数，一是item此条数据的对象，二是map地图实例，前面为什么要id呢，就是为了触发事件哒</span></span><br></pre></td></tr></table></figure>

<ul>
<li>icon</li>
</ul>
<p>点的图标，point专用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">example1.icon(<span class="string">"https://s1.ax1x.com/2020/04/17/JZku8K.png"</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>切换类方法</p>
<ul>
<li>switchCanvas()  默认切换展示</li>
<li>seitchCanvasById()  根据id切换展示</li>
<li>allCanvasShow()  全部展示</li>
<li>allCanvasHide()  全部隐藏</li>
</ul>
</li>
<li><p>缓存</p>
</li>
</ul>
<p>在实例里面有当前画布实例的缓存可以操作</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(mapData)</span><br></pre></td></tr></table></figure>

<p><a href="https://imgchr.com/i/J19BaF" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/04/20/J19BaF.png" alt="J19BaF.png"></a></p>
<h2 id="后续要完善的功能"><a href="#后续要完善的功能" class="headerlink" title="后续要完善的功能"></a>后续要完善的功能</h2><ul>
<li>搜索显示入口</li>
<li>画笔样式自定义接口</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>啦啦泽的产出</tag>
      </tags>
  </entry>
  <entry>
    <title>vue源码学习/08.渲染器patch</title>
    <url>/2020/04/09/vue%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/08.%E6%B8%B2%E6%9F%93%E5%99%A8patch/</url>
    <content><![CDATA[<h2 id="ptach原则"><a href="#ptach原则" class="headerlink" title="ptach原则"></a>ptach原则</h2><p>提高性能的关键patch步骤，对比新旧vnode，以最合适的方式更新dom</p>
<p>回头看看我们的渲染器代码先</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">vnode, container</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> prevVNode = container.vnode</span><br><span class="line">  <span class="keyword">if</span> (prevVNode == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (vnode) &#123;</span><br><span class="line">      <span class="comment">// 没有旧的 VNode，使用 `mount` 函数挂载全新的 VNode</span></span><br><span class="line">      mount(vnode, container)</span><br><span class="line">      <span class="comment">// 将新的 VNode 添加到 container.vnode 属性下，这样下一次渲染时旧的 VNode 就存在了 *</span></span><br><span class="line">      container.vnode = vnode</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (vnode) &#123;</span><br><span class="line">      <span class="comment">// 有旧的 VNode，则调用 `patch` 函数打补丁 *</span></span><br><span class="line">      patch(prevVNode, vnode, container)</span><br><span class="line">      <span class="comment">// 更新 container.vnode</span></span><br><span class="line">      container.vnode = vnode</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 有旧的 VNode 但是没有新的 VNode，这说明应该移除 DOM，在浏览器中可以使用 removeChild 函数。</span></span><br><span class="line">      container.removeChild(prevVNode.el)</span><br><span class="line">      container.vnode = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>讨论patch方法的实现，我们的vnode有5钟类型，相应的只有相同类型的vnote才有patch的必要，因为他底层都不一样了，只能用序的替换旧的，我们根据这个先写ifelse</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patch</span>(<span class="params">prevVNode, nextVNode, container</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 分别拿到新旧 VNode 的类型，即 flags</span></span><br><span class="line">  <span class="keyword">const</span> nextFlags = nextVNode.flags</span><br><span class="line">  <span class="keyword">const</span> prevFlags = prevVNode.flags</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查新旧 VNode 的类型是否相同，如果类型不同，则直接调用 replaceVNode 函数替换 VNode</span></span><br><span class="line">  <span class="comment">// 如果新旧 VNode 的类型相同，则根据不同的类型调用不同的比对函数</span></span><br><span class="line">  <span class="keyword">if</span> (prevFlags !== nextFlags) &#123;</span><br><span class="line">    replaceVNode(prevVNode, nextVNode, container)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nextFlags &amp; VNodeFlags.ELEMENT) &#123;</span><br><span class="line">    patchElement(prevVNode, nextVNode, container)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nextFlags &amp; VNodeFlags.COMPONENT) &#123;</span><br><span class="line">    patchComponent(prevVNode, nextVNode, container)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nextFlags &amp; VNodeFlags.TEXT) &#123;</span><br><span class="line">    patchText(prevVNode, nextVNode)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nextFlags &amp; VNodeFlags.FRAGMENT) &#123;</span><br><span class="line">    patchFragment(prevVNode, nextVNode, container)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nextFlags &amp; VNodeFlags.PORTAL) &#123;</span><br><span class="line">    patchPortal(prevVNode, nextVNode)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这个replace方法，先来研究replace方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">replaceVNode</span>(<span class="params">prevVNode, nextVNode, container</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 将旧的 VNode 所渲染的 DOM 从容器中移除</span></span><br><span class="line">  container.removeChild(prevVNode.el)</span><br><span class="line">  <span class="comment">// 再把新的 VNode 挂载到容器中</span></span><br><span class="line">  mount(nextVNode, container)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看起来很简单的亚子呢 嘤嘤嘤</p>
<p>按照这个逻辑，我们来一个个看看这些类型的patch</p>
<h2 id="更新标签元素"><a href="#更新标签元素" class="headerlink" title="更新标签元素"></a>更新标签元素</h2><h3 id="更新data"><a href="#更新data" class="headerlink" title="更新data"></a>更新data</h3><p>普通标签元素我们来看看，即使他们都是标签元素，他们也可能是不同的标签，这里就跟上面一个意思了，我们发现他的跟标签不同，直接替换</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patchElement</span>(<span class="params">prevVNode, nextVNode, container</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果新旧 VNode 描述的是不同的标签，则调用 replaceVNode 函数，使用新的 VNode 替换旧的 VNode</span></span><br><span class="line">  <span class="keyword">if</span> (prevVNode.tag !== nextVNode.tag) &#123;</span><br><span class="line">    replaceVNode(prevVNode, nextVNode, container)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果新旧vnode描述的是相同的标签，那我们就去比较他们的vnodedata与children</p>
<p>先谈data，将新的vnodeData应用到元素上，不存在的移除</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">  <span class="comment">// 拿到 el 元素，注意这时要让 nextVNode.el 也引用该元素</span></span><br><span class="line">  <span class="keyword">const</span> el = (nextVNode.el = prevVNode.el)</span><br><span class="line">  <span class="comment">// 拿到 新旧 VNodeData</span></span><br><span class="line">  <span class="keyword">const</span> prevData = prevVNode.data</span><br><span class="line">  <span class="keyword">const</span> nextData = nextVNode.data</span><br><span class="line">  <span class="comment">// 新的 VNodeData 存在时才有必要更新</span></span><br><span class="line">  <span class="keyword">if</span> (nextData) &#123;</span><br><span class="line">    <span class="comment">// 遍历新的 VNodeData</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> nextData) &#123;</span><br><span class="line">      <span class="comment">// 根据 key 拿到新旧 VNodeData 值</span></span><br><span class="line">      <span class="keyword">const</span> prevValue = prevData[key]</span><br><span class="line">      <span class="keyword">const</span> nextValue = nextData[key]</span><br><span class="line">      <span class="keyword">switch</span> (key) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'style'</span>:</span><br><span class="line">          <span class="comment">// 遍历新 VNodeData 中的 style 数据，将新的样式应用到元素</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> nextValue) &#123;</span><br><span class="line">            el.style[k] = nextValue[k]</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 遍历旧 VNodeData 中的 style 数据，将已经不存在于新的 VNodeData 的数据移除</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> prevValue) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!nextValue.hasOwnProperty(k)) &#123;</span><br><span class="line">              el.style[k] = <span class="string">''</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>这里只是写了style而已</p>
<p>咦，然后你会发现这里这个switch好像见过，没错，这里跟mount里面vnodeData处理是一样的道理，所以可以抽出来单独做一个函数的</p>
<p>先修改patch</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (nextData) &#123;</span><br><span class="line">    <span class="comment">// 遍历新的 VNodeData，将旧值和新值都传递给 patchData 函数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> nextData) &#123;</span><br><span class="line">      <span class="keyword">const</span> prevValue = prevData[key]</span><br><span class="line">      <span class="keyword">const</span> nextValue = nextData[key]</span><br><span class="line">      patchData(el, key, prevValue, nextValue)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (prevData) &#123;</span><br><span class="line">    <span class="comment">// 遍历旧的 VNodeData，将已经不存在于新的 VNodeData 中的数据移除</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> prevData) &#123;</span><br><span class="line">      <span class="keyword">const</span> prevValue = prevData[key]</span><br><span class="line">      <span class="keyword">if</span> (prevValue &amp;&amp; !nextData.hasOwnProperty(key)) &#123;</span><br><span class="line">        <span class="comment">// 第四个参数为 null，代表移除数据</span></span><br><span class="line">        patchData(el, key, prevValue, <span class="literal">null</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>patchData有四个参数，删除的时候第四个参数给个null表示,而我们moute的时候只要旧数据不给就行啦</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">patchData</span>(<span class="params">el, key, prevValue, nextValue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (key) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'style'</span>:</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> nextValue) &#123;</span><br><span class="line">        el.style[k] = nextValue[k]</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> prevValue) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!nextValue.hasOwnProperty(k)) &#123;</span><br><span class="line">          el.style[k] = <span class="string">''</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'class'</span>:</span><br><span class="line">      el.className = nextValue</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">if</span> (key[<span class="number">0</span>] === <span class="string">'o'</span> &amp;&amp; key[<span class="number">1</span>] === <span class="string">'n'</span>) &#123;</span><br><span class="line">        <span class="comment">// 事件</span></span><br><span class="line">        el.addEventListener(key.slice(<span class="number">2</span>), nextValue)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (domPropsRE.test(key)) &#123;</span><br><span class="line">        <span class="comment">// 当作 DOM Prop 处理</span></span><br><span class="line">        el[key] = nextValue</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 当作 Attr 处理</span></span><br><span class="line">        el.setAttribute(key, nextValue)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="更新children"><a href="#更新children" class="headerlink" title="更新children"></a>更新children</h3><p>写一个patchChildren方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">patchElement</span><br><span class="line">---</span><br><span class="line"><span class="comment">// 调用 patchChildren 函数递归地更新子节点</span></span><br><span class="line">  patchChildren(</span><br><span class="line">    prevVNode.childFlags, <span class="comment">// 旧的 VNode 子节点的类型</span></span><br><span class="line">    nextVNode.childFlags, <span class="comment">// 新的 VNode 子节点的类型</span></span><br><span class="line">    prevVNode.children,   <span class="comment">// 旧的 VNode 子节点</span></span><br><span class="line">    nextVNode.children,   <span class="comment">// 新的 VNode 子节点</span></span><br><span class="line">    el                    <span class="comment">// 当前标签元素，即这些子节点的父节点</span></span><br><span class="line">  )</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>给了5个参数</p>
<p>比较类型全靠flags属性对比，真实的一批</p>
<p>一个标签的子节点分为三种情况，只有一个子节点、没有子节点、多个子节点，根据这个圆柱写我们的patch函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patchChildren</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  prevChildFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">  nextChildFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">  prevChildren,</span></span></span><br><span class="line"><span class="function"><span class="params">  nextChildren,</span></span></span><br><span class="line"><span class="function"><span class="params">  container</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (prevChildFlags) &#123;</span><br><span class="line">    <span class="comment">// 旧的 children 是单个子节点，会执行该 case 语句块</span></span><br><span class="line">    <span class="keyword">case</span> ChildrenFlags.SINGLE_VNODE:</span><br><span class="line">      <span class="keyword">switch</span> (nextChildFlags) &#123;</span><br><span class="line">        <span class="keyword">case</span> ChildrenFlags.SINGLE_VNODE:</span><br><span class="line">          <span class="comment">// 新的 children 也是单个子节点时，会执行该 case 语句块</span></span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">case</span> ChildrenFlags.NO_CHILDREN:</span><br><span class="line">          <span class="comment">// 新的 children 中没有子节点时，会执行该 case 语句块</span></span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="comment">// 新的 children 中有多个子节点时，会执行该 case 语句块</span></span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="comment">// 旧的 children 中没有子节点时，会执行该 case 语句块</span></span><br><span class="line">    <span class="keyword">case</span> ChildrenFlags.NO_CHILDREN:</span><br><span class="line">      <span class="keyword">switch</span> (nextChildFlags) &#123;</span><br><span class="line">        <span class="keyword">case</span> ChildrenFlags.SINGLE_VNODE:</span><br><span class="line">          <span class="comment">// 新的 children 是单个子节点时，会执行该 case 语句块</span></span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">case</span> ChildrenFlags.NO_CHILDREN:</span><br><span class="line">          <span class="comment">// 新的 children 中没有子节点时，会执行该 case 语句块</span></span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="comment">// 新的 children 中有多个子节点时，会执行该 case 语句块</span></span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="comment">// 旧的 children 中有多个子节点时，会执行该 case 语句块</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">switch</span> (nextChildFlags) &#123;</span><br><span class="line">        <span class="keyword">case</span> ChildrenFlags.SINGLE_VNODE:</span><br><span class="line">          <span class="comment">// 新的 children 是单个子节点时，会执行该 case 语句块</span></span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">case</span> ChildrenFlags.NO_CHILDREN:</span><br><span class="line">          <span class="comment">// 新的 children 中没有子节点时，会执行该 case 语句块</span></span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="comment">// 新的 children 中有多个子节点时，会执行该 case 语句块</span></span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实这里就是ifelse大法，不过用switch代替了好看点，一共有9种情况</p>
<p>然后我们来填中间的内容</p>
<p>各情况分类讨论</p>
<p><img src="http://zezeze-note.oss-cn-hongkong.aliyuncs.com/%E7%AC%94%E8%AE%B0%E6%88%AA%E5%9B%BE/vue%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/06%E6%B8%B2%E6%9F%93%E5%99%A8patch/G5k7fP.png?OSSAccessKeyId=LTAI4GCeVHegRoadhkK6mc12&Expires=1588221866&Signature=t3xxVnHShAIMmHZsVRC%2Bol9v0co%3D" alt="G5k7fP.png"></p>
<p><img src="http://zezeze-note.oss-cn-hongkong.aliyuncs.com/%E7%AC%94%E8%AE%B0%E6%88%AA%E5%9B%BE/vue%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/06%E6%B8%B2%E6%9F%93%E5%99%A8patch/G5A4jU.png?OSSAccessKeyId=LTAI4GCeVHegRoadhkK6mc12&Expires=1588221898&Signature=5SHkLC8YYZs42g42AfQaZakxbnE%3D" alt="G5A4jU.png"></p>
<p><img src="http://zezeze-note.oss-cn-hongkong.aliyuncs.com/%E7%AC%94%E8%AE%B0%E6%88%AA%E5%9B%BE/vue%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/06%E6%B8%B2%E6%9F%93%E5%99%A8patch/G5EaVJ.png?OSSAccessKeyId=LTAI4GCeVHegRoadhkK6mc12&Expires=1588221955&Signature=bOxETgeqzHKQAnIsVl3GEvd6mp0%3D" alt="G5EaVJ.png"></p>
<p>最最核心的其实是在后面的diff，是关键</p>
<p>具体实现看代码</p>
<h2 id="更新文本节点"><a href="#更新文本节点" class="headerlink" title="更新文本节点"></a>更新文本节点</h2><p>这个好做，直接将他的文本换成新的文本就行了</p>
<p>实现</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patchText</span>(<span class="params">prevVNode, nextVNode</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 拿到文本元素 el，同时让 nextVNode.el 指向该文本元素</span></span><br><span class="line">  <span class="keyword">const</span> el = (nextVNode.el = prevVNode.el)</span><br><span class="line">  <span class="comment">// 只有当新旧文本内容不一致时才有必要更新</span></span><br><span class="line">  <span class="keyword">if</span> (nextVNode.children !== prevVNode.children) &#123;</span><br><span class="line">    el.nodeValue = nextVNode.children   <span class="comment">// 文本放在children里面呀</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="更新Fragment"><a href="#更新Fragment" class="headerlink" title="更新Fragment"></a>更新Fragment</h2><p>Fragment相当于没有父元素的标签元素更新，就是两个片段的子节点的比较，是一样的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patchFragment</span>(<span class="params">prevVNode, nextVNode, container</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 直接调用 patchChildren 函数更新 新旧片段的子节点即可</span></span><br><span class="line">  patchChildren(</span><br><span class="line">    prevVNode.childFlags, <span class="comment">// 旧片段的子节点类型</span></span><br><span class="line">    nextVNode.childFlags, <span class="comment">// 新片段的子节点类型</span></span><br><span class="line">    prevVNode.children,   <span class="comment">// 旧片段的子节点</span></span><br><span class="line">    nextVNode.children,   <span class="comment">// 新片段的子节点</span></span><br><span class="line">    container</span><br><span class="line">  )</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">switch</span> (nextVNode.childFlags) &#123;</span><br><span class="line">    <span class="keyword">case</span> ChildrenFlags.SINGLE_VNODE:</span><br><span class="line">      nextVNode.el = nextVNode.children.el  <span class="comment">// 只有一个元素的话就只是一个</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> ChildrenFlags.NO_CHILDREN:</span><br><span class="line">      nextVNode.el = prevVNode.el  </span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      nextVNode.el = nextVNode.children[<span class="number">0</span>].el <span class="comment">//默认是children的第一个</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完全可以用上面写到的给标签用的方法，要记得更新el的引用</p>
<h2 id="更新portal"><a href="#更新portal" class="headerlink" title="更新portal"></a>更新portal</h2><p>portal可以类似frafment的更新，但是有一个巨大不同，portal是可以到处挂载的，他们要挂载的地方可能变了，所以我们要更新他的挂载目标</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">patchPortal (prevVNode, nextVNode)&#123;</span><br><span class="line">  patchChildren(</span><br><span class="line">    prevVNode.childFlags,</span><br><span class="line">    nextVNode.childFlags,</span><br><span class="line">    prevVNode.children,</span><br><span class="line">    nextVNode.children,</span><br><span class="line">    prevVNode.tag <span class="comment">// 注意容器元素是旧的 container</span></span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 让 nextVNode.el 指向 prevVNode.el</span></span><br><span class="line">  nextVNode.el = prevVNode.el</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先更新了children，然后将占位文本节点给next</p>
<p>然后思考怎么更新挂载目标</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果新旧容器不同，才需要搬运</span></span><br><span class="line"><span class="keyword">if</span> (nextVNode.tag !== prevVNode.tag) &#123;</span><br><span class="line">    <span class="comment">// 获取新的容器元素，即挂载目标</span></span><br><span class="line">    <span class="keyword">const</span> container =</span><br><span class="line">          <span class="keyword">typeof</span> nextVNode.tag === <span class="string">'string'</span></span><br><span class="line">    ? <span class="built_in">document</span>.querySelector(nextVNode.tag)</span><br><span class="line">    : nextVNode.tag</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (nextVNode.childFlags) &#123;</span><br><span class="line">        <span class="keyword">case</span> ChildrenFlags.SINGLE_VNODE:</span><br><span class="line">            <span class="comment">// 如果新的 Portal 是单个子节点，就把该节点搬运到新容器中</span></span><br><span class="line">            container.appendChild(nextVNode.children.el)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">case</span> ChildrenFlags.NO_CHILDREN:</span><br><span class="line">            <span class="comment">// 新的 Portal 没有子节点，不需要搬运</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">// 如果新的 Portal 是多个子节点，遍历逐个将它们搬运到新容器中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nextVNode.children.length; i++) &#123;</span><br><span class="line">                container.appendChild(nextVNode.children[i].el)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>appendChild方法向dom添加元素时，如果被添加的元素已经存在于页面上，会直接移动元素到新的目标，然后就是传统异能ifelse了</p>
<h2 id="更新有状态组件"><a href="#更新有状态组件" class="headerlink" title="更新有状态组件"></a>更新有状态组件</h2><p>这里我们将有状态组件的更新分为主动更新与被动更新</p>
<ul>
<li>主动更新：组件自身的状态发生变化导致更新</li>
<li>被动更新：组件依赖别的组件的数据，别的组件更新了导致我要更新</li>
</ul>
<h3 id="主动更新"><a href="#主动更新" class="headerlink" title="主动更新"></a>主动更新</h3><p>当组件的状态变化，我们要渲染出新的vnode，然后将新旧vnode对比patch</p>
<p>回头看组件挂载时写的代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountStatefulComponent</span>(<span class="params">vnode, container, isSVG</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建组件实例</span></span><br><span class="line">  <span class="keyword">const</span> instance = <span class="keyword">new</span> vnode.tag()</span><br><span class="line">  </span><br><span class="line">  instance._update = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 1、渲染VNode</span></span><br><span class="line">      instance.$vnode = instance.render()</span><br><span class="line">      <span class="comment">// 2、挂载</span></span><br><span class="line">      mount(instance.$vnode, container, isSVG)</span><br><span class="line">      <span class="comment">// 4、el 属性值 和 组件实例的 $el 属性都引用组件的根DOM元素</span></span><br><span class="line">      instance.$el = vnode.el = instance.$vnode.el</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  instance._update()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后面三步就是渲染方法，我们封装他，方便要重新渲染出新的vnod的时候我们可以再调用</p>
<p>目前我们没有写钩子，所以要手动调用他</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 自身状态 or 本地状态</span></span><br><span class="line">  localState = <span class="string">'one'</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// mounted 钩子</span></span><br><span class="line">  mounted() &#123;</span><br><span class="line">    <span class="comment">// 两秒钟之后修改本地状态的值，并重新调用 _update() 函数更新组件</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.localState = <span class="string">'two'</span></span><br><span class="line">      <span class="keyword">this</span>._update()</span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> h(<span class="string">'div'</span>, <span class="literal">null</span>, <span class="keyword">this</span>.localState)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个是测试用例，写了个钩子，然后有一个settimeout</p>
<p>相应我们的update方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountStatefulComponent</span>(<span class="params">vnode, container, isSVG</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建组件实例</span></span><br><span class="line">  <span class="keyword">const</span> instance = <span class="keyword">new</span> vnode.tag()</span><br><span class="line"></span><br><span class="line">  instance._update = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 1、渲染VNode</span></span><br><span class="line">    instance.$vnode = instance.render()</span><br><span class="line">    <span class="comment">// 2、挂载</span></span><br><span class="line">    mount(instance.$vnode, container, isSVG)</span><br><span class="line">    <span class="comment">// 4、el 属性值 和 组件实例的 $el 属性都引用组件的根DOM元素</span></span><br><span class="line">    instance.$el = vnode.el = instance.$vnode.el</span><br><span class="line">    <span class="comment">// 5、调用 mounted 钩子</span></span><br><span class="line">    instance.mounted &amp;&amp; instance.mounted()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  instance._update()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个调用钩子我们应该只是第一次挂载的时候才调用好，而后续更新的时候是不调用的，是调用patch函数将新旧vnode对比,用一个boolean来表示</p>
<p>改写update</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountStatefulComponent</span>(<span class="params">vnode, container, isSVG</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建组件实例</span></span><br><span class="line">  <span class="keyword">const</span> instance = <span class="keyword">new</span> vnode.tag()</span><br><span class="line"></span><br><span class="line">  instance._update = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果 instance._mounted 为真，说明组件已挂载，应该执行更新操作</span></span><br><span class="line">    <span class="keyword">if</span> (instance._mounted) &#123;</span><br><span class="line">      <span class="comment">// 1、拿到旧的 VNode</span></span><br><span class="line">      <span class="keyword">const</span> prevVNode = instance.$vnode</span><br><span class="line">      <span class="comment">// 2、重渲染新的 VNode</span></span><br><span class="line">      <span class="keyword">const</span> nextVNode = (instance.$vnode = instance.render())</span><br><span class="line">      <span class="comment">// 3、patch 更新</span></span><br><span class="line">      <span class="comment">// prevVNode.el.parentNode容器元素</span></span><br><span class="line">      patch(prevVNode, nextVNode, prevVNode.el.parentNode)</span><br><span class="line">      <span class="comment">// 4、更新 vnode.el 和 $el</span></span><br><span class="line">      instance.$el = vnode.el = instance.$vnode.el</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 1、渲染VNode</span></span><br><span class="line">      instance.$vnode = instance.render()</span><br><span class="line">      <span class="comment">// 2、挂载</span></span><br><span class="line">      mount(instance.$vnode, container, isSVG)</span><br><span class="line">      <span class="comment">// 3、组件已挂载的标识</span></span><br><span class="line">      instance._mounted = <span class="literal">true</span></span><br><span class="line">      <span class="comment">// 4、el 属性值 和 组件实例的 $el 属性都引用组件的根DOM元素</span></span><br><span class="line">      instance.$el = vnode.el = instance.$vnode.el</span><br><span class="line">      <span class="comment">// 5、调用 mounted 钩子</span></span><br><span class="line">      instance.mounted &amp;&amp; instance.mounted()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  instance._update()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个instance._mounted哪里来呢</p>
<h3 id="组件的外部状态props"><a href="#组件的外部状态props" class="headerlink" title="组件的外部状态props"></a>组件的外部状态props</h3><p>被动更新就是外面的状态影响了我们的组件，然后被迫更新</p>
<p>我们来模拟下加入这一步</p>
<p>在mout状态组件的时候，创建组件实例后，里面是出话组件的props</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountStatefulComponent</span>(<span class="params">vnode, container, isSVG</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建组件实例</span></span><br><span class="line">  <span class="keyword">const</span> instance = (vnode.children = <span class="keyword">new</span> vnode.tag())</span><br><span class="line">  <span class="comment">// 初始化 props</span></span><br><span class="line">  instance.$props = vnode.data</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样子组件就能通过this.$props来访问父组件传来的props数据</p>
<p>这样直接赋值其实是不对的，不过这里是为了有那种外部引起变化的样例</p>
<p>用来下面的被动更新用</p>
<h3 id="被动更新"><a href="#被动更新" class="headerlink" title="被动更新"></a>被动更新</h3><p>假设我们为父组件定义了mouted钩子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">mounted() &#123;</span><br><span class="line">   <span class="comment">// 两秒钟后将 localState 的值修改为 'two'</span></span><br><span class="line">   setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="keyword">this</span>.localState = <span class="string">'two'</span></span><br><span class="line">     <span class="keyword">this</span>._update()</span><br><span class="line">   &#125;, <span class="number">2000</span>)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>产生的vnode为</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> prevCompVNode = h(ChildComponent, &#123;</span><br><span class="line">  text: <span class="string">'one'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> nextCompVNode = h(ChildComponent, &#123;</span><br><span class="line">  text: <span class="string">'two'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这个时候就是这两个东西之间的patch了，调用之前写好的patch函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (nextFlags &amp; VNodeFlags.COMPONENT) &#123;</span><br><span class="line">    patchComponent(prevVNode, nextVNode, container)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们现在要实现这个patchComponent函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patchComponent</span>(<span class="params">prevVNode, nextVNode, container</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 检查组件是否是有状态组件</span></span><br><span class="line">  <span class="keyword">if</span> (nextVNode.flags &amp; VNodeFlags.COMPONENT_STATEFUL_NORMAL) &#123;</span><br><span class="line">    <span class="comment">// 1、获取组件实例</span></span><br><span class="line">    <span class="keyword">const</span> instance = (nextVNode.children = prevVNode.children)</span><br><span class="line">    <span class="comment">// 这里是通过children直接那有状态组件的vnode，因为我们前面默认赋值了</span></span><br><span class="line">    <span class="comment">// 2、更新 props</span></span><br><span class="line">    instance.$props = nextVNode.data</span><br><span class="line">    <span class="comment">// 3、更新组件</span></span><br><span class="line">    instance._update()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>理论上vnode的children都是用来放子节点的，但是对于组件类型来说，他的子节点应该用插槽放，所以我们这里用children来放组件实例</p>
<p>同时还有一个问题，有的时候父组件data的变化会切换他渲染不同的组件，这个时候我们要定一个策略，我们认为不同的组件渲染不同的内容，对于不同的组件，我们使用新组建的内容替换旧组件渲染的内容</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patchComponent</span>(<span class="params">prevVNode, nextVNode, container</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// tag 属性的值是组件类，通过比较新旧组件类是否相等来判断是否是相同的组件</span></span><br><span class="line">  <span class="keyword">if</span> (nextVNode.tag !== prevVNode.tag) &#123;</span><br><span class="line">    replaceVNode(prevVNode, nextVNode, container)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nextVNode.flags &amp; VNodeFlags.COMPONENT_STATEFUL_NORMAL) &#123;</span><br><span class="line">    <span class="comment">// 获取组件实例</span></span><br><span class="line">    <span class="keyword">const</span> instance = (nextVNode.children = prevVNode.children)</span><br><span class="line">    <span class="comment">// 更新 props</span></span><br><span class="line">    instance.$props = nextVNode.data</span><br><span class="line">    <span class="comment">// 更新组件</span></span><br><span class="line">    instance._update()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面写过一个replaceVnode方法，对于组件要扩充一下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">replaceVNode</span>(<span class="params">prevVNode, nextVNode, container</span>) </span>&#123;</span><br><span class="line">  container.removeChild(prevVNode.el)</span><br><span class="line">  <span class="comment">// 如果将要被移除的 VNode 类型是组件，则需要调用该组件实例的 unmounted 钩子函数</span></span><br><span class="line">  <span class="keyword">if</span> (prevVNode.flags &amp; VNodeFlags.COMPONENT_STATEFUL_NORMAL) &#123;</span><br><span class="line">    <span class="comment">// 类型为有状态组件的 VNode，其 children 属性被用来存储组件实例对象</span></span><br><span class="line">    <span class="keyword">const</span> instance = prevVNode.children</span><br><span class="line">    instance.unmounted &amp;&amp; instance.unmounted()</span><br><span class="line">  &#125;</span><br><span class="line">  mount(nextVNode, container)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数式组件更新"><a href="#函数式组件更新" class="headerlink" title="函数式组件更新"></a>函数式组件更新</h2><p>观察函数式组件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子组件 - 函数式组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyFunctionalComp</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> h(<span class="string">'div'</span>, <span class="literal">null</span>, props.text)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 父组件的 render 函数中渲染了 MyFunctionalComp 子组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParentComponent</span> </span>&#123;</span><br><span class="line">  localState = <span class="string">'one'</span></span><br><span class="line"></span><br><span class="line">  mounted() &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.localState = <span class="string">'two'</span></span><br><span class="line">      <span class="keyword">this</span>._update()</span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> h(MyFunctionalComp, &#123;</span><br><span class="line">      text: <span class="keyword">this</span>.localState</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有状态组件 VNode</span></span><br><span class="line"><span class="keyword">const</span> compVNode = h(ParentComponent)</span><br><span class="line">render(compVNode, <span class="built_in">document</span>.getElementById(<span class="string">'app'</span>))</span><br></pre></td></tr></table></figure>

<p>可以看到函数式组件是没有prop的，他是将父组件的参数作为函数的参数传递进去的</p>
<p>修改之前的mountFunctionalComponent</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountFunctionalComponent</span>(<span class="params">vnode, container, isSVG</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取 props</span></span><br><span class="line">  <span class="keyword">const</span> props = vnode.data</span><br><span class="line">  <span class="comment">// 获取 VNode</span></span><br><span class="line">  <span class="keyword">const</span> $vnode = (vnode.children = vnode.tag(props))</span><br><span class="line">  <span class="comment">// 挂载</span></span><br><span class="line">  mount($vnode, container, isSVG)</span><br><span class="line">  <span class="comment">// el 元素引用该组件的根元素</span></span><br><span class="line">  vnode.el = $vnode.el</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用组件函数钱先拿了props，也是放children，对于组件来说，以后他的children都是放slot，这是我们自己设计决定的</p>
<p>接下来修改patchComponent函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patchComponent</span>(<span class="params">prevVNode, nextVNode, container</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (nextVNode.tag !== prevVNode.tag) &#123;</span><br><span class="line">    replaceVNode(prevVNode, nextVNode, container)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nextVNode.flags &amp; VNodeFlags.COMPONENT_STATEFUL_NORMAL) &#123;</span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 在这里编写函数式组件的更新逻辑</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后就是写他中间挂载的方法</p>
<p>同时函数式组件没有组件实例，所以我们没有办法像上面的组件那样封装，所以我们直接把他定义在函数式组件的vnode上</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountFunctionalComponent</span>(<span class="params">vnode, container, isSVG</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 在函数式组件类型的 vnode 上添加 handle 属性，它是一个对象</span></span><br><span class="line">  vnode.handle = &#123;</span><br><span class="line">    prev: <span class="literal">null</span>, <span class="comment">// 旧的函数vnide</span></span><br><span class="line">    next: vnode, <span class="comment">// 新的函数vnode</span></span><br><span class="line">    container, <span class="comment">//容器</span></span><br><span class="line">    update: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 初始化 props</span></span><br><span class="line">      <span class="keyword">const</span> props = vnode.data</span><br><span class="line">      <span class="comment">// 获取 VNode</span></span><br><span class="line">      <span class="keyword">const</span> $vnode = (vnode.children = vnode.tag(props))</span><br><span class="line">      <span class="comment">// 挂载</span></span><br><span class="line">      mount($vnode, container, isSVG)</span><br><span class="line">      <span class="comment">// el 元素引用该组件的根元素</span></span><br><span class="line">      vnode.el = $vnode.el</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 立即调用 vnode.handle.update 完成初次挂载</span></span><br><span class="line">  vnode.handle.update()</span><br></pre></td></tr></table></figure>

<p>修改mountFunctionalComponent，给他一个handle方法，就是我们更新的时候调用的方法，这个handle也是有设计的</p>
<p>在上面加上我们的处理</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 更新函数式组件</span></span><br><span class="line">  <span class="comment">// 通过 prevVNode.handle 拿到 handle 对象</span></span><br><span class="line">  <span class="keyword">const</span> handle = (nextVNode.handle = prevVNode.handle)</span><br><span class="line">  <span class="comment">// 更新 handle 对象</span></span><br><span class="line">  handle.prev = prevVNode <span class="comment">// 存旧的组件</span></span><br><span class="line">  handle.next = nextVNode <span class="comment">// 拿新的组件</span></span><br><span class="line">  handle.container = container <span class="comment">// 更新container</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用 update 函数完成更新</span></span><br><span class="line">  handle.update()</span><br></pre></td></tr></table></figure>

<p>通过判断vnode.handle是否存在来判断是否要更新，更新的时候他会自己调用update</p>
<p>整个patch的设计就在这里了，当然diff算法还没搞</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>源码</tag>
        <tag>读书笔记</tag>
        <tag>框架设计</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack常用需求配置1</title>
    <url>/2020/04/10/webpack/%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>在掘金看的，做笔记</p>
<p>各篇都看一点，以这篇为主</p>
<blockquote>
<p><a href="https://juejin.im/post/5e5c65fc6fb9a07cd00d8838" target="_blank" rel="noopener">https://juejin.im/post/5e5c65fc6fb9a07cd00d8838</a></p>
</blockquote>
<h2 id="webpack是什么，能做什么"><a href="#webpack是什么，能做什么" class="headerlink" title="webpack是什么，能做什么"></a>webpack是什么，能做什么</h2><p>就一个打包的东西嘛</p>
<ul>
<li>代码转换：将tscript编译成js，scss、less编译成css</li>
<li>文件优化：压缩js、css、html代码，压缩合并图片</li>
<li>代码分割：提取多个页面的公共代码，提取首屏不需要执行部分的代码让其异步加载</li>
<li>模块合并需要构建功能将各个分类的模块合并成一个文件</li>
<li>自动刷新：监听本地源代码变化，自动重新构建、刷新浏览器</li>
</ul>
<h2 id="webpack的核心概念"><a href="#webpack的核心概念" class="headerlink" title="webpack的核心概念"></a>webpack的核心概念</h2><ul>
<li>entry：入口</li>
<li>output：输出</li>
<li>loader：模块转换器，等于是按转换器的规则转换</li>
<li>plugins：扩展插件，在webpack构建流程中注入扩展逻辑来改变构建结果</li>
</ul>
<h2 id="入门使用"><a href="#入门使用" class="headerlink" title="入门使用"></a>入门使用</h2><p>没啥好说的，webpack4.0以后开箱即用，有默认配置的，默认入口是./src,默认打包到dist/main.js,但是但是，他是默认什么loader与plugins都没有的，就相当于copy代码0.0</p>
<h3 id="js转义为低版本"><a href="#js转义为低版本" class="headerlink" title="js转义为低版本"></a>js转义为低版本</h3><h4 id="babel-loader"><a href="#babel-loader" class="headerlink" title="babel-loader"></a>babel-loader</h4><p>babel，永远滴神，这个只是又是单独的了，看这个</p>
<blockquote>
<p><a href="https://juejin.im/post/5ddff3abe51d4502d56bd143" target="_blank" rel="noopener">https://juejin.im/post/5ddff3abe51d4502d56bd143</a></p>
</blockquote>
<p>安装好后要配置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.jsx?$/</span>,</span><br><span class="line">                use: [<span class="string">'babel-loader'</span>],</span><br><span class="line">                exclude: <span class="regexp">/node_modules/</span> <span class="comment">//排除 node_modules 目录</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>匹配jsx的给他转换，exclude是不用这个转换器的列表</p>
<p>babel也可以在.babelrc里面编辑规则</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"presets"</span>: [<span class="string">"@babel/preset-env"</span>],</span><br><span class="line">    <span class="string">"plugins"</span>: [</span><br><span class="line">        [</span><br><span class="line">            <span class="string">"@babel/plugin-transform-runtime"</span>,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">"corejs"</span>: <span class="number">3</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>借着说明下这个module的配置规则</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [ <span class="comment">//rules是一个数组，可以有多个规则</span></span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.jsx?$/</span>,   <span class="comment">// 匹配的文件规则，用正则</span></span><br><span class="line">                use: &#123; <span class="comment">//可以用数组，使用多个loader</span></span><br><span class="line">                    loader: <span class="string">'babel-loader'</span>,  <span class="comment">//使用的loader</span></span><br><span class="line">                    options: &#123;</span><br><span class="line">                        <span class="comment">// 这个loader的配置项，就写在了这里，不同loader的配置项是不一样的</span></span><br><span class="line">                        presets: [<span class="string">"@babel/preset-env"</span>],</span><br><span class="line">                        plugins: [</span><br><span class="line">                            [</span><br><span class="line">                                <span class="string">"@babel/plugin-transform-runtime"</span>,</span><br><span class="line">                                &#123;</span><br><span class="line">                                    <span class="string">"corejs"</span>: <span class="number">3</span></span><br><span class="line">                                &#125;</span><br><span class="line">                            ]</span><br><span class="line">                        ]</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                exclude: <span class="regexp">/node_modules/</span> <span class="comment">//不匹配这个规则的文件夹</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="mode"><a href="#mode" class="headerlink" title="mode"></a>mode</h2><p>将mode（不同模式）配置进webpack.config.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    mode: <span class="string">"development"</span>,</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mode的值</p>
<ul>
<li><p>devlopment:开发，具体启用NamedChunksPlugin与NamedModulesPlugin</p>
</li>
<li><p>production:生产，启用一堆东西</p>
</li>
</ul>
<h2 id="html-webpack-plugin"><a href="#html-webpack-plugin" class="headerlink" title="html-webpack-plugin"></a>html-webpack-plugin</h2><p>这个是一个插件，帮助我们可以人工注入编译好的js（因为每次编译的文件名都可以是随机的，解决了浏览器缓存静态文件的问题）</p>
<p>首先安装，这个不写了</p>
<p>配置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//首先引入插件</span></span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="comment">//数组 放着所有的webpack插件</span></span><br><span class="line">        <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">            template: <span class="string">'./public/index.html'</span>, <span class="comment">// 需要打包的文件</span></span><br><span class="line">            filename: <span class="string">'index.html'</span>, <span class="comment">//打包后的文件名</span></span><br><span class="line">            minify: &#123; <span class="comment">//一些配置项</span></span><br><span class="line">                removeAttributeQuotes: <span class="literal">false</span>, <span class="comment">//是否删除属性的双引号</span></span><br><span class="line">                collapseWhitespace: <span class="literal">false</span>, <span class="comment">//是否折叠空白</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// hash: true //是否加上hash，默认是 false，加上了名字就不一样了</span></span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>html-webpack-plugin可以拥有一个单独的config文件，通过配置设置一些文件引入不引入</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//public/config.js 除了以下的配置之外，这里面还可以有许多其他配置，例如,pulicPath 的路径等等</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    dev: &#123;</span><br><span class="line">        template: &#123;</span><br><span class="line">            title: <span class="string">'你好'</span>,</span><br><span class="line">            header: <span class="literal">false</span>,</span><br><span class="line">            footer: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    build: &#123;</span><br><span class="line">        template: &#123;</span><br><span class="line">            title: <span class="string">'你好才怪'</span>,</span><br><span class="line">            header: <span class="literal">true</span>,</span><br><span class="line">            footer: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有true的选项他才引用，然后要改webpack配置与我们的html</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = require(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> isDev = process.env.NODE_ENV === <span class="string">'development'</span>;</span><br><span class="line"><span class="keyword">const</span> config = require(<span class="string">'./public/config'</span>)[isDev ? <span class="string">'dev'</span> : <span class="string">'build'</span>];</span><br><span class="line"></span><br><span class="line">modue.<span class="keyword">exports</span> = &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    mode: isDev ? <span class="string">'development'</span> : <span class="string">'production'</span></span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">            template: <span class="string">'./public/index.html'</span>,</span><br><span class="line">            filename: <span class="string">'index.html'</span>, <span class="comment">//打包后的文件名</span></span><br><span class="line">            config: config.template</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%</span> <span class="attr">if</span>(<span class="attr">htmlWebpackPlugin.options.config.header</span>) &#123; %&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"//common/css/header.css"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%</span> &#125; %&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span> (<span class="attr">htmlWebpackPlugin.options.config.title</span>) %&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">%</span> <span class="attr">if</span>(<span class="attr">htmlWebpackPlugin.options.config.header</span>) &#123; %&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"//common/header.min.js"</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">%</span> &#125; %&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>修改命令，这里有一个兼容winsows与mac命令行的cross-env</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"scripts"</span>: &#123;</span><br><span class="line">        <span class="string">"dev"</span>: <span class="string">"cross-env NODE_ENV=development webpack"</span>,</span><br><span class="line">        <span class="string">"build"</span>: <span class="string">"cross-env NODE_ENV=production webpack"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更详细的可以看官方文档</p>
<blockquote>
<p><a href="https://github.com/jantimon/html-webpack-plugin#configuration" target="_blank" rel="noopener">https://github.com/jantimon/html-webpack-plugin#configuration</a></p>
</blockquote>
<h2 id="server"><a href="#server" class="headerlink" title="server"></a>server</h2><p>安装，然后配置命令就可以直接跑了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"dev"</span>: <span class="string">"cross-env NODE_ENV=development webpack-dev-server"</span>,</span><br><span class="line">    <span class="string">"build"</span>: <span class="string">"cross-env NODE_ENV=production webpack"</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>同时也可以在config文件里面配置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    devServer: &#123;</span><br><span class="line">        port: <span class="string">'3000'</span>, <span class="comment">//默认是8080</span></span><br><span class="line">        quiet: <span class="literal">false</span>, <span class="comment">//默认不启用,启用的话不会打印错误，不好捉bug</span></span><br><span class="line">        inline: <span class="literal">true</span>, <span class="comment">//默认开启 inline 模式，如果设置为false,开启 iframe 模式</span></span><br><span class="line">        stats: <span class="string">"errors-only"</span>, <span class="comment">//终端仅打印 error  </span></span><br><span class="line">        overlay: <span class="literal">false</span>, <span class="comment">//默认不启用</span></span><br><span class="line">        clientLogLevel: <span class="string">"silent"</span>, <span class="comment">//日志等级</span></span><br><span class="line">        compress: <span class="literal">true</span> <span class="comment">//是否启用 gzip 压缩</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="devtool"><a href="#devtool" class="headerlink" title="devtool"></a>devtool</h2><p>帮助我们将编译后的代码映射回原始源代码，不同的值影响构建的速度（就是出错的时候等够定位源码）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    devtool: <span class="string">'cheap-module-eval-source-map'</span> <span class="comment">//开发环境下使用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 生产环境下可以使用none或者source-map</span></span><br></pre></td></tr></table></figure>

<h2 id="处理css"><a href="#处理css" class="headerlink" title="处理css"></a>处理css</h2><p>我习惯用sass</p>
<p>webpack不能处理css，要借助很多loader，如果我用sass的话，一般会用style-loader、css-loader、postcss-loader、sass-loader</p>
<p>配置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js  </span></span><br><span class="line"><span class="comment">// 这个是less的配置，尴尬</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.(le|c)ss$/</span>,</span><br><span class="line">                use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, &#123;</span><br><span class="line">                    loader: <span class="string">'postcss-loader'</span>,</span><br><span class="line">                    options: &#123;</span><br><span class="line">                        plugins: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                            <span class="keyword">return</span> [</span><br><span class="line">                                <span class="built_in">require</span>(<span class="string">'autoprefixer'</span>)(&#123;</span><br><span class="line">                                    <span class="string">"overrideBrowserslist"</span>: [</span><br><span class="line">                                        <span class="string">"&gt;0.25%"</span>,</span><br><span class="line">                                        <span class="string">"not dead"</span></span><br><span class="line">                                    ]</span><br><span class="line">                                &#125;)</span><br><span class="line">                            ]</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="string">'less-loader'</span>],</span><br><span class="line">                exclude: <span class="regexp">/node_modules/</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>poctcss-loader可以关注下，这个东西可以自动兼容浏览器前缀，完美</p>
<p>loader的执行顺序是里面向外面执行得例如上面的例子sess、postcss、css、style</p>
<p>可以用enforce改优先级</p>
<h2 id="图片文字处理"><a href="#图片文字处理" class="headerlink" title="图片文字处理"></a>图片文字处理</h2><p>使用url-loader与file-loader</p>
<p>配置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    modules: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.(png|jpg|gif|jpeg|webp|svg|eot|ttf|woff|woff2)$/</span>,</span><br><span class="line">                use: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: <span class="string">'url-loader'</span>,</span><br><span class="line">                        options: &#123;</span><br><span class="line">                            limit: <span class="number">10240</span>, <span class="comment">//10K</span></span><br><span class="line">                            esModule: <span class="literal">false</span>,</span><br><span class="line">                            outputPath: <span class="string">'assets'</span>, <span class="comment">// 可以选择输出到同一个目录</span></span><br><span class="line">                            name: <span class="string">'[name]_[hash:6].[ext]'</span> <span class="comment">// 哈希命名</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                ],</span><br><span class="line">                exclude: <span class="regexp">/node_modules/</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>limit为限制资源大小，小于这个资源就转为base64，超过这个大小的话就放到dist目录里面</p>
<p>这个esModule记得设置false，否则{require(‘XXX.jpg’)} /&gt; 会出现 &lt;img src=[Module Object] /&gt;</p>
<h3 id="html本地图片"><a href="#html本地图片" class="headerlink" title="html本地图片"></a>html本地图片</h3><p>本地html相对路径拿不到图片，这个我目前没有遇过，可以记一记先</p>
<p>这里可以使用html-withimg-loader，或者直接改你前面那个html的img配置</p>
<p>html-withimg-loader配置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    modules: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.(png|jpg|gif|jpeg|webp|svg|eot|ttf|woff|woff2)$/</span>,</span><br><span class="line">                use: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: <span class="string">'url-loader'</span>,</span><br><span class="line">                        options: &#123;</span><br><span class="line">                            limit: <span class="number">10240</span>, <span class="comment">//10K</span></span><br><span class="line">                            esModule: <span class="literal">false</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>img的写法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;img src=<span class="string">"&lt;%= require('./thor.jpeg') %&gt;"</span> /&gt;</span><br></pre></td></tr></table></figure>

<h2 id="入口配置"><a href="#入口配置" class="headerlink" title="入口配置"></a>入口配置</h2><p>老配置了，可以用字符串或者数组，数组的时候表示有多个主入口，想要多个依赖文件一起折辱，会这样配置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">entry: [</span><br><span class="line">    <span class="string">'./src/polyfills.js'</span>,</span><br><span class="line">    <span class="string">'./src/index.js'</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="出口配置"><a href="#出口配置" class="headerlink" title="出口配置"></a>出口配置</h2><p>控制webpack如何输出编译文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">'dist'</span>), <span class="comment">//必须是绝对路径</span></span><br><span class="line">        filename: <span class="string">'bundle[hash:6].js'</span>, <span class="comment">//加上哈希解决版本问题,哈希的数字表示长度</span></span><br><span class="line">        publicPath: <span class="string">'/'</span> <span class="comment">//通常是CDN地址</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以放上cdn网络访问哦</p>
<h2 id="每次打包前清空dist目录"><a href="#每次打包前清空dist目录" class="headerlink" title="每次打包前清空dist目录"></a>每次打包前清空dist目录</h2><p>这个是解决前面用了哈希，然后他会不一样名字，就不会覆盖旧名字，就会无限所文件，要使用到一个插件clean-webpack-plugin</p>
<p>配置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="comment">//不需要传参数喔，它可以找到 outputPath</span></span><br><span class="line">        <span class="keyword">new</span> CleanWebpackPlugin() </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 可以这样配置，指定一个目录下的文件不删除</span></span><br><span class="line">        <span class="keyword">new</span> CleanWebpackPlugin(&#123;</span><br><span class="line">            cleanOnceBeforeBuildPatterns:[<span class="string">'**/*'</span>, <span class="string">'!dll'</span>, <span class="string">'!dll/**'</span>] <span class="comment">//不删除dll目录下的文件</span></span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>点击实现复制</title>
    <url>/2020/04/09/%E8%B8%A9%E5%9D%91/babel%E7%BC%96%E8%AF%91ES6class%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>babel普通配置的时候编译报错，报错代码如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父组件类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParentComponent</span> </span>&#123;</span><br><span class="line">    isTrue = <span class="literal">true</span>  <span class="comment">//这句报错</span></span><br><span class="line"></span><br><span class="line">    mounted() &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.isTrue = <span class="literal">false</span></span><br><span class="line">            <span class="keyword">this</span>._update()</span><br><span class="line">        &#125;, <span class="number">2000</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.isTrue ? h(ChildComponent1) : h(ChildComponent2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>引入了各种class都没解决，因为这段代码是看书的，我尝试复刻看书的环境，这个时候报错新的错</p>
<blockquote>
<p>就是上面的错并没有解决，嘤嘤嘤</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.setDynamic is not a function</span><br></pre></td></tr></table></figure>

<p>在stackoverflow看了一下，是我主babel是7的版本，其他的插件也要是7的版本，不能是6的版本，修改后好了</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>babel</tag>
        <tag>工作</tag>
        <tag>踩坑</tag>
      </tags>
  </entry>
  <entry>
    <title>点击实现复制</title>
    <url>/2020/04/06/%E8%B8%A9%E5%9D%91/%E7%82%B9%E5%87%BB%E5%AE%9E%E7%8E%B0%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<p>需求：点击一个按钮复制一段文字</p>
<p>核心：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"urlData"</span> <span class="attr">style</span>=<span class="string">"opacity: 0;position: absolute"</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">value</span>=<span class="string">"'+data.data+'"</span>&gt;</span></span><br><span class="line">data.data</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    $(<span class="string">'#urlData'</span>).select();</span><br><span class="line">    <span class="built_in">document</span>.execCommand(<span class="string">'Copy'</span>);</span><br><span class="line">    layer.close(index);</span><br><span class="line">    alert(<span class="string">"复制成功"</span>)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>解释：</p>
<p>select方法只能选择input框里的文字，然后用execCommand完成系统复制</p>
<p>这里的input要是正常编辑状态，但是我又不想他显示，多用了opacity与position隐藏了他</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>工作</tag>
        <tag>踩坑</tag>
      </tags>
  </entry>
  <entry>
    <title>禁止浏览器密码联想</title>
    <url>/2020/04/27/%E8%B8%A9%E5%9D%91/%E7%A6%81%E6%AD%A2%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%86%E7%A0%81%E8%81%94%E6%83%B3/</url>
    <content><![CDATA[<p>当注册页面也是用户名与密码的时候，如果之前登录保存了密码，浏览器会自动帮你把用户名跟密码填进去，正常的逻辑不是这个亚子的，所以我们要怎么搞呢</p>
<p>不给他password嘛，点击focus的时候才给</p>
<p>这个东西在有password的地方特别容易出现</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>工作</tag>
        <tag>踩坑</tag>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>vue源码学习/11.diff3</title>
    <url>/2020/04/13/vue%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/11.diff3/</url>
    <content><![CDATA[<p>vue3的这种diff借鉴于ivi与inferno</p>
<h2 id="前置与后置处理"><a href="#前置与后置处理" class="headerlink" title="前置与后置处理"></a>前置与后置处理</h2><p>由文本比对例子引入</p>
<p>两个文本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TEXT1: I use vue for app development</span><br><span class="line">text2: I use react for app development</span><br></pre></td></tr></table></figure>

<p>就中间的vue与react不一样，我们可不可以做预处理将头变成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TEXT1: vue</span><br><span class="line">text2: react</span><br></pre></td></tr></table></figure>

<p>这样子我们可以快速替换中间的文本，同时代表文本删除与新增都是可以的</p>
<p>我们分析来看，这个也是diff的策略之一，相同的删除，快速得出不同的元素，应用在我们的vnode上可不可以呢</p>
<p><img src="https://s1.ax1x.com/2020/04/14/GxuvIe.png" alt="GxuvIe.png"></p>
<p>这个亚子的话直接插入d就行了吧，完美</p>
<p>一样用索引把戏玩，找出一样的，然后索引加一,等于删除,判断条件是直到不一样的为止，这样可以连着删除几个</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 更新相同的前缀节点</span></span><br><span class="line"><span class="comment">// j 为指向新旧 children 中第一个节点的索引</span></span><br><span class="line"><span class="keyword">let</span> j = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> prevVNode = prevChildren[j]</span><br><span class="line"><span class="keyword">let</span> nextVNode = nextChildren[j]</span><br><span class="line"><span class="comment">// while 循环向后遍历，直到遇到拥有不同 key 值的节点为止</span></span><br><span class="line"><span class="keyword">while</span> (prevVNode.key === nextVNode.key) &#123;</span><br><span class="line">  <span class="comment">// 调用 patch 函数更新</span></span><br><span class="line">  patch(prevVNode, nextVNode, container)</span><br><span class="line">  j++</span><br><span class="line">  prevVNode = prevChildren[j]</span><br><span class="line">  nextVNode = nextChildren[j]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于新旧children的长度不一样，他们的j不能共用，所以我们分开写</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 更新相同的后缀节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指向旧 children 最后一个节点的索引</span></span><br><span class="line"><span class="keyword">let</span> prevEnd = prevChildren.length - <span class="number">1</span></span><br><span class="line"><span class="comment">// 指向新 children 最后一个节点的索引</span></span><br><span class="line"><span class="keyword">let</span> nextEnd = nextChildren.length - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">prevVNode = prevChildren[prevEnd]</span><br><span class="line">nextVNode = nextChildren[nextEnd]</span><br><span class="line"></span><br><span class="line"><span class="comment">// while 循环向前遍历，直到遇到拥有不同 key 值的节点为止</span></span><br><span class="line"><span class="keyword">while</span> (prevVNode.key === nextVNode.key) &#123;</span><br><span class="line">  <span class="comment">// 调用 patch 函数更新</span></span><br><span class="line">  patch(prevVNode, nextVNode, container)</span><br><span class="line">  prevEnd--</span><br><span class="line">  nextEnd--</span><br><span class="line">  prevVNode = prevChildren[prevEnd]</span><br><span class="line">  nextVNode = nextChildren[nextEnd]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更新完成后应该是这个亚兹的</p>
<p><img src="https://s1.ax1x.com/2020/04/14/GxKcJH.png" alt="GxKcJH.png"></p>
<p>这个时候查看一下我们之前的索引余下值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">j: 1</span><br><span class="line">prevEnd: 0</span><br><span class="line">nextEnd: 1</span><br></pre></td></tr></table></figure>

<p>这里上面两个方法都是要跑的，一个删前面相同的，一个删后面相同的</p>
<p>分析一下，next多了，说明新children是多了的，分析得出我们从j到nextEnd之间的都应该插入，应该插入到什么位置呢，这里我们应该插入到lib之前，lib的代表索引，就是nextEnd+1</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 满足条件，则说明从 j -&gt; nextEnd 之间的节点应作为新节点插入</span></span><br><span class="line"><span class="keyword">if</span> (j &gt; prevEnd &amp;&amp; j &lt;= nextEnd) &#123;</span><br><span class="line">  <span class="comment">// 所有新节点应该插入到位于 nextPos 位置的节点的前面</span></span><br><span class="line">  <span class="keyword">const</span> nextPos = nextEnd + <span class="number">1</span></span><br><span class="line">  <span class="keyword">const</span> refNode =</span><br><span class="line">    nextPos &lt; nextChildren.length ? nextChildren[nextPos].el : <span class="literal">null</span></span><br><span class="line">  <span class="comment">// 采用 while 循环，调用 mount 函数挂载节点</span></span><br><span class="line">  <span class="keyword">while</span> (j &lt;= nextEnd) &#123;</span><br><span class="line">    mount(nextChildren[j++], container, <span class="literal">false</span>, refNode)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那删除的情况呢，这个例子</p>
<p><img src="https://s1.ax1x.com/2020/04/14/GxMPfJ.png" alt="GxMPfJ.png"></p>
<p>跑完之后的索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">j: 1</span><br><span class="line">prevEnd: 1</span><br><span class="line">nextEnd: 0</span><br></pre></td></tr></table></figure>

<p>同理，在j到prevEnd之间的都应该删除，删除在prevEnd+1之后</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; nextEnd) &#123;</span><br><span class="line">    <span class="comment">// j -&gt; prevEnd 之间的节点应该被移除</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt;= prevEnd) &#123;</span><br><span class="line">        container.removeChild(prevChildren[j++].el)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>到此我们基本考虑了所有的情况</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// while 循环向后遍历，直到遇到拥有不同 key 值的节点为止</span></span><br><span class="line"><span class="keyword">while</span> (prevVNode.key === nextVNode.key) &#123;</span><br><span class="line">  <span class="comment">// 调用 patch 函数更新</span></span><br><span class="line">  <span class="comment">// 省略...</span></span><br><span class="line">  j++</span><br><span class="line">  <span class="comment">// 省略...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// while 循环向前遍历，直到遇到拥有不同 key 值的节点为止</span></span><br><span class="line"><span class="keyword">while</span> (prevVNode.key === nextVNode.key) &#123;</span><br><span class="line">  <span class="comment">// 调用 patch 函数更新</span></span><br><span class="line">  <span class="comment">// 省略...</span></span><br><span class="line">  prevEnd--</span><br><span class="line">  nextEnd--</span><br><span class="line">  <span class="comment">// 省略...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 满足条件，则说明从 j -&gt; nextEnd 之间的节点应作为新节点插入</span></span><br><span class="line"><span class="keyword">if</span> (j &gt; prevEnd &amp;&amp; j &lt;= nextEnd) &#123;</span><br><span class="line">  <span class="comment">// j -&gt; nextEnd 之间的节点应该被添加</span></span><br><span class="line">  <span class="comment">// 省略...</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; nextEnd) &#123;</span><br><span class="line">  <span class="comment">// j -&gt; prevEnd 之间的节点应该被移除</span></span><br><span class="line">  <span class="comment">// 省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们都是根据三个索引来玩的，那有没有可能第一个循环以后索引j的值已经大于prevEnd与nextEnd了呢</p>
<p>有可能的嘛，我们考虑这种情况改造代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">outer: &#123;</span><br><span class="line">  <span class="keyword">while</span> (prevVNode.key === nextVNode.key) &#123;</span><br><span class="line">    patch(prevVNode, nextVNode, container)</span><br><span class="line">    j++</span><br><span class="line">    <span class="keyword">if</span> (j &gt; prevEnd || j &gt; nextEnd) &#123;</span><br><span class="line">      <span class="keyword">break</span> outer</span><br><span class="line">    &#125;</span><br><span class="line">    prevVNode = prevChildren[j]</span><br><span class="line">    nextVNode = nextChildren[j]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 更新相同的后缀节点</span></span><br><span class="line">  prevVNode = prevChildren[prevEnd]</span><br><span class="line">  nextVNode = nextChildren[nextEnd]</span><br><span class="line">  <span class="keyword">while</span> (prevVNode.key === nextVNode.key) &#123;</span><br><span class="line">    patch(prevVNode, nextVNode, container)</span><br><span class="line">    prevEnd--</span><br><span class="line">    nextEnd--</span><br><span class="line">    <span class="keyword">if</span> (j &gt; prevEnd || j &gt; nextEnd) &#123;</span><br><span class="line">      <span class="keyword">break</span> outer</span><br><span class="line">    &#125;</span><br><span class="line">    prevVNode = prevChildren[prevEnd]</span><br><span class="line">    nextVNode = nextChildren[nextEnd]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里用了label写法，只要到了j &gt; prevEnd || j &gt; nextEnd会直接跳出这个outer代码块，就不会重复执行循环了</p>
<h2 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h2><p>增删搞完了，是时候搞移动了</p>
<p>判断哪些节点需要移动，要移动到哪里</p>
<blockquote>
<p>到此我们可以概括，diff算法的重点：判断是否有节点需要移动，以及应该如何移动，同时寻找出那些需要被添加或移除的节点</p>
</blockquote>
<p>下面来例子</p>
<p><img src="https://s1.ax1x.com/2020/04/14/Gx3nKA.png" alt="Gx3nKA.png"></p>
<p><a href="https://imgchr.com/i/Gx3Kbt" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/04/14/Gx3Kbt.png" alt="Gx3Kbt.png"></a></p>
<p>处理后我们的情况就是这样，都是要移动的，同时可以看到各索引</p>
<p>现在问题是怎么移动了</p>
<p>我们新建一个与新children剩余节点长度一样的数组，用来放新children的节点在旧的children里面对应的位置索引</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (j &gt; prevEnd &amp;&amp; j &lt;= nextEnd) &#123;</span><br><span class="line">  <span class="comment">// 省略...</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; nextEnd) &#123;</span><br><span class="line">  <span class="comment">// 省略...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;  <span class="comment">// 写在这里，因为这里的参数关系就是除了上面的两种</span></span><br><span class="line">  <span class="comment">// 构造 source 数组</span></span><br><span class="line">  <span class="keyword">const</span> nextLeft = nextEnd - j + <span class="number">1</span>  <span class="comment">// 新 children 中剩余未处理节点的数量</span></span><br><span class="line">  <span class="keyword">const</span> source = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nextLeft; i++) &#123;</span><br><span class="line">    source.push(<span class="number">-1</span>) <span class="comment">// 默认-1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>怎么拿索引呢，两层for循环安排上</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> prevStart = j</span><br><span class="line"><span class="keyword">const</span> nextStart = j</span><br><span class="line"><span class="comment">// 遍历旧 children</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = prevStart; i &lt;= prevEnd; i++) &#123;</span><br><span class="line">  <span class="keyword">const</span> prevVNode = prevChildren[i]</span><br><span class="line">  <span class="comment">// 遍历新 children</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> k = nextStart; k &lt;= nextEnd; k++) &#123;</span><br><span class="line">    <span class="keyword">const</span> nextVNode = nextChildren[k]</span><br><span class="line">    <span class="comment">// 找到拥有相同 key 值的可复用节点</span></span><br><span class="line">    <span class="keyword">if</span> (prevVNode.key === nextVNode.key) &#123;</span><br><span class="line">      <span class="comment">// patch 更新</span></span><br><span class="line">      patch(prevVNode, nextVNode, container)</span><br><span class="line">      <span class="comment">// 更新 source 数组</span></span><br><span class="line">      source[k - nextStart] = i</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s1.ax1x.com/2020/04/14/GxG2Ax.png" alt="GxG2Ax.png"></p>
<p>这里要注意的是k不不是对应source数组的真实的索引，因为余下的节点循环的，要k-nextStart，然后i因为是循环旧的children的，所以是直接反映到的，而如果两次循环后的元素值还是-1，就说明他在旧的children是不存在的，是要新加入的</p>
<p>然后我们要判断他是否需要移动的标志了，与react一样的处理</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line"><span class="keyword">let</span> moved = <span class="literal">false</span></span><br><span class="line"><span class="keyword">let</span> pos = <span class="number">0</span></span><br><span class="line">---</span><br><span class="line"><span class="keyword">if</span> (k &lt; pos) &#123;</span><br><span class="line">    moved = <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    pos = k</span><br><span class="line">&#125;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>然后我们检测到moved为true就去该剧pos移动了嘛</p>
<p>但是双层循环太jb笨b了，用key建立索引表</p>
<p><img src="https://s1.ax1x.com/2020/04/14/GxGTud.png" alt="GxGTud.png"></p>
<p>新建了一个indexMap，键是节点的key，值是在新children的位置索引，就对应了在sources的位置</p>
<p>代码就改成了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> prevStart = j</span><br><span class="line"><span class="keyword">const</span> nextStart = j</span><br><span class="line"><span class="keyword">let</span> moved = <span class="literal">false</span></span><br><span class="line"><span class="keyword">let</span> pos = <span class="number">0</span></span><br><span class="line"><span class="comment">// 构建索引表</span></span><br><span class="line"><span class="keyword">const</span> keyIndex = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = nextStart; i &lt;= nextEnd; i++) &#123;</span><br><span class="line">  keyIndex[nextChildren[i].key] = i</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 遍历旧 children 的剩余未处理节点</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = prevStart; i &lt;= prevEnd; i++) &#123;</span><br><span class="line">  prevVNode = prevChildren[i]</span><br><span class="line">  <span class="comment">// 通过索引表快速找到新 children 中具有相同 key 的节点的位置</span></span><br><span class="line">  <span class="keyword">const</span> k = keyIndex[prevVNode.key]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> k !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    nextVNode = nextChildren[k]</span><br><span class="line">    <span class="comment">// patch 更新</span></span><br><span class="line">    patch(prevVNode, nextVNode, container)</span><br><span class="line">    <span class="comment">// 更新 source 数组</span></span><br><span class="line">    source[k - nextStart] = i</span><br><span class="line">    <span class="comment">// 判断是否需要移动</span></span><br><span class="line">    <span class="keyword">if</span> (k &lt; pos) &#123;</span><br><span class="line">      moved = <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      pos = k</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 没找到 说明旧节点在新的里面没有了，删除</span></span><br><span class="line">       container.removeChild(prevVNode.el)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就变成单层循环咯</p>
<p>然后就是移动咯，moved为true，需要移动</p>
<p>同时加多一个变量判断更新次数，如果更新次数大于新children中需要更新的节点，说明该节点是多余的节点，应该移除咯，这里是一次性移除后面的所有节点了，其实是加快了速度，不用重复判断</p>
<p>完整代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> patched = <span class="number">0</span></span><br><span class="line"><span class="comment">// 遍历旧 children 的剩余未处理节点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = prevStart; i &lt;= prevEnd; i++) &#123;</span><br><span class="line">  prevVNode = prevChildren[i]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (patched &lt; nextLeft) &#123;</span><br><span class="line">    <span class="comment">// 通过索引表快速找到新 children 中具有相同 key 的节点的位置</span></span><br><span class="line">    <span class="keyword">const</span> k = keyIndex[prevVNode.key]</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> k !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">      nextVNode = nextChildren[k]</span><br><span class="line">      <span class="comment">// patch 更新</span></span><br><span class="line">      patch(prevVNode, nextVNode, container)</span><br><span class="line">      patched++</span><br><span class="line">      <span class="comment">// 更新 source 数组</span></span><br><span class="line">      source[k - nextStart] = i</span><br><span class="line">      <span class="comment">// 判断是否需要移动</span></span><br><span class="line">      <span class="keyword">if</span> (k &lt; pos) &#123;</span><br><span class="line">        moved = <span class="literal">true</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pos = k</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 没找到，说明旧节点在新 children 中已经不存在了，应该移除</span></span><br><span class="line">      container.removeChild(prevVNode.el)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 多余的节点，应该移除</span></span><br><span class="line">    container.removeChild(prevVNode.el)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="移动方式"><a href="#移动方式" class="headerlink" title="移动方式"></a>移动方式</h2><p>经过我们的一顿操作上面是这样的</p>
<p><img src="https://s1.ax1x.com/2020/04/14/GxNyRK.png" alt="GxNyRK.png"></p>
<p>我们前面有一个moved为true，true的时候就可以进行DOM操作了</p>
<p>这里用的是最长递增子序列</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (moved) &#123;</span><br><span class="line">  <span class="comment">// 计算最长递增子序列</span></span><br><span class="line">    <span class="comment">// [2 3 1 -1]</span></span><br><span class="line">  <span class="keyword">const</span> seq = lis(sources) <span class="comment">// [ 0, 1 ]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>什么事最长递增子序列：给定一个数值序列，找到它的一个子序列，并且子序列中的值是递增的，子序列中的元素在原序列中不一定连续。</p>
</blockquote>
<p>例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ 0, 8, 4, 12 ]</span><br><span class="line">最长递增子序列：[0, 8, 12]、[0, 4, 12]</span><br></pre></td></tr></table></figure>

<p>这个list函数要自己搞的，后面说</p>
<p>上面为什么会返回[0,1],因为我们的diff算法返回的是索引对应[2,3]的索引位置</p>
<p>得到这个有什么用呢？</p>
<p>[0,1]代表的是他们的在source中的先后关系与在旧children中的先后关系相同，可以理解为位于位置0和位置1的节点是不需要被移动的节点</p>
<p>然后我们这样操作</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (moved) &#123;</span><br><span class="line">  <span class="keyword">const</span> seq = lis(source)</span><br><span class="line">  <span class="comment">// j 指向最长递增子序列的最后一个值</span></span><br><span class="line">  <span class="keyword">let</span> j = seq.length - <span class="number">1</span></span><br><span class="line">  <span class="comment">// 从后向前遍历新 children 中的剩余未处理节点</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = nextLeft - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i !== seq[j]) &#123;</span><br><span class="line">      <span class="comment">// 说明该节点需要移动</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 当 i === seq[j] 时，说明该位置的节点不需要移动</span></span><br><span class="line">      <span class="comment">// 并让 j 指向下一个位置</span></span><br><span class="line">      j--</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意i的范围，是0到nextLeft - 1的，实际上等价与我们对剩余节点进行了重新编号</p>
<p>如果为-1，说明是全新的节点，需要挂载，增加判断</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (source[i] === <span class="number">-1</span>) &#123;</span><br><span class="line">     <span class="comment">// 作为全新的节点挂载</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// 该节点在新 children 中的真实位置索引</span></span><br><span class="line">     <span class="keyword">const</span> pos = i + nextStart</span><br><span class="line">     <span class="keyword">const</span> nextVNode = nextChildren[pos]</span><br><span class="line">     <span class="comment">// 该节点下一个节点的位置索引</span></span><br><span class="line">     <span class="keyword">const</span> nextPos = pos + <span class="number">1</span></span><br><span class="line">     <span class="comment">// 挂载</span></span><br><span class="line">     mount(</span><br><span class="line">       nextVNode,</span><br><span class="line">       container,</span><br><span class="line">       <span class="literal">false</span>,</span><br><span class="line">       nextPos &lt; nextChildren.length</span><br><span class="line">         ? nextChildren[nextPos].el</span><br><span class="line">         : <span class="literal">null</span></span><br><span class="line">     )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，这里这个pos又是真正的索引（i+nextStart）了，</p>
<p>这个是新增的，那么换位置的呢</p>
<p>这样搞</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line"><span class="comment">// 该节点在新 children 中的真实位置索引</span></span><br><span class="line"><span class="keyword">const</span> pos = i + nextStart</span><br><span class="line"><span class="keyword">const</span> nextVNode = nextChildren[pos]</span><br><span class="line"><span class="comment">// 该节点下一个节点的位置索引</span></span><br><span class="line"><span class="keyword">const</span> nextPos = pos + <span class="number">1</span></span><br><span class="line"><span class="comment">// 移动</span></span><br><span class="line">container.insertBefore(</span><br><span class="line">    nextVNode.el,</span><br><span class="line">    nextPos &lt; nextChildren.length</span><br><span class="line">    ? nextChildren[nextPos].el</span><br><span class="line">    : <span class="literal">null</span></span><br><span class="line">)</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>这里取了他真实节点的后一个节点插入</p>
<p>到这里，我们解决了所有问题！！！</p>
<p>求解最长递增子序列分开写：</p>
<p><a href=""></a></p>
<h2 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h2>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>源码</tag>
        <tag>读书笔记</tag>
        <tag>框架设计</tag>
      </tags>
  </entry>
  <entry>
    <title>跨域坑</title>
    <url>/2020/04/14/%E8%B8%A9%E5%9D%91/%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<blockquote>
<p>来源：<a href="https://juejin.im/post/5e948bbbf265da47f2561705" target="_blank" rel="noopener">https://juejin.im/post/5e948bbbf265da47f2561705</a></p>
</blockquote>
<h2 id="跨域产生的原因"><a href="#跨域产生的原因" class="headerlink" title="跨域产生的原因"></a>跨域产生的原因</h2><h3 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h3><p>一个安全策略，限制了一个origin的问题或者他加载的脚本如果与另一个源的资源进行交互，为了安全，你要按照我规定的方式交互</p>
<h3 id="同源定义"><a href="#同源定义" class="headerlink" title="同源定义"></a>同源定义</h3><p>只有protocol(协议)、domain(域名)、port(端口)三者一致时，才是同源，不同就是跨域了</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>定义：使用额外的HTTP头来告诉浏览器让运行在一个origin（远端）上的web应用可以访问来自不同源服务器上的指定的资源，当一个资源或者这个资源本身所在的服务器请求一个不同源的资源时，资源就会发起一个跨域http请求</p>
<p>分类：简单请求、复杂请求</p>
<h4 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h4><p>不会触发CORS预检请求</p>
<blockquote>
<p>CORS预检请求</p>
<p>首先使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/OPTIONS" target="_blank" rel="noopener"><code>OPTIONS</code></a>  方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求。”预检请求“的使用，可以避免跨域请求对服务器的用户数据产生未预期的影响。</p>
<p>就是实际请求前先发一次请求确认</p>
</blockquote>
<p>情况</p>
<ul>
<li><p>使用GET、HEAD、POST请求</p>
</li>
<li><p>人为设置以下请求头</p>
<ul>
<li>Accept、Accept-Language、Content-Language、Content-Type、DPR、Downlink、Save-Data、Viewprt-Width、Width</li>
</ul>
</li>
<li><p>Content-Type的值为</p>
<ul>
<li>text/plain、multipart/form-data、application/x-www-form-urlencoded</li>
</ul>
</li>
<li><p>请求中的任意XMLHttpRequestUpload对象没有注册任何时间监听器</p>
</li>
<li><p>请求中没有使用ReadableStream对象</p>
</li>
</ul>
<h4 id="复杂请求"><a href="#复杂请求" class="headerlink" title="复杂请求"></a>复杂请求</h4><p>以上除外的</p>
<h4 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h4><p>最常用的CORS就是前端加请求头，服务器设置相关字段，循环跨域请求，以node端代码为例</p>
<p>需要设置这个Access-Control-Allow-Origin，就可以跨域请求拉~~</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">    <span class="string">'Access-Control-Allow-Origin'</span>: <span class="string">'*'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者使用了 Express 这样的框架</span></span><br><span class="line">res.header(<span class="string">"Access-Control-Allow-Origin"</span>, <span class="string">"*"</span>);</span><br></pre></td></tr></table></figure>

<h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><p>利用script标签默认可以跨域的原理，直接跨域，缺点是只能get请求,但是兼容性好</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 通过原生使用 script 标签 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">jsonpCallback</span><span class="params">(data)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        alert(<span class="string">'获取到的数据了，打开控制台瞧瞧'</span>);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(data);</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://127.0.0.1:3000?callback=jsonpCallback"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以直接用ajax的jsonp</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- AJAX GET 请求 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">jsonpCallback</span><span class="params">(data)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        alert(<span class="string">'获取到的数据了，打开控制台瞧瞧'</span>);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(data);</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    $.ajax(&#123;</span></span><br><span class="line"><span class="actionscript">        type: <span class="string">'GET'</span>, <span class="comment">// 必须是 GET 请求</span></span></span><br><span class="line"><span class="actionscript">        url: <span class="string">'http://127.0.0.1:3000'</span>,</span></span><br><span class="line"><span class="actionscript">        dataType: <span class="string">'jsonp'</span>, <span class="comment">// 设置为 jsonp 类型</span></span></span><br><span class="line"><span class="actionscript">        jsonpCallback: <span class="string">'jsonpCallback'</span> <span class="comment">// 设置回调函数</span></span></span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>最常用就这两种，先这样吧，后面踩坑遇到回来补</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>工作</tag>
        <tag>踩坑</tag>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title>EventLoop</title>
    <url>/2020/05/04/%E9%9D%A2%E8%AF%95/yck-EventLoop/</url>
    <content><![CDATA[<p>来讲eventloop，众所周知，js是单线程的（起飞）</p>
<h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><p>线程与进程分别描述的是什么呢，其实他们描述的都是cpu对于任务的工作时间的概念</p>
<p>进程指的是运行指令以及保存上下文所需的时间，可以简单理解为一个程序，那就好理解了</p>
<p>线程理解为cpu 的一个核心，一个核心在同一时间内只能干一件事</p>
<p>浏览器渲染的过程中，如果ui渲染与js运行并列运行的话，他们其中一个可能会阻止另外一个的进行</p>
<p>单线程也是有一点好处的</p>
<ul>
<li>节约内存</li>
<li>加快切换上下文的时间</li>
<li>没有锁的问题</li>
</ul>
<h2 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h2><p>这个看过好多次了，就是函数执行的栈结果，先进后出，直到所有函数执行完</p>
<p>平时chrome报错弹得也是栈报错</p>
<p>注意栈是会爆的，还是要注意一下栈的大小</p>
<h2 id="浏览器的EventLoop"><a href="#浏览器的EventLoop" class="headerlink" title="浏览器的EventLoop"></a>浏览器的EventLoop</h2><p>知道什么是执行栈之后，我们就可以来看EvetnLoop了</p>
<p>因为js是单线程的嘛，我在执行栈中遇到了异步代码怎么办？</p>
<p>js会将栈中的任务挂起，放在task（队列）中，到我当前栈中没有了要执行的代码，他就会从task中拿任务出来执行的了</p>
<p>这么看js本质上是单线程同步的，不过代码执行顺序不一样</p>
<p><img src="http://zezeze-note.oss-cn-hongkong.aliyuncs.com/%E7%AC%94%E8%AE%B0%E6%88%AA%E5%9B%BE/%E9%9D%A2%E8%AF%95/yck-EventLoop/Snipaste_2020-05-04_20-52-12.png?OSSAccessKeyId=LTAI4GCeVHegRoadhkK6mc12&Expires=1588600406&Signature=2i92zjLYsZNxSD56%2FDXDVYwptnE%3D" alt=""></p>
<p>任务可以分为微任务与宏任务，es6中，微任务称为jobs，macrotsk称为task</p>
<p>这里有一个说明我们正常写的代码的时候触发的例子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> async2()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async2 end'</span>)</span><br><span class="line">&#125;</span><br><span class="line">async1()</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Promise'</span>)</span><br><span class="line">  resolve()</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise2'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>)</span><br><span class="line"><span class="comment">// script start =&gt; async2 end =&gt; Promise =&gt; script end =&gt; promise1 =&gt; promise2 =&gt; async1 end =&gt; setTimeout</span></span><br></pre></td></tr></table></figure>

<p>怎么理解这个顺序呢，执行async的时候，没有await的就普通执行，当遇到await，就可以当做是让出线程的标志，然后跟后面的两个then相比，是我先进队列的，所以同步完之后是我先执行，然后再到两个then，最后到排在最后的setTimeout</p>
<p>总结EventLoop的执行顺序</p>
<ul>
<li>先执行同步代码，称为宏任务</li>
<li>执行栈为空，查询是否有异步代码执行，称为微任务</li>
<li>执行异步代码</li>
<li>查询是否要渲染页面</li>
<li>一个宏任务执行完了，执行宏任务的回调setTimeout，然后到下一轮</li>
</ul>
<p>宏微的分别我目前认为是这个代码是否异步的，可以理解为主任务与压后的任务</p>
<h2 id="Node中的EvetnLoop"><a href="#Node中的EvetnLoop" class="headerlink" title="Node中的EvetnLoop"></a>Node中的EvetnLoop</h2><p>Node中改写了EventLoop，跟浏览器的不一样了</p>
<p>Node中的EventLoop分为6个阶段，会按照顺序反复执行</p>
<p><img src="http://zezeze-note.oss-cn-hongkong.aliyuncs.com/%E7%AC%94%E8%AE%B0%E6%88%AA%E5%9B%BE/%E9%9D%A2%E8%AF%95/yck-EventLoop/Snipaste_2020-05-04_21-17-30.png?OSSAccessKeyId=LTAI4GCeVHegRoadhkK6mc12&Expires=1588601866&Signature=7W2J6zgwUUxqYDS%2Fkvu10Bq5fnU%3D" alt=""></p>
<ul>
<li>timer：执行setTimeout与setInterval回调，一样不是准确按照执行的</li>
<li>IO：做上一轮io操作的回调</li>
<li>idle、prepare</li>
<li>poll：回到timer节点执行还能，执行io回调</li>
<li>执行setImmeiate</li>
<li>close callback：执行close事件</li>
</ul>
<p>这一篇说node的部分有点迷糊，建议还是要找其他文章一起看</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>tcp/ip协议</title>
    <url>/2020/04/24/%E9%9D%A2%E8%AF%95/tcphttp/</url>
    <content><![CDATA[<p>   看的是群主很久之前的文章，就像群主所说，如果我能记住我看过的80%，那我将无敌，可是是不可能的嘛</p>
<p>  多看多写吧</p>
<h2 id="tcp-ip协议群"><a href="#tcp-ip协议群" class="headerlink" title="tcp/ip协议群"></a>tcp/ip协议群</h2><p>  就是一堆通过的互联网协议，总称互联网协议套件IPS，其中tcp与ip是最早通过的标准，其他常见的还有http、ftp、udp等</p>
<h2 id="经典分层"><a href="#经典分层" class="headerlink" title="经典分层"></a>经典分层</h2><p>  其实今天也看过，分七层，有的地方说分四层</p>
<ul>
<li>应用层</li>
<li>运输层</li>
<li>网络层</li>
<li>链路层</li>
</ul>
<p>分层的好处是各层自己管自己的，层之间用规定好的方式交流，一个层改了或者翻车了也不会影响其他层</p>
<h2 id="各层介绍"><a href="#各层介绍" class="headerlink" title="各层介绍"></a>各层介绍</h2><ul>
<li><p>应用层：就是应用通过网络与其他程序通信的层，数据通过应用被编码成特定的格式传输，常用的格式有：HTTP、FTP、SMTP、SSH、DNS</p>
</li>
<li><p>传输层，在应用层的下层，用于两台计算机之间进行数据传输，传输层有两种不同的协议</p>
<ul>
<li>TCP</li>
<li>UDP</li>
</ul>
<p>这个可以好好说说，上图</p>
</li>
</ul>
<p><img src="https://s1.ax1x.com/2020/04/24/JDqff0.png" alt="JDqff0.png"></p>
<p>懂的都懂，老懂了</p>
<h3 id="传输层的使用"><a href="#传输层的使用" class="headerlink" title="传输层的使用"></a>传输层的使用</h3><p>  传输层使用了序列号加确认号的模式，接受的单位为TCP头部+数据这个样子，后面的数据段有大有小可以控制</p>
<p>  什么事序列号与确认号呢，序列号就是相当于当前数据的id嘛，确认号是我接受完成后，我会发送一个确认的号码，表示我已经发送成功的疑似</p>
<h3 id="SYN，同步序列号"><a href="#SYN，同步序列号" class="headerlink" title="SYN，同步序列号"></a>SYN，同步序列号</h3><p>  两个机器之间的序列号是并不一定相等的，他们会使用各自的ISN产生器，产生初始序列号，在建立tcp连接的时候，会通过控制单元中的syn，让两端进行ISN的交换同步</p>
<p>  其实这个就是tcp的三次握手</p>
<p>  <img src="https://s1.ax1x.com/2020/04/24/JDLaB4.png" alt="JDLaB4.png"></p>
<p>如图，三次嘛</p>
<p>具体的后面还要看</p>
<h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>  就是数据流动的层，最常见的就是我们常说的ip协议</p>
<p>  原本ipv4发展为ipv6了嘛，放的节点多了</p>
<p>  同时还有一个概念是路由</p>
<p>就是相当于地图，我怎么将我的数据发送到别人的电脑，中间要经过很多路，用路由表记录路的方向</p>
<p><img src="https://s1.ax1x.com/2020/04/24/JDO92V.png" alt="JDO92V.png"></p>
<h3 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h3><p>  处理网络中的硬件部分的，机器与机器之间连接的方式，最常见的是以太网，也就是我们所说的mac地址，机器的位置</p>
<p>  那么怎么知道机器的位置呢，使用广播查询与通知，找他邻居mac与ip地址的映射，通过ip连接</p>
<h2 id="总传输流"><a href="#总传输流" class="headerlink" title="总传输流"></a>总传输流</h2><p>所以最后综合几层走的路子是这样的</p>
<p><img src="https://s1.ax1x.com/2020/04/24/JDXiWt.png" alt="JDXiWt.png"></p>
<p>这样一层层走过去，同时数据会包上每层特有的东西</p>
<p><img src="https://s1.ax1x.com/2020/04/24/JDXDl6.png" alt="JDXDl6.png"></p>
<h2 id="各种协议"><a href="#各种协议" class="headerlink" title="各种协议"></a>各种协议</h2><p>我们常说的各种协议，是运行在应用层之间的，建立在tcp与udp协议之上的</p>
<ul>
<li>tcp<ul>
<li>http</li>
<li>https</li>
<li>ftp</li>
<li>pop3</li>
<li>smtp</li>
<li>telnet</li>
<li>ssh</li>
</ul>
</li>
<li>udp<ul>
<li>bootp</li>
<li>ntp</li>
<li>dhcp</li>
</ul>
</li>
<li>dns：两个都要用</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>js异步</title>
    <url>/2020/04/29/%E9%9D%A2%E8%AF%95/yck-js%E5%BC%82%E6%AD%A5/</url>
    <content><![CDATA[<p>众所周知，异步是js的一大特色（坑点）</p>
<p>所以搞清楚异步对我们还是很重要的</p>
<h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h2><ul>
<li>并发指的是有两个任务，一段时间内通过任务间的切换完成了这两个任务，这叫做并发（只有一个线程）</li>
<li>并行指的是我分别有任务A、B，同时双线程完成任务，这个叫做并行</li>
</ul>
<h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>回调函数嘛，写js都写，就是异步玩在执行的嘛</p>
<p>回调的一个缺点，容易回调地狱</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ajax(url, () =&gt; &#123;</span><br><span class="line">    <span class="comment">// 处理逻辑</span></span><br><span class="line">    ajax(url1, () =&gt; &#123;</span><br><span class="line">        <span class="comment">// 处理逻辑</span></span><br><span class="line">        ajax(url2, () =&gt; &#123;</span><br><span class="line">            <span class="comment">// 处理逻辑</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>我透，我司日常</p>
<p>回调函数的缺点不是说他不好看不好维护（当然也是之一啦），主要是</p>
<ul>
<li>方法偶尔行太强，一个改动很容易牵引后面的函数</li>
<li>嵌套函数一多，错误无法处理，无法用try catch捕捉错误，不能直接return</li>
</ul>
<p>在不引入es6的情况下，es5自身是无法解决回调地狱的，起飞<del>~</del></p>
<h2 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h2><p>是es6新增的一个写法，叫生成器，里面是一个迭代器iterator的玩法</p>
<p>这里有一篇介绍js循环比较好的文章</p>
<blockquote>
<p><a href="https://juejin.im/post/5c40484bf265da61171cfb4d" target="_blank" rel="noopener">https://juejin.im/post/5c40484bf265da61171cfb4d</a></p>
</blockquote>
<p>这里直接看一个例子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> y = <span class="number">2</span> * (<span class="keyword">yield</span> (x + <span class="number">1</span>))</span><br><span class="line">  <span class="keyword">let</span> z = <span class="keyword">yield</span> (y / <span class="number">3</span>)</span><br><span class="line">  <span class="keyword">return</span> (x + y + z)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> it = foo(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">console</span>.log(it.next())   <span class="comment">// =&gt; &#123;value: 6, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next(<span class="number">12</span>)) <span class="comment">// =&gt; &#123;value: 8, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next(<span class="number">13</span>)) <span class="comment">// =&gt; &#123;value: 42, done: true&#125;</span></span><br></pre></td></tr></table></figure>

<p>这个结果一看有点奇怪，分析一波</p>
<ul>
<li>第一个结果很好理解，5+1停止了是6，这里要留意的是，停的时候会返回一个迭代器给的对象哦</li>
<li>这第二个就奇怪了呀，不应该是12/3为4嘛，错哒，在第二次执行的时候，等于重新传参数了，传入的参数等于第一个的结果并重新执行前面的步骤，那就是这样哒</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// it.next(12)，传入了12哒</span></span><br><span class="line">y=<span class="number">2</span>*<span class="number">12</span></span><br><span class="line">z=<span class="number">24</span>/<span class="number">3</span> = <span class="number">8</span></span><br></pre></td></tr></table></figure>

<ul>
<li>第三次同理嘛，13+28+8</li>
</ul>
<p>感觉有点晕，所以我们一般都不会直接用generator</p>
<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>promise，承诺，有三种状态</p>
<ul>
<li>等待中pending</li>
<li>完成了resolved</li>
<li>拒绝了rejected</li>
</ul>
<p>一旦变为完成或者拒绝的而一种，就无法再次回头了，毕竟是承诺嘛，嘤嘤嘤</p>
<p>我们构造一个promise的时候，他会直接执行里面的代码（发起的请求就马上发起咯），但是我们后面写在then的代码都是延迟执行哒，而且then中会有一个新的promise，给后面继续then用，而我们如果这个then中return了，那么他就会被promise.resolve（）包装了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'new Promise'</span>)</span><br><span class="line">  resolve(<span class="string">'success'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'finifsh'</span>)</span><br><span class="line"><span class="comment">// new Promise -&gt; finifsh</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">1</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res) <span class="comment">// =&gt; 1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> <span class="comment">// 包装成 Promise.resolve(2)</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res) <span class="comment">// =&gt; 2</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>resolve中的结果可以返回给下一个then的promise中当做参数哦</p>
<p>我们可以捕捉promise的错误</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// success</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// failure</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Promise'</span>);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'resolved.'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Hi!'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise</span></span><br><span class="line"><span class="comment">// Hi!</span></span><br><span class="line"><span class="comment">// resolved</span></span><br></pre></td></tr></table></figure>

<h2 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h2><p>最常用的语法糖来哒</p>
<p>函数加上async，会返回一个Promise，一样用东西包好给你，await只能在async中使用，await会等待这个函数的结果再执行下面的</p>
<p>呀咩，那不就是同步函数了吗，其实是的，他就是！！！只不过好看了一点，恩，亿点</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  a = a + <span class="keyword">await</span> <span class="number">10</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'2'</span>, a) <span class="comment">// -&gt; '2' 10</span></span><br><span class="line">&#125;</span><br><span class="line">b()</span><br><span class="line">a++</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span>, a) <span class="comment">// -&gt; '1' 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1 1 </span></span><br><span class="line"><span class="comment">// 2 10</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getStockPriceByName</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> symbol = <span class="keyword">await</span> getStockSymbol(name);</span><br><span class="line">  <span class="keyword">const</span> stockPrice = <span class="keyword">await</span> getStockPrice(symbol);</span><br><span class="line">  <span class="keyword">return</span> stockPrice;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getStockPriceByName(<span class="string">'goog'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="常用的定时器"><a href="#常用的定时器" class="headerlink" title="常用的定时器"></a>常用的定时器</h2><p>定时器算是异步编程的特色哒</p>
<p>常用的有三个</p>
<ul>
<li>setTimeout</li>
<li>setInterval</li>
<li>requestAnimationFrame</li>
</ul>
<h3 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a>setTimeout</h3><p>首先我们要明确，因为js单线程的原因，setTimeout是不准的，我们要修正他</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> period = <span class="number">60</span> * <span class="number">1000</span> * <span class="number">60</span> * <span class="number">2</span></span><br><span class="line"><span class="keyword">let</span> startTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</span><br><span class="line"><span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> end = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime() + period</span><br><span class="line"><span class="keyword">let</span> interval = <span class="number">1000</span></span><br><span class="line"><span class="keyword">let</span> currentInterval = interval</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loop</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  count++</span><br><span class="line">  <span class="comment">// 代码执行所消耗的时间</span></span><br><span class="line">  <span class="keyword">let</span> offset = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime() - (startTime + count * interval);</span><br><span class="line">  <span class="keyword">let</span> diff = end - <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</span><br><span class="line">  <span class="keyword">let</span> h = <span class="built_in">Math</span>.floor(diff / (<span class="number">60</span> * <span class="number">1000</span> * <span class="number">60</span>))</span><br><span class="line">  <span class="keyword">let</span> hdiff = diff % (<span class="number">60</span> * <span class="number">1000</span> * <span class="number">60</span>)</span><br><span class="line">  <span class="keyword">let</span> m = <span class="built_in">Math</span>.floor(hdiff / (<span class="number">60</span> * <span class="number">1000</span>))</span><br><span class="line">  <span class="keyword">let</span> mdiff = hdiff % (<span class="number">60</span> * <span class="number">1000</span>)</span><br><span class="line">  <span class="keyword">let</span> s = mdiff / (<span class="number">1000</span>)</span><br><span class="line">  <span class="keyword">let</span> sCeil = <span class="built_in">Math</span>.ceil(s)</span><br><span class="line">  <span class="keyword">let</span> sFloor = <span class="built_in">Math</span>.floor(s)</span><br><span class="line">  <span class="comment">// 得到下一次循环所消耗的时间</span></span><br><span class="line">  currentInterval = interval - offset </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'时：'</span>+h, <span class="string">'分：'</span>+m, <span class="string">'毫秒：'</span>+s, <span class="string">'秒向上取整：'</span>+sCeil, <span class="string">'代码执行时间：'</span>+offset, <span class="string">'下次循环间隔'</span>+currentInterval) </span><br><span class="line"></span><br><span class="line">  setTimeout(loop, currentInterval)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setTimeout(loop, currentInterval)</span><br></pre></td></tr></table></figure>

<p>我看懂了（大声）</p>
<h3 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval"></a>setInterval</h3><p>这个比settimeout更拉闸，首先他也是不准的，其次其次，他还会累积，上一次的不累积下去哒，会越来越离谱</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">  &#125;,<span class="number">1000</span>)</span><br><span class="line">  sleep(<span class="number">2000</span>)</span><br><span class="line">&#125;</span><br><span class="line">demo()</span><br></pre></td></tr></table></figure>

<h3 id="requestAnimationFrame"><a href="#requestAnimationFrame" class="headerlink" title="requestAnimationFrame"></a>requestAnimationFrame</h3><p>最后是这个动画定时器，他会保证在16.6毫米只执行一次，自带节流，而且他的延时效果是精确的(浏览器牛皮)，多一我们可以用他来实现上面的那个setInerval</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setInterval</span>(<span class="params">callback, interval</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer</span><br><span class="line">  <span class="keyword">const</span> now = <span class="built_in">Date</span>.now</span><br><span class="line">  <span class="keyword">let</span> startTime = now()</span><br><span class="line">  <span class="keyword">let</span> endTime = startTime</span><br><span class="line">  <span class="keyword">const</span> loop = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    timer = <span class="built_in">window</span>.requestAnimationFrame(loop)</span><br><span class="line">    endTime = now()</span><br><span class="line">    <span class="keyword">if</span> (endTime - startTime &gt;= interval) &#123;</span><br><span class="line">      startTime = endTime = now()</span><br><span class="line">      callback(timer)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  timer = <span class="built_in">window</span>.requestAnimationFrame(loop)</span><br><span class="line">  <span class="keyword">return</span> timer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">0</span></span><br><span class="line">setInterval(<span class="function"><span class="params">timer</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">  a++</span><br><span class="line">  <span class="keyword">if</span> (a === <span class="number">3</span>) cancelAnimationFrame(timer)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>

<p>这个看不太懂，好复杂！！！</p>
<p>完，累了休息</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>vue常考知识点</title>
    <url>/2020/04/26/%E9%9D%A2%E8%AF%95/yck-vue%E5%B8%B8%E8%80%83%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h2 id="生命周期钩子函数"><a href="#生命周期钩子函数" class="headerlink" title="生命周期钩子函数"></a>生命周期钩子函数</h2><p>beforeCreated构造函数，是获取不到props与data的，数据首次出现初始化在initState中</p>
<p>然后执行created钩子函数，这个时候可以访问数据了，不过组件还没有被挂载，是看不到的</p>
<p>然后只是beforeMount钩子，开始创建VDOM,最后执行mouted钩子，并将VDOM渲染为只是DOM并且渲染数据，组件中如果有子组件的话，会递归挂载子组件，只有所有子组件挂载完毕，才会执行根组件的挂载钩子</p>
<p>然后剩下的就是数据更新时会调用的beforeUpdate和updated了,没啥好说的，更新时调用</p>
<p>还有一个是keep-alive独有生命周期，分别为activated和deactivated，用keep-alive包裹的组件在切换时不会进行销毁，而是缓存到内存中执行deactivated构造函数，在缓存中渲染后会执行actived</p>
<p>最后是销毁组件的钩子beforeDestory和destoryed，前者适合移除事件，定时器等，释放内存，然后会递归销毁子组件，直到所有的子组件都销毁完毕后会执行根组件的destoryed钩子</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>beforeCreated是拿不到数据的，知道created才有</li>
<li>beforeMount之后会递归创建挂载所有子组件，只有所有子组件挂载完才会执行mouted</li>
<li>keep-alive独有生命周期是在内存的，切换组件不会销毁</li>
<li>beforeDestory后会递归销毁所有的子组件再执行destoryed</li>
</ul>
<p>最后上个图</p>
<p><img src="https://s1.ax1x.com/2020/04/26/Jc4oOe.png" alt="Jc4oOe.png"></p>
<h2 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h2><p>一般面对以下情况</p>
<ul>
<li>父子组件通信</li>
<li>兄弟组件通信</li>
<li>跨层级通信</li>
<li>任意组件通信</li>
</ul>
<h3 id="父子通信"><a href="#父子通信" class="headerlink" title="父子通信"></a>父子通信</h3><p>先来看看父子通信</p>
<p>父组件通过props传递数据给子组件，子组件通过emit发送事件传递数据给父组件</p>
<p>缺点是单向数据流的，子组件只能通过发送事件修改父组件的数据</p>
<p>v-model可以帮助简化这个写法，但是根本上其实是一样的，v-model相当于一个语法糖</p>
<p>通过$parent或者$children对象来访问父子组件中的方法与实例</p>
<p>同时还有$liensters与.sync这两个属性来帮助通信</p>
<ul>
<li>$liensters将父组件中的v-on事件监听器传递给子组件，子组件通过访问$listeners来自定义监听器</li>
<li>.sync：本质上也是一个语法糖</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">父组件中</span><br><span class="line">&lt;input :value.sync = <span class="string">"value"</span>&gt;</span><br><span class="line"></span><br><span class="line">翻译为</span><br><span class="line">&lt;input :value=<span class="string">"value"</span> @update:value=<span class="string">"v =&gt; value = v"</span>&gt;&lt;<span class="regexp">/comp&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">子组件中</span></span><br><span class="line"><span class="regexp">this.$emit('update:value',1)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">就是一个语法糖，有这个.sync的属性都可以通过$emit改变父组件中的值</span></span><br><span class="line"><span class="regexp">就是v-model的变种</span></span><br></pre></td></tr></table></figure>

<h3 id="兄弟组件通信"><a href="#兄弟组件通信" class="headerlink" title="兄弟组件通信"></a>兄弟组件通信</h3><p>通过上面的$parent查找父组件中的其他子组件的值实现</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$parent.$children </span><br><span class="line">可以获得父组件的自组建实例，然后通过组建name获取实例通信</span><br></pre></td></tr></table></figure>

<h3 id="跨多层次组件通信"><a href="#跨多层次组件通信" class="headerlink" title="跨多层次组件通信"></a>跨多层次组件通信</h3><p>有一个api provide/inject方法可以用，不过文档不推荐直接用在服务中</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父组件 A</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  provide: &#123;</span><br><span class="line">    data: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子组件 B</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  inject: [<span class="string">'data'</span>],</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    <span class="comment">// 无论跨几层都能获得父组件的 data 属性</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.data) <span class="comment">// =&gt; 1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="任意通信"><a href="#任意通信" class="headerlink" title="任意通信"></a>任意通信</h3><p>这个无论组件在任何位置都要通信的画，引入全局变量Vuex吧，一般上面说的简单父子兄弟可以不用，如果实在不行还是引入的好</p>
<h2 id="Vue的mixin与minins"><a href="#Vue的mixin与minins" class="headerlink" title="Vue的mixin与minins"></a>Vue的mixin与minins</h2><p>mixin全局混入，会影响到每一个组件，一般的插件都是这样初始化</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.mixin(&#123;</span><br><span class="line">    beforeCreate() &#123;</span><br><span class="line">        <span class="comment">// ...逻辑</span></span><br><span class="line">        <span class="comment">// 这种方式会影响到每个组件的 beforeCreate 钩子函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>但是不建议滥用，但是有的情况真的很方便，一些全局的东西我们可以直接引入，方便</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mixin=&#123;</span><br><span class="line">    data()&#123;</span><br><span class="line">        <span class="keyword">return</span>&#123;</span><br><span class="line">            msg:<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods:&#123;</span><br><span class="line">        foo()&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'hello from mixin!----'</span>+<span class="keyword">this</span>.msg++)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> child=Vue.component(<span class="string">'child'</span>,&#123; </span><br><span class="line">        template:<span class="string">`&lt;h1 @click="foo"&gt;child component&lt;/h1&gt;`</span>, </span><br><span class="line">        mixins:[mixin]</span><br><span class="line">&#125;)</span><br><span class="line">Vue.component(<span class="string">'kid'</span>,&#123; </span><br><span class="line">        template:<span class="string">`&lt;h1 @click="foo"&gt;kid component&lt;/h1&gt;`</span>, </span><br><span class="line">        mixins:[mixin]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>mixins的不会影响全局，看这个例子，复用了foo方法，是个很好的写法</p>
<h2 id="computed和watch的区别"><a href="#computed和watch的区别" class="headerlink" title="computed和watch的区别"></a>computed和watch的区别</h2><p>computed计算属性，依赖其他属性计算值，并且有缓存，只有计算的值变化了才会返回内容</p>
<p>watch监听值的变化，只有有变化就会执行回调</p>
<p>所以一般需要依赖别的属性来动态获得值的时候用computed，对于监听值然后来做复杂业务逻辑的情况用watch</p>
<h2 id="keep-aive组件"><a href="#keep-aive组件" class="headerlink" title="keep-aive组件"></a>keep-aive组件</h2><p>如果一个组件不需要多次渲染浪费性能的话，可以使用keep-alive包住，他就独立在内存中，在切换组件的时候不会进行销毁，再切换回来就会直接出来了，不会重复渲染</p>
<h2 id="v-show与v-if区别"><a href="#v-show与v-if区别" class="headerlink" title="v-show与v-if区别"></a>v-show与v-if区别</h2><p>v-show只切换只是切换display，还是在dom树里面的，切换的消耗比较小，v-if直接在dom树里没了，每次切换都要销毁挂载组件，所以性能消耗更大，不适合在经常切换的场景</p>
<p>但是v-if可以减少初始页面加载的开销，就是首屏不卡，看情况选吧</p>
<h2 id="组件从的data"><a href="#组件从的data" class="headerlink" title="组件从的data"></a>组件从的data</h2><p>我们知道组件中的data一般是return的写法，那为什么呢</p>
<p>组件复用时所有实例都共享data，所以如果data是对象的写法，一个实例改变会影响其他实例，所以要写成函数return出去，不会影响其他实例</p>
<p>而new Vue方法的话是创造根组件的，一般情况下不会复用，所以咋写都没问题</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>面试/test</title>
    <url>/2020/04/29/%E9%9D%A2%E8%AF%95/test/</url>
    <content><![CDATA[<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
<meta name="generator" content="Hexo 4.2.0"></head>

<body>
    <div>
        
    </div>
    <script>
        function observe(obj) {
            // 判断类型
            if (!obj || typeof obj !== 'object') {
                return
            }
            Object.keys(obj).forEach(key => {
                defineReactive(obj, key, obj[key])
            })
        }

        function defineReactive(obj, key, val) {
            // 递归子属性
            observe(val)
            let dp = new Dep()
            Object.defineProperty(obj, key, {
                enumerable: true,
                configurable: true,
                get: function reactiveGetter() {
                    console.log('get value')
                    // 将 Watcher 添加到订阅
                    if (Dep.target) {
                        dp.addSub(Dep.target)
                    }
                    return val
                },
                set: function reactiveSetter(newVal) {
                    console.log('change value')
                    val = newVal
                    // 执行 watcher 的 update 方法
                    dp.notify()
                }
            })
        }

        class Dep {
            constructor() {
                this.subs = []
            }
            // 添加依赖
            addSub(sub) {
                this.subs.push(sub)
            }
            // 更新
            notify() {
                this.subs.forEach(sub => {
                    sub.update()
                })
            }
        }
        // 全局属性，通过该属性配置 Watcher
        Dep.target = null

        class Watcher {
            constructor(obj, key, cb) {
                // 将 Dep.target 指向自己
                // 然后触发属性的 getter 添加监听
                // 最后将 Dep.target 置空
                Dep.target = this
                this.cb = cb
                this.obj = obj
                this.key = key
                this.value = obj[key]
                Dep.target = null
            }
            update() {
                // 获得新值
                this.value = this.obj[this.key]
                // 调用 update 方法更新 Dom
                this.cb(this.value)
            }
        }
        
        var data = {
            name: 'yck'
        }
        observe(data)

        function update(value) {
            document.querySelector('div').innerText = value
        }
        // 模拟解析到 `` 触发的操作
        new Watcher(data, 'name', update)
        // update Dom innerText
        data.name = 'yyy'
    </script> 
</body>

</html>]]></content>
  </entry>
  <entry>
    <title>vue常见问题</title>
    <url>/2020/04/26/%E9%9D%A2%E8%AF%95/yck-vue%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="MVVM是什么"><a href="#MVVM是什么" class="headerlink" title="MVVM是什么"></a>MVVM是什么</h2><h3 id="首先什么是View，什么事Model"><a href="#首先什么是View，什么事Model" class="headerlink" title="首先什么是View，什么事Model"></a>首先什么是View，什么事Model</h3><p>  View，就是页面嘛，Model，就是指本地数据和数据库中的数据</p>
<p>  传统的MVC用控制器更新模型，视图从模型中获取数据去渲染，当用户有输入时，控制控制器去更新模型，并且通知视图更新</p>
<p>  当项目越来越大的时候，控制器</p>
<p>代码越来越臃肿，控制器就越来越复杂，代码越来越多，不利于维护</p>
<p>MVVM引入ViewModel,为了独立view与model，用viewmodl做中间者，不用control了，多个view共用一个viewmodel逻辑</p>
<p>说人话，以vue来说，view就是模板，model就是数据来源，viewModel就是组件的实例（可以理解为view更新的规则，），同时还会引入数据绑定的功能，model改变就改变viewmodel的数据</p>
<p>这里的话，MVVM的精髓是通过ViewModel将视图中的状态和用户的行为分离出一个抽象，就是vm状态全由数据驱动的了</p>
<h2 id="Virtual-Dom"><a href="#Virtual-Dom" class="headerlink" title="Virtual Dom"></a>Virtual Dom</h2><p>原生操作dom是很慢的，而操作js很快，可以通过js来模拟dom，更重要的是，抽象出了dom，可以进行更多的操作</p>
<p>在更新时对两个虚拟dom（js对象）进行最小差异并且局部更新Dom</p>
<p>这个我的vue源码笔记有说，不认真看，总体来说就是设计一整套diff算法，来达到最快更新</p>
<p>Virtual Dom的优势</p>
<ul>
<li>将vdmo作为兼容层，可以对非web端的系统，实现跨端开发</li>
<li>通过vdom可以渲染其他平台</li>
<li>实现组件高度抽象化</li>
</ul>
<h2 id="路由原理"><a href="#路由原理" class="headerlink" title="路由原理"></a>路由原理</h2><p>路由要做啥，简单说就是要监听url的变化，然后匹配路由规则，显示相应的页面，并且不用刷新页面</p>
<p>前端路由实现的方式</p>
<ul>
<li>Hash模式</li>
<li>History模式</li>
</ul>
<h3 id="Hash模式"><a href="#Hash模式" class="headerlink" title="Hash模式"></a>Hash模式</h3><p>简单说就是#号后面的哈希值发生变化，可以通过haschange事件监听到URL的变化，从而进行页面跳转，并且无论哈希值如何变化，服务端收到的url永远都是<a href="http://www.test.com" target="_blank" rel="noopener">www.test.com</a></p>
<h3 id="History"><a href="#History" class="headerlink" title="History"></a>History</h3><p>是html5的新功能，主要使用hostor.pushState和replaceState改变urrl</p>
<p>用这两个方法改变url不会引起页面的刷新，只会更新浏览器的历史记录</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 新增历史记录</span></span><br><span class="line">history.pushState(stateObject, title, URL)</span><br><span class="line"><span class="comment">// 替换当前历史记录</span></span><br><span class="line">history.replaceState(stateObject, title, URL)</span><br></pre></td></tr></table></figure>

<p>用户触发浏览器动作时，比如点击后退按钮时会触发popState事件，我们就可以或者他的state了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'popstate'</span>, e =&gt; &#123;</span><br><span class="line">  <span class="comment">// e.state 就是 pushState(stateObject) 中的 stateObject</span></span><br><span class="line">  <span class="built_in">console</span>.log(e.state)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="两种模式的对比"><a href="#两种模式的对比" class="headerlink" title="两种模式的对比"></a>两种模式的对比</h3><ul>
<li><p>Hash只可以改变后面#的内容，History比较随意，可以用api任意设置同源的url</p>
</li>
<li><p>History模式可以通过API添加任意类型的api到历史记录中，Hash模式只能更改哈希值，也就是字符串</p>
</li>
<li><p>Hash无需后端配置，并且兼容性号，History模式在用户手动输入地址或者地址刷新后都会发起url请求，后端要配置好一个inde.html对应匹配不到的静态资源</p>
</li>
</ul>
<h2 id="Vue、React的区别"><a href="#Vue、React的区别" class="headerlink" title="Vue、React的区别"></a>Vue、React的区别</h2><p>react比vue自由，换一种说法就是比vue难，vue语法糖多</p>
<p>react同时使用jsx，有一定成本，但是更灵活是真的</p>
<p>其实两者区别真的不大，做的事情都是一样的</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器是怎么选软的</title>
    <url>/2020/04/28/%E9%9D%A2%E8%AF%95/yck-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E6%80%8E%E4%B9%88%E6%B8%B2%E6%9F%93%E7%9A%84/</url>
    <content><![CDATA[<p>对应不同的文件会编译生成不同的东西，分别看</p>
<h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><p>html要翻译成dom树</p>
<p>浏览器请求服务器，服务器返回数据，这些数据都是二进制的0与1，然后浏览器会将这些二进制翻译成字符串，就是我们说的代码</p>
<p>浏览器接受到代码，会通过自己的词法分析转换为标记，标记在html中就是我们说的标签，当然不同的语言编译的时候是不一样的，我们这里只讨论html</p>
<p>当有了标记后，浏览器会生成节点node，然后根据node之间的联系生成一颗dom树</p>
<p>这就是html的解析过程</p>
<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><p>这个时候，浏览器接受到css，根据css选择器生成最终每一个节点的样式是怎么样的，在这个过程中，不同的选择器对资源的耗费也是不一样的，如果我们css的层级过深，耗费的资源也会增大</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.zeze</span> <span class="selector-class">.zezeze</span> <span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，对于第二个标签，他会先找.zeze，再找.zezeze，最后再找div，对比直接div耗费的资源当然就多了吗</p>
<p>所以我们在设计html的时候要避免添加无意义的标签，保证层级扁平</p>
<p>然后我们根据css，生成一个cssom树，与dom树结合为渲染树</p>
<p>这一过程不是简单的结合，他会选择要渲染的节点，例如设置了display：none的节点，在渲染树中是没有的，当然dom树还是有的</p>
<p>然后浏览器会根据渲染树去渲染，首先会做一个布局的操作，也叫做回流，是调用gpu绘制的，定位好渲染好就可以看到页面了</p>
<h2 id="为什么操作dom慢"><a href="#为什么操作dom慢" class="headerlink" title="为什么操作dom慢"></a>为什么操作dom慢</h2><p>为什么说直接操作dom性能很差？</p>
<p>因为dom是浏览器渲染引擎中的东西，而js是js引擎的东西，用js去控制dom，在两个线程之间通信，如果操作的dom个数过多，那么线程之间就会一直通信，一直通信就一直卡，然后操作dom会触发回流，那就是卡上加卡</p>
<h3 id="如何优化插入dom"><a href="#如何优化插入dom" class="headerlink" title="如何优化插入dom"></a>如何优化插入dom</h3><ul>
<li>一个思路是用requestAnimationFrame去循环插入dom</li>
<li>另外一个思路是我只渲染用户看到的地方</li>
</ul>
<p>比较典型的是虚拟滚动，滚动的时候只渲染看到的部分，没看到的就不渲染了，dom元素永远就只有页面的部分啦</p>
<h2 id="什么是阻塞渲染"><a href="#什么是阻塞渲染" class="headerlink" title="什么是阻塞渲染"></a>什么是阻塞渲染</h2><ul>
<li>第一个因素是html与css结构，如果结果复杂太大，解析的时候会阻塞渲染，应该优化选择器，扁平化</li>
<li>当解析到script时，会暂停构建dom，去加载js，完成后会从暂停的地方重新开始，也就是说，如果想首屏快，就不应该在首屏加载js，实在不行js能放底部的都放底部，不要挡着dom渲染，当然也可以添加defer或者async属性，但是要注意不要有依赖，如果js之间有依赖这样是会拉闸的</li>
</ul>
<h2 id="重绘和回流"><a href="#重绘和回流" class="headerlink" title="重绘和回流"></a>重绘和回流</h2><p>在我们操作dom的时候会频繁出现，同时会影响性能</p>
<ul>
<li>重绘是节点改变外观不改变布局</li>
<li>回流是改变布局了</li>
</ul>
<p>回流必定会发生重绘，回流成本高的多</p>
<h3 id="减少重绘与回流"><a href="#减少重绘与回流" class="headerlink" title="减少重绘与回流"></a>减少重绘与回流</h3><ul>
<li>使用transform代替top</li>
</ul>
<p>就是定位的时候不要用top，用transform直接移动，不会发生回流，他是变形得出的，具体要看原来</p>
<ul>
<li><p>使用visibility代替display，visibility只是不见了还在dom树里面的，不会频繁重新渲染</p>
</li>
<li><p>不要把节点属性值放在一个循环里做变量</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 获取 offsetTop 会导致回流，因为需要去获取正确的值</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">document</span>.querySelector(<span class="string">'.test'</span>).style.offsetTop)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里提一下尝试去获取元素的offsetwidth呀，offsetheight等都回触发回流</p>
<ul>
<li>不要使用table布局，table的小改动都会造成重新布局</li>
<li>动画实现的速度，根据一般的屏幕60fps，可以选择requestAnimationFrame刚刚好</li>
<li>css选择器从右到做匹配查找，节点不要层级过多</li>
<li>对于频繁重绘回流的节点，最好给他单独一个图层，这样他就不会影响其他的节点</li>
</ul>
<p>有一些标签浏览器会自动将他变为图层，可以利用一下</p>
<p>例如：video、iframe标签，will-change属性</p>
<h2 id="如何测量渲染速度"><a href="#如何测量渲染速度" class="headerlink" title="如何测量渲染速度"></a>如何测量渲染速度</h2><p>有一个DOMContentLoaded事件，这个事件是渲染完成后触发的，我们可以看这个事件的发生条件，然后去看书剑</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>vue进阶知识点</title>
    <url>/2020/04/26/%E9%9D%A2%E8%AF%95/yck-vue%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h2 id="响应式原理"><a href="#响应式原理" class="headerlink" title="响应式原理"></a>响应式原理</h2><p>就是数据的动态绑定的叫法</p>
<p>vue2用的defineProperty()</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断类型</span></span><br><span class="line">  <span class="keyword">if</span> (!obj || <span class="keyword">typeof</span> obj !== <span class="string">'object'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Object</span>.keys(obj).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    defineReactive(obj, key, obj[key])</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj, key, val</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 递归子属性</span></span><br><span class="line">  observe(val)</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    <span class="comment">// 可枚举</span></span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 可配置</span></span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 自定义函数</span></span><br><span class="line">    <span class="keyword">get</span>: function reactiveGetter() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'get value'</span>)</span><br><span class="line">      <span class="keyword">return</span> val</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function reactiveSetter(newVal) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'change value'</span>)</span><br><span class="line">      val = newVal</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面是一个封装了一下通过get、set方法动态监听的</p>
<p>来个模板</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    &#123;&#123;name&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>但是我们不可能手动调用方法的嘛，我们希望</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data = &#123; <span class="attr">name</span>: <span class="string">'yck'</span> &#125;</span><br><span class="line">observe(data)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.querySelector(<span class="string">'div'</span>).innerText = value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后半部分才是重点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟解析到 `&#123;&#123;name&#125;&#125;` 触发的操作</span></span><br><span class="line"><span class="keyword">new</span> Watcher(data, <span class="string">'name'</span>, update)</span><br><span class="line"><span class="comment">// update Dom innerText</span></span><br><span class="line">data.name = <span class="string">'yyy'</span></span><br></pre></td></tr></table></figure>

<p>有一个watch类，我们给他data，属性名，更新回调，自动搞定，而且data 跟name可能不止一个</p>
<p>来个操作数组的中间累Dep先</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过 Dep 解耦属性的依赖和更新操作</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.subs = []</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加依赖</span></span><br><span class="line">  addSub(sub) &#123;</span><br><span class="line">    <span class="keyword">this</span>.subs.push(sub)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 更新</span></span><br><span class="line">  notify() &#123;</span><br><span class="line">    <span class="keyword">this</span>.subs.forEach(<span class="function"><span class="params">sub</span> =&gt;</span> &#123;</span><br><span class="line">      sub.update()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 全局属性，通过该属性配置 Watcher</span></span><br><span class="line">Dep.target = <span class="literal">null</span></span><br></pre></td></tr></table></figure>

<p>再来写watch</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(obj, key, cb) &#123;</span><br><span class="line">    <span class="comment">// 将 Dep.target 指向自己</span></span><br><span class="line">    <span class="comment">// 然后触发属性的 getter 添加监听</span></span><br><span class="line">    <span class="comment">// 最后将 Dep.target 置空</span></span><br><span class="line">    Dep.target = <span class="keyword">this</span> <span class="comment">//绑定实例</span></span><br><span class="line">    <span class="keyword">this</span>.cb = cb</span><br><span class="line">    <span class="keyword">this</span>.obj = obj</span><br><span class="line">    <span class="keyword">this</span>.key = key</span><br><span class="line">    <span class="keyword">this</span>.value = obj[key]</span><br><span class="line">    Dep.target = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  update() &#123;</span><br><span class="line">    <span class="comment">// 获得新值</span></span><br><span class="line">    <span class="keyword">this</span>.value = <span class="keyword">this</span>.obj[<span class="keyword">this</span>.key]</span><br><span class="line">    <span class="comment">// 调用 update 方法更新 Dom</span></span><br><span class="line">    <span class="keyword">this</span>.cb(<span class="keyword">this</span>.value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更新上面的defineReactive</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj, key, val</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 递归子属性</span></span><br><span class="line">  observe(val)</span><br><span class="line">  <span class="keyword">let</span> dp = <span class="keyword">new</span> Dep()</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    <span class="keyword">get</span>: function reactiveGetter() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'get value'</span>)</span><br><span class="line">      <span class="comment">// 将 Watcher 添加到订阅</span></span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        dp.addSub(Dep.target)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> val</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function reactiveSetter(newVal) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'change value'</span>)</span><br><span class="line">      val = newVal</span><br><span class="line">      <span class="comment">// 执行 watcher 的 update 方法</span></span><br><span class="line">      dp.notify()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这文章说的不好，要手动敲敲</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>刷面试题1</title>
    <url>/2020/04/20/%E9%9D%A2%E8%AF%95/%E7%9C%8B%E4%B9%A61/</url>
    <content><![CDATA[<p>跟的是这个</p>
<blockquote>
<p><a href="https://mp.weixin.qq.com/s/aywCFgyDhosDvaTBxdh7SA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/aywCFgyDhosDvaTBxdh7SA</a></p>
</blockquote>
<p>每天看几题题，查漏补缺</p>
<h3 id="es5实现let"><a href="#es5实现let" class="headerlink" title="es5实现let"></a>es5实现let</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> i =&gt; <span class="keyword">var</span> _i</span><br></pre></td></tr></table></figure>

<p>将变量名转换来达到块级作用域的效果，为什么可以这样呢</p>
<p>一般来说下划线是我们对私有变量的约定俗成的写法，实际上行不行呢</p>
<p>测试</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> _i = <span class="number">0</span>;_i&lt;=<span class="number">10</span>;_i++) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(_i) <span class="comment">// 11</span></span><br></pre></td></tr></table></figure>

<p>事实证明这只是约定俗成的写法</p>
<p>我们可以用自执行函数来模拟</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)  <span class="comment">// 0 1 2 3 4</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(i)      <span class="comment">// Uncaught ReferenceError: i is not defined</span></span><br></pre></td></tr></table></figure>

<p>就是将变量包裹在立即执行函数里面了嘛</p>
<h2 id="es5实现const"><a href="#es5实现const" class="headerlink" title="es5实现const"></a>es5实现const</h2><p>关键在于这个api</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(obj,prop,desc)</span><br><span class="line">obj:要在上面定义的属性的对象</span><br><span class="line">prop:要定义或修改的属性的名称</span><br><span class="line">descriptor:将被定义或修改的属性描述符</span><br></pre></td></tr></table></figure>

<p>vue监听变量用的也是这个，那么我们怎么做呢，我们可以定义writable属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// writable属性</span></span><br><span class="line"><span class="comment">// 类属性描述符，用来描述对象的属性的</span></span><br><span class="line"><span class="comment">// writable属性就是可写的意思</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_const</span>(<span class="params">key, value</span>) </span>&#123;    </span><br><span class="line">    <span class="keyword">const</span> desc = &#123;        </span><br><span class="line">        value,        </span><br><span class="line">        writable: <span class="literal">false</span>    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(<span class="built_in">window</span>, key, desc)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_const(<span class="string">'obj'</span>, &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;)   <span class="comment">//定义obj</span></span><br><span class="line">obj.b = <span class="number">2</span>               <span class="comment">//可以正常给obj的属性赋值</span></span><br><span class="line">obj = &#123;&#125;                <span class="comment">//抛出错误，提示对象read-only</span></span><br></pre></td></tr></table></figure>

<h2 id="手写call"><a href="#手写call" class="headerlink" title="手写call"></a>手写call</h2><p>先来看call方法是啥</p>
<p>就是指定一个this值和单独给出的一个或多个参数一起调用一个函数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用add方法替换sub方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a+b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sub</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a-b)</span><br><span class="line"> &#125;</span><br><span class="line"> add.call(sub,<span class="number">3</span>,<span class="number">1</span>) <span class="comment">//4</span></span><br><span class="line"><span class="comment">// 这里是用add方法替换了sub方法了</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>)</span>&#123;    </span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">"Animal"</span>;    </span><br><span class="line">    <span class="keyword">this</span>.showName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;    </span><br><span class="line">        alert(<span class="keyword">this</span>.name);    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;    </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params"></span>)</span>&#123;    </span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">"Cat"</span>;    </span><br><span class="line">&#125;    </span><br><span class="line">   </span><br><span class="line"><span class="keyword">var</span> animal = <span class="keyword">new</span> Animal();    </span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat();    </span><br><span class="line">    </span><br><span class="line"><span class="comment">//通过call或apply方法，将原本属于Animal对象的showName()方法交给对象cat来使用了。    </span></span><br><span class="line"><span class="comment">//输入结果为"Cat"    </span></span><br><span class="line">animal.showName.call(cat,<span class="string">","</span>);</span><br><span class="line">animal.showName.call(cat);</span><br><span class="line"><span class="comment">//animal.showName.apply(cat,[]);</span></span><br></pre></td></tr></table></figure>

<p>怎么实现呢，这里其实是一个this的玩法，将函数的this指向变为他的直接调用者，就是变更调用者</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 变更调用者</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    name:<span class="string">'写代码想蔡徐坤'</span></span><br><span class="line">&#125;</span><br><span class="line">obj.foo = foo <span class="comment">// 变更foo的调用者</span></span><br><span class="line">obj.foo() <span class="comment">// '写代码像蔡徐坤'</span></span><br></pre></td></tr></table></figure>

<p>真正实现</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span>(<span class="params">thisArg, ...args</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'error'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> fn = <span class="built_in">Symbol</span>(<span class="string">'fn'</span>)        <span class="comment">// 声明一个独有的Symbol属性, 防止fn覆盖已有属性</span></span><br><span class="line">    thisArg = thisArg || <span class="built_in">window</span>    <span class="comment">// 若没有传入this, 默认绑定window对象</span></span><br><span class="line">    thisArg[fn] = <span class="keyword">this</span>              <span class="comment">// this指向调用call的对象,即我们要改变this指向的函数</span></span><br><span class="line">    <span class="keyword">const</span> result = thisArg[fn](...args)  <span class="comment">// 执行当前函数</span></span><br><span class="line">    <span class="keyword">delete</span> thisArg[fn]              <span class="comment">// 删除我们声明的fn属性</span></span><br><span class="line">    <span class="keyword">return</span> result                  <span class="comment">// 返回函数执行结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="手写apply"><a href="#手写apply" class="headerlink" title="手写apply"></a>手写apply</h2><p>apply跟call类似，但是apply收参数用数组收，call接受很多参数</p>
<p>所以用上面的call方法修改即可</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span>(<span class="params">thisArg, args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'error'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> fn = <span class="built_in">Symbol</span>(<span class="string">'fn'</span>)        <span class="comment">// 声明一个独有的Symbol属性, 防止fn覆盖已有属性</span></span><br><span class="line">    thisArg = thisArg || <span class="built_in">window</span>    <span class="comment">// 若没有传入this, 默认绑定window对象</span></span><br><span class="line">    thisArg[fn] = <span class="keyword">this</span>              <span class="comment">// this指向调用call的对象,即我们要改变this指向的函数</span></span><br><span class="line">    <span class="keyword">const</span> result = thisArg[fn](...args)  <span class="comment">// 执行当前函数</span></span><br><span class="line">    <span class="keyword">delete</span> thisArg[fn]              <span class="comment">// 删除我们声明的fn属性</span></span><br><span class="line">    <span class="keyword">return</span> result                  <span class="comment">// 返回函数执行结果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line">foo.myApply(obj, [])     <span class="comment">// 输出'写代码像蔡徐抻'</span></span><br></pre></td></tr></table></figure>

<p>可以看到就进来的参数形式不一样，这里是…args方法帮忙了</p>
<h2 id="手写bind"><a href="#手写bind" class="headerlink" title="手写bind"></a>手写bind</h2><p>bind方法创建一个新函数，如果bind被调用，这个新函数的this被指定为bind的第一个参数，其余参数作为新函数的参数供调用时使用</p>
<p>理论上只要在apply或者call外面包一层</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span>(<span class="params">thisArg, ...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.apply(thisArg, args)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>他自己myBind是个函数，只是第一个的方法，返回结果，看起来很完美，然而</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 除了this还接受其他参数，bind返回的函数也要接受参数</span></span><br><span class="line"><span class="comment">// new的优先级被绑定的函数，如果new了被绑定函数，this指向发生改变，此时this就只是实例了</span></span><br><span class="line"><span class="comment">// 没有保留原函数原型链上的属性与方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改后</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span> (<span class="params">thisArg, ...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">"function"</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">TypeError</span>(<span class="string">"Bind must be called on a function"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span></span><br><span class="line">    <span class="comment">// new优先级</span></span><br><span class="line">    <span class="keyword">var</span> fbound = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        self.apply(<span class="keyword">this</span> <span class="keyword">instanceof</span> self ? <span class="keyword">this</span> : thisArg, args.concat(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 继承原型上的属性和方法</span></span><br><span class="line">    fbound.prototype = <span class="built_in">Object</span>.create(self.prototype);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fbound;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">'写代码像蔡徐抻'</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.myBind(obj, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>)()    <span class="comment">//输出写代码像蔡徐抻 ['a', 'b', 'c']</span></span><br></pre></td></tr></table></figure>

<p>注意，new优先级那里，意思是如果函数被new了，这个时候的this就不是指向这个函数了，此时是指向函数new出来的实例，那么我们看代码</p>
<p>this instanceof self，true就是我是你的实例，应该指向实例，false就是不是，指向函数</p>
<p>然后args.concat(Array.prototype.slice.call(arguments))是传递参数的</p>
<ul>
<li>防抖函数</li>
</ul>
<p>老问题，什么是防抖，就是短时间内大量触发同一事件，但是只会执行一次事件，就是防止事件疯狂触发</p>
<p>我们设置一个定时器，在xx毫秒后再触发事件，每次触发都会重新设置定时器，然后直到xx毫秒内无第二次操作</p>
<p>这个可以认真搞搞，是为了性能</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func,wait</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">let</span> timeout = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="keyword">this</span> </span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">arguments</span> <span class="comment">// 拿参数</span></span><br><span class="line">        <span class="keyword">if</span> (timeout) clearTimeout(timeout)</span><br><span class="line">        timeout = setTimeout(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">            func.apply(context,args)</span><br><span class="line">        &#125;,wait)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="节流函数"><a href="#节流函数" class="headerlink" title="节流函数"></a>节流函数</h2><p>节流是间隔执行，每隔一段时间久执行一次，设置一个定时器，每xx毫秒就执行时间，如果时间到了，就重置计时器</p>
<p>防抖是每次触发事件重置定时器，节流是在定时器到时间后清空定时器</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func,wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timeout = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="keyword">this</span></span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">arguments</span></span><br><span class="line">        <span class="keyword">if</span> (!timeout) &#123;</span><br><span class="line">            timeout = setTimeout( <span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">                timeout = <span class="literal">null</span> <span class="comment">// 关键之重置timeout</span></span><br><span class="line">                func.apply(context,args)</span><br><span class="line">            &#125;,wait)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种实现思路，用两个时间戳，一新一旧，每次触发判断两者的时间</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> prev = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> now = <span class="built_in">Date</span>.now();</span><br><span class="line">        <span class="keyword">let</span> context = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span> (now - prev &gt; wait) &#123;</span><br><span class="line">            func.apply(context, args);</span><br><span class="line">            prev = now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a>数组扁平化</h2><p>扁平化值得是将[1,[1,2],[1,2,3]]拍扁为[1,1,2,1,2,3]</p>
<p>有几种方法可以呢</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// es6的flat</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, [<span class="number">1</span>,<span class="number">2</span>], [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line">arr.flat(<span class="literal">Infinity</span>)  <span class="comment">// [1, 1, 2, 1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 序列化后正则，其实就是删除方括号</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, [<span class="number">1</span>,<span class="number">2</span>], [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line"><span class="keyword">const</span> str = <span class="string">`[<span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(arr).replace(<span class="regexp">/(\[|\])/g</span>, <span class="string">''</span>)&#125;</span>]`</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(str)   <span class="comment">// [1, 1, 2, 1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, [<span class="number">1</span>,<span class="number">2</span>], [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flat</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">      <span class="comment">// 递归调用</span></span><br><span class="line">    item <span class="keyword">instanceof</span> <span class="built_in">Array</span> ? result = result.concat(flat(item)) : result.push(item)</span><br><span class="line">  &#125; <span class="comment">// concat 连接数组</span></span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line">flat(arr) <span class="comment">// [1, 1, 2, 1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代加展开运算符</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, [<span class="number">1</span>,<span class="number">2</span>], [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line"><span class="keyword">while</span> (arr.some(<span class="built_in">Array</span>.isArray)) &#123;</span><br><span class="line">  arr = [].concat(...arr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...运算符，就是展开参数</span></span><br><span class="line"><span class="comment">// 这里就是[].concat(1,[1,2],[1,2,3])</span></span><br><span class="line"><span class="comment">// 就把所有的连接起来啦</span></span><br><span class="line"><span class="built_in">console</span>.log(arr)  <span class="comment">// [1, 1, 2, 1, 2, 3]</span></span><br><span class="line"><span class="comment">// 检测数组中的元素是否满足指定条件,是就返回true，否则false</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>刷面试题2</title>
    <url>/2020/04/22/%E9%9D%A2%E8%AF%95/%E7%9C%8B%E4%B9%A62/</url>
    <content><![CDATA[<h2 id="手写promise"><a href="#手写promise" class="headerlink" title="手写promise"></a>手写promise</h2><p>填坑后补</p>
<h2 id="原型链知识点"><a href="#原型链知识点" class="headerlink" title="原型链知识点"></a>原型链知识点</h2><ul>
<li>每个对象都有_proto_属性，属性指向原型对象， 调用实例的方法和属性的时候，如果实力对象上找不到，就会往原型对象上找</li>
<li>构造函数的prototype属性也指向实例的原型对象</li>
<li>原型对象的constructor指向构造函数</li>
</ul>
<h2 id="手写new"><a href="#手写new" class="headerlink" title="手写new"></a>手写new</h2><p>首先要知道new做了啥</p>
<ul>
<li>创建一个新对象，并继承其构造函数的prototype，这一步拿到了原型</li>
<li>执行构造函数，方法内的this被指定为该新实例，这一步执行构造函数内的赋值操作</li>
<li>返回新实例</li>
</ul>
<p>来人上代码</p>
<p><img src="https://s1.ax1x.com/2020/04/22/Jt90RU.jpg" alt="Jt90RU.jpg"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// new是关键字,这里我们用函数来模拟,new Foo(args) &lt;=&gt; myNew(Foo, args)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNew</span>(<span class="params">foo, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建新对象,并继承构造方法的prototype属性, 这一步是为了把obj挂原型链上, 相当于obj.__proto__ = Foo.prototype</span></span><br><span class="line">  <span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(foo.prototype)  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行构造方法, 并为其绑定新this, 这一步是为了让构造方法能进行this.name = name之类的操作, args是构造方法的入参, 因为这里用myNew模拟, 所以入参从myNew传入</span></span><br><span class="line">  <span class="keyword">let</span> result = foo.apply(obj, args)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果构造方法已经return了一个对象, 那么就返回该对象, 一般情况下，构造方法不会返回新实例，但使用者可以选择返回新实例来覆盖new创建的对象 否则返回myNew创建的新对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> result === <span class="string">'object'</span> &amp;&amp; result !== <span class="literal">null</span> ? result : obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> newObj = myNew(Foo, <span class="string">'zhangsan'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(newObj)                 <span class="comment">// Foo &#123;name: "zhangsan"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(newObj <span class="keyword">instanceof</span> Foo)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="es5的继承"><a href="#es5的继承" class="headerlink" title="es5的继承"></a>es5的继承</h2><h3 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'写代码像蔡徐抻'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 父类的原型方法</span></span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 让子类的原型对象指向父类实例, 这样一来在Child实例中找不到的属性和方法就会到原型对象(父类实例)上寻找</span></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent()</span><br><span class="line">Child.prototype.constructor = Child <span class="comment">// 根据原型链的规则,顺便绑定一下constructor, 这一步不影响继承, 只是在用到constructor时会需要</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后Child实例就能访问到父类及其原型上的name属性和getName()方法</span></span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> Child()</span><br><span class="line">child.name          <span class="comment">// '写代码像蔡徐抻'</span></span><br><span class="line">child.getName()     <span class="comment">// '写代码像蔡徐抻'</span></span><br></pre></td></tr></table></figure>

<p>但是所有的child原型其实都指向了同一个parent，所以他们之间改动原型会互相影响</p>
<p>创建子实例的时候无法向父类传参数的，所以是拿不到父类的构造函数的</p>
<h3 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a>构造函数继承</h3><p>在子类的构造函数执行父类的构造函数，将他绑定到子类的this上面，然后把父类的成员属性与方法都挂到子类的this上，这样可以避免实例之间共享一个原型实例，又能向父类构造方法传参</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = [name]</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="keyword">this</span>, <span class="string">'zhangsan'</span>)   <span class="comment">// 执行父类构造方法并绑定子类的this, 使得父类中的属性能够赋到子类的this上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是但是，这个不是真正的继承，等于复制搬过来了，而且他拿不到除构造函数外面的属性与方法了</p>
<h3 id="组合式继承"><a href="#组合式继承" class="headerlink" title="组合式继承"></a>组合式继承</h3><p>结合上面两个使用嘛，无敌</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = [name]</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 构造函数继承</span></span><br><span class="line">    Parent.call(<span class="keyword">this</span>, <span class="string">'zhangsan'</span>) </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原型链继承</span></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent()</span><br><span class="line">Child.prototype.constructor = Child</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="keyword">const</span> child1 = <span class="keyword">new</span> Child()</span><br><span class="line"><span class="keyword">const</span> child2 = <span class="keyword">new</span> Child()</span><br><span class="line">child1.name[<span class="number">0</span>] = <span class="string">'foo'</span></span><br><span class="line"><span class="built_in">console</span>.log(child1.name)          <span class="comment">// ['foo']</span></span><br><span class="line"><span class="built_in">console</span>.log(child2.name)          <span class="comment">// ['zhangsan']</span></span><br><span class="line">child2.getName()                  <span class="comment">// ['zhangsan']</span></span><br></pre></td></tr></table></figure>

<p>还要挑缺点的话就是每次都执行了两次构造函数（后面new了一个），创建实例的时候，原型中也会有两个相同的属性与方法</p>
<p>就是构造函数中的属性与方法可能与原型中的一样导致重复</p>
<h3 id="寄生式组合继承"><a href="#寄生式组合继承" class="headerlink" title="寄生式组合继承"></a>寄生式组合继承</h3><p>首先解决构造函数执行两次的问题，将指向父实例改为指向父原型，这样不会执行多一个new</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Child.prototype = Parent.prototype  <span class="comment">//将`指向父类实例`改为`指向父类原型`</span></span><br></pre></td></tr></table></figure>

<p>但是他们都指向一个原型对象了，万恶的js直接引用类型赋值了</p>
<p>所以我们要浅拷贝一下</p>
<p>浅拷贝指的是如果他是对象套对象是无解的，但是单层还是可以的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Child.prototype = <span class="built_in">Object</span>.create(Parent.prototype)</span><br></pre></td></tr></table></figure>

<p>这是目前最成熟的继承方法</p>
<h2 id="V8引擎相关"><a href="#V8引擎相关" class="headerlink" title="V8引擎相关"></a>V8引擎相关</h2><p>这个我之前没看过，认真看看</p>
<h3 id="V8如何执行一段js代码"><a href="#V8如何执行一段js代码" class="headerlink" title="V8如何执行一段js代码"></a>V8如何执行一段js代码</h3><ul>
<li>预解析：检查语法错误，但不生成AST</li>
<li>生成AST：经过词法/语法分析，生成抽象语法树</li>
<li>生成字节码：基线编译器，将AST转换为字节码</li>
<li>生成机器码：优化编译器将字节码转化为机器码，执行字节码的时候，如果发现一个字节码经常执行，会生成机器码，优化执行速度</li>
</ul>
<p>这个只是普通的，详细的看</p>
<p>占坑</p>
<h3 id="引用计数与标记清除"><a href="#引用计数与标记清除" class="headerlink" title="引用计数与标记清除"></a>引用计数与标记清除</h3><ul>
<li>引用计数：给一个变量赋值引用类型，这个对象的引用次数就会+1，如果引用他的一个变量变成了其他值，那么该对象的引用次数就会-1，垃圾回收器会回收引用次数为0的对象，但是当对象循环引用时，会导致次数永远无法为0，内存就无法释放了</li>
<li>标记清除：垃圾收集器给内存中的所有对象都加上标记，然后从根节点开始遍历，去掉被要用的对象和运行环境中对象的标记，剩下的被标记的对象就是无法访问等待回收的对象</li>
</ul>
<p>理解一下这个标记清除，就是选出要被回收的对象，然后回收</p>
<h3 id="V8如何进行垃圾回收"><a href="#V8如何进行垃圾回收" class="headerlink" title="V8如何进行垃圾回收"></a>V8如何进行垃圾回收</h3><p>首先V8对变量的存储主要有两个位置，栈内存和堆内存，栈内存放基本数据类型与引用数据类型的内存地址，堆内存放引用数据类型的数据</p>
<h4 id="栈内存的回收"><a href="#栈内存的回收" class="headerlink" title="栈内存的回收"></a>栈内存的回收</h4><p>上下文环境切换后就回收</p>
<h4 id="堆内存的回收"><a href="#堆内存的回收" class="headerlink" title="堆内存的回收"></a>堆内存的回收</h4><p>V8的堆内存分为新生代内存与老生代内存，新生代内存是临时分配的内存，存在时间段，老生代内存存在时间长</p>
<ul>
<li>新生代内存</li>
</ul>
<p>内存小，64为系统下仅有32M，分为From、To两部分，进行垃圾回收时，先扫描From，将非存活对象回收，将存活对象顺序复制到To中，之后调换，等待下一次回收</p>
<ul>
<li>老生代内存回收机制<ul>
<li>晋升：如果新生代的变量经过多次回收依然存在，那么就会放入老生代内存中</li>
<li>标记清除：老生代内存会先遍历所有对象并打上标记，然后对正在使用或这强引用的对象取消标记，回收被标记的对象</li>
<li>整理内存碎片：把对象挪到内存的一端</li>
</ul>
</li>
</ul>
<h3 id="js为什么这么慢，V8做了什么优化"><a href="#js为什么这么慢，V8做了什么优化" class="headerlink" title="js为什么这么慢，V8做了什么优化"></a>js为什么这么慢，V8做了什么优化</h3><h4 id="js的问题"><a href="#js的问题" class="headerlink" title="js的问题"></a>js的问题</h4><p>动态类型：每次存取属性都要检查类型，而且动态类型很难再编译的时候进行优化</p>
<p>属性存取：c++/java等语言的语法，属性是存在数组中的，数组位移就可以获取，而js是放在对象中的，每次获取都要进行哈希查询</p>
<h4 id="V8的优化"><a href="#V8的优化" class="headerlink" title="V8的优化"></a>V8的优化</h4><p>优化JIT：js原生是一边解释一遍执行，效率低，V8对重复执行得代码会转为机器码缓存下来，下次运行时直接使用机器码</p>
<p>隐藏类：优化属性存取，借用类和偏移位置的思想，将对象划分为不同的组，隐藏类</p>
<p>内嵌缓存：即缓存对象查询的结果，不用重复查询</p>
<p>垃圾回收管理：上面说的</p>
<h3 id="浏览器渲染机制"><a href="#浏览器渲染机制" class="headerlink" title="浏览器渲染机制"></a>浏览器渲染机制</h3>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>手写时间处理器</title>
    <url>/2020/04/23/%E9%9D%A2%E8%AF%95/%E6%89%8B%E5%86%99%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E5%99%A8/</url>
    <content><![CDATA[<p>事情的起因是群主去网络面试，然后拉我们共享题目，我屁颠屁颠就去了</p>
<p>为保护群主，题目手写吧</p>
<p>大意就是手写一个事件处理器,要有送几个方法</p>
<ul>
<li>on绑定事件两个参数（name,callback）</li>
<li>取消绑定off，参数name</li>
<li>触发事件trigger，参数name，data</li>
</ul>
<p>如果是我一看打扰了，不会，告辞</p>
<p><img src="https://s1.ax1x.com/2020/04/23/JdY6Wn.jpg" alt="JdY6Wn.jpg"></p>
<p>我们来看看海螺大佬的答案</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span> () &#123;</span><br><span class="line">        <span class="keyword">super</span>()</span><br><span class="line">        <span class="keyword">this</span>.listeners = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    on (name,callback) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> callback === <span class="string">'function'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.listeners[name]) &#123;</span><br><span class="line">                <span class="keyword">this</span>.listeners[name].push(callback)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.listeners[name] = [callback]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.error(<span class="string">'回调函数必须是function类型！'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    off (name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.listeners[name] = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    trigger(name,data) &#123;</span><br><span class="line">        <span class="keyword">let</span> array</span><br><span class="line">        <span class="keyword">if</span> (array = <span class="keyword">this</span>.listeners[name]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>;i &lt; array.length;i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    array[i](data)</span><br><span class="line">                &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">                    <span class="built_in">console</span>.error(<span class="string">'函数'</span>+array[i]+<span class="string">'运行时出错！'</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>理解一下</p>
<p>思路还是清晰简单的</p>
<p>看看群主的写法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>()</span><br><span class="line">        <span class="keyword">this</span>.event = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    on (name,cb) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!name || !cb) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.event[name] = <span class="keyword">this</span>.event[name] || []</span><br><span class="line">        <span class="keyword">this</span>.event[name].push(cb)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    off (name) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!name) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">this</span>.event[name]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    trigger(name,data) &#123;</span><br><span class="line">        <span class="keyword">let</span> fns = <span class="keyword">this</span>.event[name]</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(fns)) &#123;</span><br><span class="line">            fns.forEach(<span class="function">(<span class="params">fn</span>) =&gt;</span> &#123;</span><br><span class="line">                fn(data)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>起手es6，姜还是老的辣，精彩精彩</p>
<p>其实思路就是用一个对象，key是名字，vlaue是事件数组，来处理事件，这道题看似简单，还是考基本功的，就这样吧，不写了，懒,看就懂了</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>刷面试题3</title>
    <url>/2020/04/23/%E9%9D%A2%E8%AF%95/%E7%9C%8B%E4%B9%A63/</url>
    <content><![CDATA[<h2 id="浏览器渲染机制"><a href="#浏览器渲染机制" class="headerlink" title="浏览器渲染机制"></a>浏览器渲染机制</h2><p>我又来了，加油奥利给</p>
<p><img src="https://s1.ax1x.com/2020/04/23/JaUBHU.jpg" alt="JaUBHU.jpg"></p>
<h3 id="浏览器的渲染过程"><a href="#浏览器的渲染过程" class="headerlink" title="浏览器的渲染过程"></a>浏览器的渲染过程</h3><ul>
<li>HTML和CSS经过各自解析，生成DOM树和CSSOM树</li>
<li>合并成渲染树</li>
<li>根据渲染树进行布局</li>
<li>最后调用GPU进行绘制，显示在屏幕上</li>
</ul>
<h3 id="如何加快浏览器渲染首屏速度"><a href="#如何加快浏览器渲染首屏速度" class="headerlink" title="如何加快浏览器渲染首屏速度"></a>如何加快浏览器渲染首屏速度</h3><ul>
<li>优化文件大小：HTML和CSS的加载和解析都会阻塞渲染树的生成，从而影响首屏的速度，要优化文件的大小，k可以加快</li>
<li>避免资源下载阻塞文档解析，最好异步解析哦，如果没有依赖关系的话</li>
</ul>
<h3 id="什么是回流，怎么触发"><a href="#什么是回流，怎么触发" class="headerlink" title="什么是回流，怎么触发"></a>什么是回流，怎么触发</h3><ul>
<li>当元素的尺寸或位置发生变化，需要重新计算渲染树，这就是回流</li>
<li>DOM元素的几何属性发生变化时会触发回流</li>
<li>DOM元素移动或增加会触发回流</li>
<li>读写offset、scroll、client等属性会触发回流</li>
<li>调用window.getComputeStyle会触发回流</li>
</ul>
<h3 id="什么是重绘，什么情况下会触发重绘"><a href="#什么是重绘，什么情况下会触发重绘" class="headerlink" title="什么是重绘，什么情况下会触发重绘"></a>什么是重绘，什么情况下会触发重绘</h3><p>DOM样式发生变化，但是没用影响DOM的集合属性时，就会触发重绘，而不会触发回流，就是他布局不用变，所以性能比回流好，但是还是要重画的</p>
<h3 id="什么事GPU加速，如何用，啥缺点"><a href="#什么事GPU加速，如何用，啥缺点" class="headerlink" title="什么事GPU加速，如何用，啥缺点"></a>什么事GPU加速，如何用，啥缺点</h3><p>优点：使用某一些css属性的时候，例如transform、opacity、filters等属性的时候，会直接在GPU中完成处理，那么这些属性的变化不会引发回流，加快速度</p>
<p>缺点：GPU渲染会导致字体模糊，过多的GPU处理也会浪费内存</p>
<h3 id="如何减少回流"><a href="#如何减少回流" class="headerlink" title="如何减少回流"></a>如何减少回流</h3><ul>
<li>用class，别用style</li>
<li>使用resize、scroll时要进行防抖与节流处理，这两者会直接导致回流</li>
<li>使用visiblity代替display：none，前者会重绘，但是后者回流拉</li>
<li>批量修改元素时，先上元素脱离文档流，修改完毕再放入文档流，不然修改一个他就渲染一遍</li>
<li>避免触发同步布局事件，例如在获取offsetWidth这类布局属性时，可以使用变量将查询结果存起来，避免多次查询，因为每次查询都会触发回流</li>
<li>对于复杂动画效果，使用绝对定位让他脱离文档流，复杂的动画效果会频繁地出发回流重绘，将动画设置绝对定位脱离文档流避免反复回流重绘</li>
</ul>
<h2 id="浏览器缓存策略"><a href="#浏览器缓存策略" class="headerlink" title="浏览器缓存策略"></a>浏览器缓存策略</h2><h3 id="浏览器缓存位置与优先级"><a href="#浏览器缓存位置与优先级" class="headerlink" title="浏览器缓存位置与优先级"></a>浏览器缓存位置与优先级</h3><ul>
<li>service Worker</li>
<li>Memory Cache(内存缓存)</li>
<li>Disk Cache(硬盘缓存)</li>
<li>Push Cache(推送混存)</li>
<li>以上都找不到，浏览器会进行网络请求</li>
</ul>
<h3 id="不同缓存之间的差别"><a href="#不同缓存之间的差别" class="headerlink" title="不同缓存之间的差别"></a>不同缓存之间的差别</h3><ul>
<li>service Worker</li>
</ul>
<p>与Web Worker类似，是一个独立的线程，在这个线程中缓存文件，在主线程需要的时候读取这里的文件，缓存是持续性的</p>
<ul>
<li>Memory Cache</li>
</ul>
<p>内存缓存，不是持续的，可能会被释放，没了</p>
<ul>
<li>Disk Cache</li>
</ul>
<p>硬盘缓存，是持续性，且容量更大的，当然速度慢啦</p>
<ul>
<li>push Cache</li>
</ul>
<p>推送缓存，HTTP/2的内容，目前用的少</p>
<h3 id="浏览器缓存策略-1"><a href="#浏览器缓存策略-1" class="headerlink" title="浏览器缓存策略"></a>浏览器缓存策略</h3><h4 id="强缓存，不需要问服务器的"><a href="#强缓存，不需要问服务器的" class="headerlink" title="强缓存，不需要问服务器的"></a>强缓存，不需要问服务器的</h4><ul>
<li>设计Expries：设置过期时间，要求本地日期与服务器日期一致，不然会时间错误</li>
<li>设置Cache-Control：通过max-age字段设置过期时间</li>
</ul>
<h4 id="协商缓存，需要向服务器问是否已经过期"><a href="#协商缓存，需要向服务器问是否已经过期" class="headerlink" title="协商缓存，需要向服务器问是否已经过期"></a>协商缓存，需要向服务器问是否已经过期</h4><ul>
<li>Last-Modified：浏览器第一次请求资源的时候，会在响应头上面加上Last-Modified，当浏览器再次请求的时候，在请求头上面加上If-Modified-Since字段，服务器对象两个时间，相同就返回304否则返回新资源，并更新Last-Modified</li>
<li>ETag：文件唯一标识，只要文件内容改动，ETag就会重新计算，流程与上面一样，服务器发送ETag字段，浏览器再次请求时发送If-None-Match，如果值不匹配，说明文件已经改变，返回新资源并更新ETag，匹配就返回304</li>
</ul>
<p>对比：</p>
<ul>
<li>ETag准一点，并且Last的时间单位为一秒，如果一秒内修改了完，是不会分辨出是否为缓存的</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>群主的一份题</title>
    <url>/2020/04/24/%E9%9D%A2%E8%AF%95/%E7%BE%A4%E4%B8%BB%E7%9A%84%E4%B8%80%E4%BB%BD%E9%A2%98/</url>
    <content><![CDATA[<p>题目：</p>
<ul>
<li><p>使用冒泡排序算法将数组var a = [B,A,E,C,D];排序为var a=[A,B,C,D,E];</p>
<p>请使用javascript写出全过程。</p>
</li>
<li><p>补全以下css，使他可以如图</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"out"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"leftCircle circle"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"rightCircle circle"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（注： .out处于body的中央（水平垂直居中）, .circle宽高皆为100px）</p>
<p><img src="https://s1.ax1x.com/2020/04/24/JBi2vR.png" alt="JBi2vR.png"></p>
<ul>
<li>请写出从“在浏览器输入域名”到“页面静态资源完全加载”的整个流程</li>
</ul>
<p>下面开始操作</p>
<h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p>排序一定要搞会呀，目前的我，白给</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function bubbleSort(array) &#123;</span><br><span class="line">     for (let j &#x3D; 0; j &lt; array.length; j++) &#123;</span><br><span class="line">       let complete &#x3D; true;</span><br><span class="line">       for (let i &#x3D; 0; i &lt; array.length - 1 - j; i++) &#123;</span><br><span class="line">         &#x2F;&#x2F; 比较相邻数</span><br><span class="line">         if (array[i] &gt; array[i + 1]) &#123;</span><br><span class="line">           [array[i], array[i + 1]] &#x3D; [array[i + 1], array[i]];</span><br><span class="line">           complete &#x3D; false;</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       &#x2F;&#x2F; 没有冒泡结束循环</span><br><span class="line">       if (complete) &#123;</span><br><span class="line">         break;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     return array;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><p>这个可以理解为这样</p>
<p><img src="https://s1.ax1x.com/2020/04/24/JBAeCF.png" alt="JBAeCF.png"></p>
<p>外面的out在外面方框居中，两个圆顶格子,观察圆心,得出为宽高150px的正方形，圆心坐标如果定义左上为零点，那么就是50，50、100,100</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"out"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"leftCircle circle"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"rightCircle circle"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.out</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">position</span><span class="selector-pseudo">:relative</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.circle</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">border</span><span class="selector-pseudo">:1px</span> <span class="selector-tag">solid</span> <span class="selector-tag">balck</span>;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">border-radius</span><span class="selector-pseudo">:50</span>%;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">width</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">height</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">positon</span><span class="selector-pseudo">:absolute</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.leftCircle</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">top</span><span class="selector-pseudo">:0</span>;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">left</span><span class="selector-pseudo">:0</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.rifhtCircle</span> &#123;</span></span><br><span class="line"><span class="css">         <span class="selector-tag">bottom</span><span class="selector-pseudo">:0</span>;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">right</span><span class="selector-pseudo">:0</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="3"><a href="#3" class="headerlink" title="3"></a>3</h2><p>这个嘛，打扰了，告辞</p>
<p>复制群主的答案过来理解</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 用户输入</span><br><span class="line"></span><br><span class="line">   当用户输入关键字并键入回车之后，这意味着当前页面即将要被替换成新的页面，不过在这个流程继续之前，浏览器还给了当前页面一次执行 beforeunload 事件的机会，beforeunload 事件允许页面在退出之前执行一些数据清理操作，还可以询问用户是否要离开当前页面。</span><br><span class="line"></span><br><span class="line">2. URL 请求过程</span><br><span class="line"></span><br><span class="line">   首先，网络进程会查找本地缓存是否缓存了该资源。</span><br><span class="line"></span><br><span class="line">   如果有缓存资源，那么直接返回资源给浏览器进程；如果在缓存中没有查找到资源，那么直接进入网络请求流程。这请求前的第一步是要进行 DNS 解析，以获取请求域名的服务器 IP 地址。如果请求协议是 HTTPS，那么还需要建立 TLS 连接。</span><br><span class="line"></span><br><span class="line">   * 其中，DNS也有几步缓存：浏览器缓存，hosts文件，</span><br><span class="line">   * 如果本地域名解析服务器也没有该域名的记录，则开始递归+迭代解析</span><br><span class="line">   * TCP三次握手，HTTP。TLS握手，HTTPS。</span><br><span class="line"></span><br><span class="line">   接下来就是利用 IP 地址和服务器建立 TCP 连接。连接建立之后，浏览器端会构建请求行、请求头等信息，并把和该域名相关的 Cookie 等数据附加到请求头中，然后向服务器发送构建的请求信息。</span><br><span class="line"></span><br><span class="line">   数据在进入服务端之前，可能还会先经过负责负载均衡的服务器，它的作用就是将请求合理的分发到多台服务器上，这时假设服务端会响应一个 HTML 文件。</span><br><span class="line"></span><br><span class="line">   首先浏览器会判断状态码是什么，如果是 200 那就继续解析，如果 400 或 500 的话就会报错，如果 300 的话会进行重定向，这里会有个重定向计数器，避免过多次的重定向，超过次数也会报错。</span><br><span class="line"></span><br><span class="line">   浏览器开始解析文件，如果是 gzip 格式的话会先解压一下，然后通过文件的编码格式知道该如何去解码文件。</span><br><span class="line"></span><br><span class="line">3. 准备渲染进程</span><br><span class="line"></span><br><span class="line">   默认情况下，Chrome 会为每个页面分配一个渲染进程，也就是说，每打开一个新页面就会配套创建一个新的渲染进程。</span><br><span class="line"></span><br><span class="line">4. 渲染阶段</span><br><span class="line"></span><br><span class="line">   文件解码成功后会正式开始渲染流程，先会根据 HTML 构建 DOM 树，有 CSS 的话会去构建 CSSOM 树。如果遇到 script 标签的话，会判断是否存在 async 或者 defer ，前者会并行进行下载并执行 JS，后者会先下载文件，然后等待 HTML 解析完成后顺序执行。</span><br><span class="line"></span><br><span class="line">   如果以上都没有，就会阻塞住渲染流程直到 JS 执行完毕。</span><br><span class="line"></span><br><span class="line">   CSSOM 树和 DOM 树构建完成后会开始生成 Render 树，这一步就是确定页面元素的布局、样式等等诸多方面的东西</span><br><span class="line"></span><br><span class="line">   在生成 Render 树的过程中，浏览器就开始调用 GPU 绘制，合成图层，将内容显示在屏幕上了。</span><br></pre></td></tr></table></figure>

<p>思维导图整理</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>面试中手写代码</title>
    <url>/2020/04/06/%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E4%B8%AD%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<blockquote>
<p>来源：<a href="https://juejin.im/post/5e57048b6fb9a07cc845a9ef" target="_blank" rel="noopener">https://juejin.im/post/5e57048b6fb9a07cc845a9ef</a></p>
</blockquote>
<p>就是当面试的时候叫你手写代码，你要注意的注意事项</p>
<h3 id="起名字与具体功能考虑"><a href="#起名字与具体功能考虑" class="headerlink" title="起名字与具体功能考虑"></a>起名字与具体功能考虑</h3><p>应该要考虑的点</p>
<ul>
<li>代码规范（大小写）</li>
<li>函数名称直接使用功能名</li>
<li>传递的参数，不用考虑太多，例如数组直接arr1或者arr+功能名称搞定</li>
</ul>
<h3 id="新变量与返回值"><a href="#新变量与返回值" class="headerlink" title="新变量与返回值"></a>新变量与返回值</h3><p>看完题，可以看下是否需要声明新变量，需要返回的结果与结果类型</p>
<ul>
<li>如果要返回数组，是在一开始声明一个数组，还是用map、filter函数</li>
<li>对象深拷贝，返回一个拷贝后的对象，是怎初期声明一个空对象，然后返回处理过的 </li>
<li>在可以不声明变量或者声明新变量都可以解决的情况下，就不用考虑这么多空间复杂度与时间复杂度的优化了，先写了，面试官问优化再写</li>
</ul>
<h3 id="考虑用循环还是递归"><a href="#考虑用循环还是递归" class="headerlink" title="考虑用循环还是递归"></a>考虑用循环还是递归</h3><h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><h5 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h5><p>这个太熟，不写</p>
<h5 id="for-in-循环"><a href="#for-in-循环" class="headerlink" title="for in 循环"></a>for in 循环</h5><p>主要用于遍历对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (keys in object)</span><br></pre></td></tr></table></figure>

<p>要注意for…in连原型链上的属性也能读取，可以使用hasOwnProperty(keys)== true判断，true就是不是原型链上的</p>
<h5 id="for-of-循环"><a href="#for-of-循环" class="headerlink" title="for of 循环"></a>for of 循环</h5><p>可以遍历所有部署了Symbol.iterator(迭代器)的数据结构，for…of调用的是内部的Symbol.iterator方法</p>
<h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><blockquote>
<p><a href="https://juejin.im/post/5d85cda3f265da03b638e918" target="_blank" rel="noopener">https://juejin.im/post/5d85cda3f265da03b638e918</a></p>
</blockquote>
<h3 id="考虑界限"><a href="#考虑界限" class="headerlink" title="考虑界限"></a>考虑界限</h3><p>一般题目用到循环的话，都要考虑下判定条件，其中还有类型的判断条件</p>
<h4 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h4><h5 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h5><p>普通的通过typeof判断</p>
<ul>
<li>对null判断有误差，得到object（bug来的，null不是object）</li>
<li>对于object对象的类型区分不够，无法区分数组等，除了函数</li>
</ul>
<h5 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h5><p>测试构造函数的prototype是否出现在被检测对象的原型链上</p>
<ul>
<li>无法区分普通对象与array，例如我一个array.instanceof数组或者对象都是true，无法再细分（但是不是array的去instanceof数组都是可以分出哦）</li>
</ul>
<h5 id="Object-prototype-toString-call"><a href="#Object-prototype-toString-call" class="headerlink" title="Object.prototype.toString.call()"></a>Object.prototype.toString.call()</h5><p>完美方法</p>
<ul>
<li>用Object.prototype.toString()方法，然后改变他的this指向为我们要验证的类型</li>
<li>能够判断原始类型是因为他里面有包装</li>
<li>能够判断null与undefined是因为内部有做处理</li>
</ul>
<h5 id="Array-isArray"><a href="#Array-isArray" class="headerlink" title="Array.isArray()"></a>Array.isArray()</h5><p>判断参数是否为数组</p>
<h4 id="空值判断"><a href="#空值判断" class="headerlink" title="空值判断"></a>空值判断</h4><h5 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h5><p>数组判断的话就是length=0</p>
<h5 id="json对象"><a href="#json对象" class="headerlink" title="json对象"></a>json对象</h5><p>转换为字符串，然后看是否等于’{}’</p>
<h5 id="for…in循环判断对象"><a href="#for…in循环判断对象" class="headerlink" title="for…in循环判断对象"></a>for…in循环判断对象</h5><p>可以用for…in的就是对象咯</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">judgeObj</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">judgeObj(obj); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h5 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys()"></a>Object.keys()</h5><p>同样是有返回就就是对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.keys(obj).length === <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h5 id="直接使用对象属性判断"><a href="#直接使用对象属性判断" class="headerlink" title="直接使用对象属性判断"></a>直接使用对象属性判断</h5><p>前提是确定obj不为空，一定会包含name属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">obj &amp;&amp; obj.name ? <span class="string">'不为空'</span> : <span class="string">'为空'</span>; <span class="comment">// 三元表达式操作</span></span><br></pre></td></tr></table></figure>

<h4 id="等号使用"><a href="#等号使用" class="headerlink" title="等号使用"></a>等号使用</h4><h5 id="双等号比较过程"><a href="#双等号比较过程" class="headerlink" title="双等号比较过程"></a>双等号比较过程</h5><ul>
<li><p>如果两个值类型相同，再进行三等号比较</p>
</li>
<li><p>如果两个值类型不同，也有可能相同，因为会有默认类型转换</p>
<ul>
<li>null与undefined相等</li>
<li>如果一个是字符串，一个是数值，把字符串转为数值再进行比较</li>
</ul>
</li>
</ul>
<h5 id="三等号比较过程"><a href="#三等号比较过程" class="headerlink" title="三等号比较过程"></a>三等号比较过程</h5><ul>
<li>如果类型不同，就一定不相等</li>
<li>如果两个都是数值并同值，那么相等，如果其中至少一个是NaN，那么不相等</li>
<li>如果两个都是字符串，每个位置的字符都一样，那么相等，否则不相等</li>
<li>如果两个都是true或是false，那么相等</li>
<li>如果两个值引用同一个对象或者函数，那么相等，否则不相等</li>
<li>如果两个值都是null或者undefined，那么相等</li>
</ul>
<h3 id="数组常用函数"><a href="#数组常用函数" class="headerlink" title="数组常用函数"></a>数组常用函数</h3><h4 id="Array-splice-begin-deleteCount-addItem1-addItem2…"><a href="#Array-splice-begin-deleteCount-addItem1-addItem2…" class="headerlink" title="Array.splice(begin, deleteCount, addItem1, addItem2…)"></a>Array.splice(begin, deleteCount, addItem1, addItem2…)</h4><ul>
<li>改变源数组</li>
<li>可以向数组添加新元素</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">var</span> b = arr.splice(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="comment">// a: [1,4,5]</span></span><br><span class="line"><span class="comment">// b: [2,3]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = arr.splice(<span class="number">1</span>,<span class="number">2</span>,<span class="number">777</span>,<span class="number">888</span>)</span><br><span class="line"><span class="comment">// a: [1,777,888,4,5]</span></span><br><span class="line"><span class="comment">// b: [2,3]</span></span><br></pre></td></tr></table></figure>

<h4 id="Array-slice-start-end"><a href="#Array-slice-start-end" class="headerlink" title="Array.slice([start[, end]])"></a>Array.slice([start[, end]])</h4><ul>
<li>不改变原数组，创建新数组，将一部分元素浅复制到新的数组对象，并返回</li>
<li>end是不包进去的</li>
<li>直接空参数就是复制了一个新的数组</li>
<li>浅复制指的是如果遇到不是基础类型的对象，知识复制引用而已</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>,<span class="string">"four"</span>, <span class="string">"five"</span>];</span><br><span class="line"><span class="built_in">console</span>.log(array.slice()); <span class="comment">// ["one", "two", "three","four", "five"]</span></span><br><span class="line"><span class="built_in">console</span>.log(array.slice(<span class="number">2</span>,<span class="number">3</span>)); <span class="comment">// ["three"]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>第一个参数为负数，代表错length+start位置开始复制，那么end的参数是比第一个参数少的值（就是倒过来复制）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].slice(<span class="number">-1</span>));<span class="comment">//[3]</span></span><br><span class="line"><span class="comment">// -1直接拿了最后一个值</span></span><br></pre></td></tr></table></figure>

<h5 id="Array-join-‘xxx’"><a href="#Array-join-‘xxx’" class="headerlink" title="Array.join(‘xxx’)"></a>Array.join(‘xxx’)</h5><ul>
<li>将所有元素连接一个字符串咯</li>
</ul>
<h4 id="push、concat、indexOf"><a href="#push、concat、indexOf" class="headerlink" title="push、concat、indexOf"></a>push、concat、indexOf</h4><ul>
<li>push末尾加数</li>
<li>concat合并两个数组或元素并返回</li>
<li>indexOf查找元素在数组中第一次出现的索引，没有返回-1</li>
</ul>
<h5 id="Array-includes-element-fromIndex-0"><a href="#Array-includes-element-fromIndex-0" class="headerlink" title="Array.includes(element, fromIndex=0)"></a>Array.includes(element, fromIndex=0)</h5><ul>
<li>es7的方法</li>
<li>判断当前数组是否有指定的值，是返回true，否返回false</li>
<li>formindex为开始查找的位置索引</li>
</ul>
<h3 id="字符串常用函数"><a href="#字符串常用函数" class="headerlink" title="字符串常用函数"></a>字符串常用函数</h3><h4 id="String-split-element"><a href="#String-split-element" class="headerlink" title="String.split(element)"></a>String.split(element)</h4><ul>
<li>不改变原始字符串</li>
<li>根据给的值分割成数组</li>
</ul>
<h4 id="String-substr-start-length"><a href="#String-substr-start-length" class="headerlink" title="String.substr(start[, length])"></a>String.substr(start[, length])</h4><ul>
<li>返回指定位置开始指定数量的字符串</li>
<li>start一样有正有负，负值表示从length+start开始</li>
</ul>
<h3 id="对象的常用函数"><a href="#对象的常用函数" class="headerlink" title="对象的常用函数"></a>对象的常用函数</h3><h4 id="Object-prototype-hasOwnProperty-prop"><a href="#Object-prototype-hasOwnProperty-prop" class="headerlink" title="Object.prototype.hasOwnProperty(prop)"></a>Object.prototype.hasOwnProperty(prop)</h4><ul>
<li>判断是否为自身属性，是返回true，原型链中的或者不存在的返回false</li>
</ul>
<h4 id="Object-create-obj-descr"><a href="#Object-create-obj-descr" class="headerlink" title="Object.create(obj,descr)"></a>Object.create(obj,descr)</h4><ul>
<li>创建一个新对象，并为他设置原型</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> parent = &#123;<span class="attr">hi</span>: <span class="string">'Hello'</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> o = <span class="built_in">Object</span>.create(parent, &#123;</span><br><span class="line">    prop: &#123;</span><br><span class="line">        value: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">o.hi; <span class="comment">// 'Hello'</span></span><br><span class="line"><span class="comment">// 获得它的原型</span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(parent) === <span class="built_in">Object</span>.prototype; <span class="comment">// true 说明parent的原型是Object.prototype</span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(o); <span class="comment">// &#123;hi: "Hello"&#125; // 说明o的原型是&#123;hi: "Hello"&#125;</span></span><br><span class="line">o.hasOwnProperty(<span class="string">'hi'</span>); <span class="comment">// false 说明hi是原型上的</span></span><br><span class="line">o.hasOwnProperty(<span class="string">'prop'</span>); <span class="comment">// true 说明prop是原型上的自身上的属性。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以用来创建空对象</span></span><br><span class="line"><span class="keyword">var</span> o = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line"><span class="keyword">typeof</span> o.toString(); <span class="comment">// 'undefined'</span></span><br></pre></td></tr></table></figure>

<h3 id="其他常用"><a href="#其他常用" class="headerlink" title="其他常用"></a>其他常用</h3><h4 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h4><p>类似数组，指的是对线属性名为数字，而又有对应值</p>
<p>这里指的是用方法将一堆值转换为这种类似数组的形势</p>
<ul>
<li>es6的…运算符</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [...arrayLike]; <span class="comment">// ['a','b','c']</span></span><br></pre></td></tr></table></figure>

<ul>
<li>es6的Array.form</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr2 = <span class="built_in">Array</span>.from(arrayLike); <span class="comment">// ['a', 'b', 'c']</span></span><br></pre></td></tr></table></figure>

<ul>
<li>es5的Array.prototype.slice.call()</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a,b,c,d</span>) </span></span><br><span class="line"><span class="function">   </span>&#123; </span><br><span class="line">      <span class="keyword">var</span> arg = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>,<span class="number">1</span>); </span><br><span class="line">      alert(arg); </span><br><span class="line">   &#125; </span><br><span class="line">   test(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>); <span class="comment">//b,c,d</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个参数是context，替换方法中的this</span></span><br><span class="line"><span class="comment">// 第二个参数传递给对象函数的参数</span></span><br></pre></td></tr></table></figure>

<p>甚至能将具有length属性的对象转换为数组</p>
<blockquote>
<p>最后可以看看高阶函数<a href="https://juejin.im/post/5d10f4746fb9a07eee5eda1c" target="_blank" rel="noopener">https://juejin.im/post/5d10f4746fb9a07eee5eda1c</a></p>
</blockquote>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>刷面试题4</title>
    <url>/2020/04/24/%E9%9D%A2%E8%AF%95/%E7%9C%8B%E4%B9%A64/</url>
    <content><![CDATA[<p><img src="https://s1.ax1x.com/2020/04/24/JDPxRH.jpg" alt="JDPxRH.jpg"></p>
<p>今天的我又来了，嘤嘤嘤，加油奥利给</p>
<h2 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h2><h3 id="网络七层模型"><a href="#网络七层模型" class="headerlink" title="网络七层模型"></a>网络七层模型</h3><ul>
<li>物理层：网络连接介质,如网线、光缆、数据再其中传播</li>
<li>数据链路层：数据链路层将比特封装为数据帧然后传递</li>
<li>网络层：定义ip地址，定义路由功能，建立主机到主机的通信</li>
<li>传输层：负责将数据进行可靠或者不可靠传递，建立端口到端口的通信</li>
<li>会话层：控制应用之间会话能力，区分不同进程</li>
<li>表示层：数据格式标识，基本压缩加密功能</li>
<li>应用层：各种应用软件</li>
</ul>
<h3 id="常见的HTTP状态码"><a href="#常见的HTTP状态码" class="headerlink" title="常见的HTTP状态码"></a>常见的HTTP状态码</h3><h4 id="2xx"><a href="#2xx" class="headerlink" title="2xx"></a>2xx</h4><p>请求成功，常见是200</p>
<h3 id="3xx"><a href="#3xx" class="headerlink" title="3xx"></a>3xx</h3><p>重定向有分类</p>
<ul>
<li>301永久重定向：请求的网页永久移动到新位置</li>
<li>302:临时重定向：请求的网页临时移动，服务器从不同位置的网页响应请求，但请求者继续使用原有位置来进行以后的请求</li>
<li>304未修改：请求的网页未修改过，服务器响应时，返屋企返回此响应时，不会返回网页内容</li>
</ul>
<h3 id="4xx"><a href="#4xx" class="headerlink" title="4xx"></a>4xx</h3><p>错误，还是有分类</p>
<ul>
<li>400错误请求：服务器无法理解</li>
<li>401未授权：表示发送的请求需要有通过http认证的认证信息，常见于客户端登录</li>
<li>403禁止：服务器拒绝请求</li>
<li>404:未找到：服务器找不到对应资源</li>
</ul>
<h3 id="5xx"><a href="#5xx" class="headerlink" title="5xx"></a>5xx</h3><p>服务端错误</p>
<p>500：服务器内部错误，服务器遇到错误，无法完成请求</p>
<p>501：尚未实施,服务器不具备完成请求的功能</p>
<p>502：上游服务器接收到无效的响应</p>
<p>503：服务不可用，服务器拉闸</p>
<h3 id="GET与POST的区别"><a href="#GET与POST的区别" class="headerlink" title="GET与POST的区别"></a>GET与POST的区别</h3><p>标准答案</p>
<ul>
<li>GET请求参数在url上，POST请求参数在请求体力</li>
<li>GET请求参数长度有限制，POST请求参数长度可以很大</li>
<li>POST请求相比于GET更安全</li>
<li>GET能缓存，POST不能</li>
</ul>
<p>其实http协议没有要求get请求的参数一定在url上，也没有规定长度，目前是各个浏览器自己设置的，根本原因是GET是幂等性，而POST请求不是</p>
<p>幂等性指的是对某一资源进行一次或多次请求都具有相同的副作用，例如搜索，一次或多次都是一样返回搜索数据，删除新增一次之后后面就没了，再请求报错</p>
<p>因此，GET请求在不好的网络中，他可能会重复发，因为结果是一样的，重复发造成重复操作，所以像上面说的一样，一般crud用于查询，增加删除不会的</p>
<h3 id="HTTP的请求报文是由哪几部分组成的，响应报文同理"><a href="#HTTP的请求报文是由哪几部分组成的，响应报文同理" class="headerlink" title="HTTP的请求报文是由哪几部分组成的，响应报文同理"></a>HTTP的请求报文是由哪几部分组成的，响应报文同理</h3><p>请求报文由请求行、请求头、空行、请求数据4部分组成</p>
<p>响应报文由响应行、响应头、空行、响应数据4部分组成</p>
<h3 id="常见请求-响应头及其含义"><a href="#常见请求-响应头及其含义" class="headerlink" title="常见请求/响应头及其含义"></a>常见请求/响应头及其含义</h3><h4 id="通用头：请求头与响应头都有的"><a href="#通用头：请求头与响应头都有的" class="headerlink" title="通用头：请求头与响应头都有的"></a>通用头：请求头与响应头都有的</h4><p><img src="https://s1.ax1x.com/2020/04/24/JD80Fe.png" alt="JD80Fe.png"></p>
<h4 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h4><p><img src="https://s1.ax1x.com/2020/04/24/JDGim6.png" alt="JDGim6.png"></p>
<h4 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h4><p><img src="https://s1.ax1x.com/2020/04/24/JDt2cj.png" alt="JDt2cj.png"></p>
<h4 id="实体头"><a href="#实体头" class="headerlink" title="实体头"></a>实体头</h4><p><img src="https://s1.ax1x.com/2020/04/24/JDNFvd.png" alt="JDNFvd.png"></p>
<p>太多拉，记不住啦  嘤嘤嘤</p>
<h3 id="HHTP-1-0和HTTP-1-1的区别"><a href="#HHTP-1-0和HTTP-1-1的区别" class="headerlink" title="HHTP/1.0和HTTP/1.1的区别"></a>HHTP/1.0和HTTP/1.1的区别</h3><ul>
<li>长连接：1.1可以建立长连接和请求的流水线，在一个TCP连接上可以传送多个HTTP请求，避免了因为多次TCP连接的事件消耗和延时</li>
<li>缓存处理：1.1引入了一些新的请求头来控制缓存</li>
<li>带宽优化以及网络连接的使用：在请求头引入了range头域，支持断点续传功能</li>
<li>Host头处理：Host是解决多个主机共享一个ip的情况的，在1.1中，没有host头的请求都会400错误</li>
</ul>
<h3 id="HTTP-2-0新特性"><a href="#HTTP-2-0新特性" class="headerlink" title="HTTP/2.0新特性"></a>HTTP/2.0新特性</h3><ul>
<li>多路复用：多个请求都通过一个TCP连接并发完成</li>
<li>服务端推送：主动把资源推给客户端</li>
<li>新的二进制格式：2.0采用二进制格式传输数据，1.1用的是文本，二进制拥有更好的解析性和拓展性</li>
<li>header压缩：2.0压缩消息头，减少传输数据的大小</li>
</ul>
<h3 id="http2-0的多路复用"><a href="#http2-0的多路复用" class="headerlink" title="http2.0的多路复用"></a>http2.0的多路复用</h3><p>解决的问题</p>
<ul>
<li>tcp启动慢，就是加快tcp启动</li>
<li>多条tcp连接会竞争带宽</li>
<li>http1.1一个tcp传输多个请求时，同一时刻只能处理一个请求，其他请求只能等着</li>
</ul>
<p>2.0做了什么呢，，只使用一个tcp连接来传输数据，而请求可以并发，为什么可以这样呢</p>
<p>他是引入了一个二进制的分帧层，数据都会经过这个东西经过处理，转换为一个个带有特殊id的帧携带数据，最后在传输完成后组合成对应数据</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>开通阿里云oss</title>
    <url>/2020/04/28/%E8%B8%A9%E5%9D%91/%E5%BC%80%E9%80%9A%E9%98%BF%E9%87%8C%E4%BA%91oss/</url>
    <content><![CDATA[<p>本意是写这个笔记，之前用的路过图床，但是我发现我放github上是直接拉闸的，访问不到</p>
<p>搞一个阿里云的5块钱40gb半年，正常我的东西就我自己看（嘤嘤嘤），问题是不大的</p>
<p>记录下，应该会踩坑</p>
<p>首先如何购买就不说了</p>
<p>有几种使用方式，看官方文档，我们是window就用window的吧，下载解压</p>
<p>然后启动</p>
<p>首先是登陆，用默认的，这里要key，key等于密码</p>
<p>key要自己创建</p>
<p>看文档</p>
<blockquote>
<p><a href="https://help.aliyun.com/document_detail/53045.html?spm=a2c4g.11186623.2.20.23db11441cRhm1#concept-53045-zh" target="_blank" rel="noopener">https://help.aliyun.com/document_detail/53045.html?spm=a2c4g.11186623.2.20.23db11441cRhm1#concept-53045-zh</a></p>
</blockquote>
<p>然后要给刚加的用户配置权限</p>
<p>然后这个window的怎么操作，也是看文档哒0.0</p>
<blockquote>
<p><a href="https://help.aliyun.com/document_detail/61872.html?spm=a2c4g.11186623.2.21.5ae01c62IcNSYf#concept-xmg-h33-wdb" target="_blank" rel="noopener">https://help.aliyun.com/document_detail/61872.html?spm=a2c4g.11186623.2.21.5ae01c62IcNSYf#concept-xmg-h33-wdb</a></p>
</blockquote>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>工作</tag>
        <tag>踩坑</tag>
        <tag>阿里云</tag>
      </tags>
  </entry>
  <entry>
    <title>刷面试题5</title>
    <url>/2020/04/25/%E9%9D%A2%E8%AF%95/%E7%9C%8B%E4%B9%A65/</url>
    <content><![CDATA[<p>我透，事实证明不要瞎搞，直接把前面的笔记搞没了，明天补吧</p>
<h2 id="前端安全"><a href="#前端安全" class="headerlink" title="前端安全"></a>前端安全</h2><h3 id="CSRF攻击"><a href="#CSRF攻击" class="headerlink" title="CSRF攻击"></a>CSRF攻击</h3><p>跨站请求伪造，黑客在我们的网址上放了自己的链接，默认浏览器会带着我们的网站的cookie去访问这个网址，导致用户的账号cookie被知道了翻车</p>
<h3 id="防御CSRF攻击"><a href="#防御CSRF攻击" class="headerlink" title="防御CSRF攻击"></a>防御CSRF攻击</h3><ul>
<li><p>验证token，浏览器请求服务器时，服务器返回一个token，每个请求都要带上token，token与cookie双验证就安全了</p>
</li>
<li><p>验证Referer，验证请求头的Referer来验证是否为源站点，但是请求头很容易伪造</p>
</li>
<li><p>设置SameSite，设置cookie的SameSite，让cookie不随跨域请求发出，但浏览器兼容不一</p>
</li>
</ul>
<h3 id="XSS攻击"><a href="#XSS攻击" class="headerlink" title="XSS攻击"></a>XSS攻击</h3><p>通过网页开发漏洞，注入恶意指令代码到网页，用户运行时让他运行自己的代码</p>
<p>常见类型</p>
<ul>
<li>存储型：放在服务器的，所以看到的用户都会拉闸</li>
<li>url型：放在url里面的，服务端接收之后会以为他是参数然后取出放在html里面，再到html里面执行</li>
<li>dom型：攻击脚本写在url里，用户点击后，攻击脚本运行，dom型不经过服务端，而是插入，然后通过点击运行</li>
</ul>
<h3 id="防止xss攻击"><a href="#防止xss攻击" class="headerlink" title="防止xss攻击"></a>防止xss攻击</h3><ul>
<li>输入检查：对内容中的script、iframe等进行转义或者过滤</li>
<li>设置httpOnly：很多xss攻击目标都是窃取用户cookie伪造身份认证，设置属性防止js获取cookie</li>
<li>开启CSP：开始白名单，名单外的资源无法加载和运行</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络01</title>
    <url>/2020/04/08/%E8%A1%A5%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/01.%E6%A6%82%E5%BF%B5%E3%80%81%E7%BB%84%E6%88%90%E3%80%81%E5%8A%9F%E8%83%BD%E3%80%81%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>计算机网络：是一个将分散的、具有独立功能的<strong>计算机系统</strong>。通过<strong>通信设备</strong>与<strong>线路</strong>连接起来，由功能完善的<strong>软件</strong>实现<strong>资源共享</strong>和<strong>信息传递</strong>的系统</p>
<p>计算机网络是<strong>互连</strong>的、<strong>自治</strong>的计算机集合</p>
<ul>
<li>互连：互联互通</li>
<li>自治：无主从关系</li>
</ul>
<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ul>
<li>数据通信</li>
<li>资源共享（硬件、软件、数据）</li>
<li>分布式处理</li>
<li>提高可靠性：指的是一个网络不通有其他网络可以通</li>
<li>负载均衡</li>
</ul>
<h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><h3 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h3><ul>
<li>硬件</li>
<li>软件</li>
<li>协议</li>
</ul>
<h3 id="工作港式"><a href="#工作港式" class="headerlink" title="工作港式"></a>工作港式</h3><ul>
<li>边缘部分<ul>
<li>c/s方式</li>
<li>p2p方式</li>
</ul>
</li>
<li>核心部分:为边缘部分服务</li>
</ul>
<h3 id="功能组成"><a href="#功能组成" class="headerlink" title="功能组成"></a>功能组成</h3><ul>
<li>通信子网：实现数据通信（网络层、数据链路层、物理层）</li>
<li>资源子网：实现资源共享/数据处理（会话层、表示层、应用层）</li>
</ul>
<p><img src="http://zezeze-note.oss-cn-hongkong.aliyuncs.com/%E7%AC%94%E8%AE%B0%E6%88%AA%E5%9B%BE/Gf11Rs.png?OSSAccessKeyId=LTAI4GCeVHegRoadhkK6mc12&Expires=1588155983&Signature=Cq8%2F2T5W5JekoShaVZrwKWqaqW4%3D" alt="Gf11Rs.png"></p>
<p>传输层是他们中间的</p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul>
<li><p>分部范围：广域网、城域网、局域网、个人局域网</p>
</li>
<li><p>按使用者：公用网、专用网</p>
</li>
<li><p>按交换技术：电路交换、报文交换、分组交换</p>
</li>
<li><p>按拓扑结构：总线型、星型、环型、网状型</p>
</li>
<li><p>按传输技术分：广播式网络、点对点网络（分组存储式转发和路由选择）</p>
</li>
</ul>
<p><img src="http://zezeze-note.oss-cn-hongkong.aliyuncs.com/%E7%AC%94%E8%AE%B0%E6%88%AA%E5%9B%BE/Gf3iwT.png?OSSAccessKeyId=LTAI4GCeVHegRoadhkK6mc12&Expires=1588156131&Signature=wFKX06N5XoYOEpN5FimdyEQO4Y8%3D" alt="Gf3iwT.png"></p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>补基础</tag>
        <tag>基础</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络03</title>
    <url>/2020/04/08/%E8%A1%A5%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/03.%E6%80%A7%E8%83%BD%E6%A0%87%E5%87%86/</url>
    <content><![CDATA[<h2 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h2><p>数据率、数据传输率、比特率</p>
<p>单位：比特 b/s、kb/s、Mb/s、Gb/s、Tb/s（换算是1000倍关系）</p>
<p>定义：连接在计算机上的主机在数字信道上传送数据位数的速率</p>
<p>形容速率是1000</p>
<p>形容存储容量是1024，存储容量是大写的B KB、MB等</p>
<h2 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h2><p>原本指某个信号具有的频带宽度，即最高频率与最低频率的差，单位是hz</p>
<p>数字信号之后是指网络的通信线路传送数据的能力，通常是指单位时间内从网络一点到某一点所能通过的<strong>最高数据率</strong>，单位与速率的一样</p>
<p>生活中指网络设备支持的最高速度</p>
<p>理解为主机在发送端最高发送的速率，而不是传输的速率，传输速率受线材影响</p>
<h2 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h2><p>单位时间内通过某个网络或信道或接口的数据量，单位也是速率</p>
<p>受网络的带宽与网络的额定速率的限制</p>
<h2 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h2><p>指数据从网络的一端传送到另一端所需的时间，也叫延迟，单位是s</p>
<ul>
<li>发送时延：从发送第一个比特到最后一个比特的时间</li>
</ul>
<p>$$<br>发送时延=\frac{数据长度}{信道带宽(发送速率)}<br>$$</p>
<ul>
<li>传播时延：在路线渣传播的时间，取决于电磁波传播速度和链路长度，默认2*10的8次方</li>
</ul>
<p>$$<br>传播时延=\frac{信道长度}{电磁波在信道上的传播速率}<br>$$</p>
<ul>
<li><p>排队时延：等待输出或输入链路可用的时间</p>
</li>
<li><p>处理时延：检错或找出口</p>
</li>
</ul>
<p>高速链路指的是发送速率的提高</p>
<h2 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h2><p>$$<br>时延带宽积=传播时延×带宽<br>$$</p>
<p>单位bit=s*b/s</p>
<p>指的是以比特为单位的链路长度，又称为某链路现在有多少比特，容量</p>
<h2 id="往返时延RTT"><a href="#往返时延RTT" class="headerlink" title="往返时延RTT"></a>往返时延RTT</h2><p>指发送放发送数据开始，到发送方收到接收方的确认（接收方收到后立即发送确认）总共经历的时延</p>
<p>RTT越大，在收到确认之前可以发送更多的数据</p>
<p>RTT包括</p>
<ul>
<li>往返传播时延</li>
<li>末端处理时间</li>
</ul>
<h2 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h2><ul>
<li>信道利用率</li>
</ul>
<p>$$<br>信道利用率=\frac{有数据通过时间}{数据通过时间}<br>$$</p>
<ul>
<li>网络利用率：信道利用率加权平均值</li>
</ul>
<p><img src="http://zezeze-note.oss-cn-hongkong.aliyuncs.com/%E7%AC%94%E8%AE%B0%E6%88%AA%E5%9B%BE/%E8%A1%A5%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/03/GfdH3T.png?OSSAccessKeyId=LTAI4GCeVHegRoadhkK6mc12&Expires=1588158592&Signature=BuBgCS2xqWZ1Dq81U%2FzM8vOACoM%3D" alt="GfdH3T.png"></p>
<p><img src="http://zezeze-note.oss-cn-hongkong.aliyuncs.com/%E7%AC%94%E8%AE%B0%E6%88%AA%E5%9B%BE/%E8%A1%A5%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/03/GfdxER.png?OSSAccessKeyId=LTAI4GCeVHegRoadhkK6mc12&Expires=1588158617&Signature=RyDxTXahM8kYHR28sdHr3dZH%2BCg%3D" alt="GfdxER.png"></p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>补基础</tag>
        <tag>基础</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络02</title>
    <url>/2020/04/08/%E8%A1%A5%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/02.%E6%A0%87%E5%87%86%E5%8C%96%E5%B7%A5%E4%BD%9C%E5%8F%8A%E7%BB%84%E7%BB%87/</url>
    <content><![CDATA[<p>标准化：为了实现不同厂商的硬件软件之间相互连通</p>
<h2 id="标准分类"><a href="#标准分类" class="headerlink" title="标准分类"></a>标准分类</h2><ul>
<li>法定标准：权威机构定制的，合法的标准OSI</li>
<li>事实标准：通用的标准TCP/IP</li>
</ul>
<h3 id="RFC"><a href="#RFC" class="headerlink" title="RFC"></a>RFC</h3><p>就是定制标准的方案流程</p>
<ul>
<li>草案，通过变RFC文档</li>
<li>建议标准</li>
<li>因特网标准</li>
</ul>
<p>有几个组织管理这些，不记</p>
<p><a href="https://imgchr.com/i/Gf3rtg" target="_blank" rel="noopener"><img src="http://zezeze-note.oss-cn-hongkong.aliyuncs.com/%E7%AC%94%E8%AE%B0%E6%88%AA%E5%9B%BE/Gf3rtg.png?OSSAccessKeyId=LTAI4GCeVHegRoadhkK6mc12&Expires=1588158128&Signature=q%2Bex7S5TNq1i46V%2FzW14XTkYB3g%3D" alt="Gf3rtg.png"></a></p>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>补基础</tag>
        <tag>基础</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络04</title>
    <url>/2020/04/09/%E8%A1%A5%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/04.%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>为什要分层？</p>
<p>网络传输涉及众多，分开几层好处理</p>
<h2 id="名词"><a href="#名词" class="headerlink" title="名词"></a>名词</h2><ul>
<li><p>实体：每一层中的活动元素</p>
</li>
<li><p>对等实体：同一层的实体</p>
</li>
<li><p>协议：一系列的规则与约定，只有对等实体之间才有协议</p>
<ul>
<li>语法：规定传输的数据格式</li>
<li>语义：规定要完成得功能</li>
<li>同步规定各种操作的顺序</li>
</ul>
</li>
<li><p>接口：两层之间的连接处，上层使用下层服务的入口</p>
</li>
<li><p>服务：每两层之间提供的东西，下层为上层提供服务</p>
</li>
</ul>
<h2 id="分层的基本原则"><a href="#分层的基本原则" class="headerlink" title="分层的基本原则"></a>分层的基本原则</h2><ul>
<li>各层之间相互独立，每层之间只实现一种相对独立的功能</li>
<li>每层之间界面自然清晰，易于理解，相互交流少</li>
<li>结构上可分割，层之间采用合适技术实现</li>
<li>保持上下层独立性，上层单向使用下层的服务</li>
<li>分层结构能促进标准化工作</li>
</ul>
<h2 id="3、4、5层的数据"><a href="#3、4、5层的数据" class="headerlink" title="3、4、5层的数据"></a>3、4、5层的数据</h2><ul>
<li>SDC</li>
</ul>
]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>补基础</tag>
        <tag>基础</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>vue中如何进行权限控制</title>
    <url>/2020/05/01/vue/vue%E4%B8%AD%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<p>啊哈，今天是劳动节，让我们祝全世界的劳动者节日快乐</p>
<p><img src="http://zezeze-note.oss-cn-hongkong.aliyuncs.com/%E8%A1%A8%E6%83%85%E5%8C%85/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200421100840.jpg" alt=""></p>
<p>权限操作遍布我们代码的所有层次，因此我们要会</p>
<p>以一个后台系统为例，有两个我们要控制的地方，一是侧边菜单栏，二是页面的各个按钮弹窗等</p>
<h2 id="我们的思路"><a href="#我们的思路" class="headerlink" title="我们的思路"></a>我们的思路</h2><p>跟后端获取用户拥有的权限列表，我们称之为permissionList</p>
<p>然后前端在项目中通过进行权限点的配置，通过permissionList中找这个用户是不是可以使用这个权限点，根据是否拥有进行不同的操作</p>
<h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><ul>
<li>什么时候获取permissionList，怎么保存</li>
<li>子路由全都没权限时不应该显示自己（就是我一个分组下面有4个权限点，都没有权限时，整个分组就不应该出现）</li>
<li>默认重定向的路由没有权限时，应寻找children中有权限的一项重定向</li>
<li>如果用户直接输入url试图跳到没有权限的页面，应该给他重定向</li>
</ul>
<h3 id="获取权限与保存"><a href="#获取权限与保存" class="headerlink" title="获取权限与保存"></a>获取权限与保存</h3><p>vue中router有一个beforeEach方法，官方文档的解释是这样的</p>
<p><img src="http://zezeze-note.oss-cn-hongkong.aliyuncs.com/%E7%AC%94%E8%AE%B0%E6%88%AA%E5%9B%BE/vue/vue%E4%B8%AD%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%9D%83%E9%99%90%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/Snipaste_2020-05-01_22-55-41.png" alt=""></p>
<p>这官方的什么j8文档，谁能看懂，还是要求助百度</p>
<p>这个beforEach用来做路由拦截的</p>
<p>当我们在配置一个路由的时候，可以自定义配置一个meta对象是不是要权限才能进入</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> @/router/index.js</span><br><span class="line"> <span class="keyword">import</span> A <span class="keyword">from</span> <span class="string">'@/components/a'</span></span><br><span class="line">&#123;</span><br><span class="line">    path: <span class="string">'/a'</span>,</span><br><span class="line">        name: <span class="string">'a'</span>,</span><br><span class="line">            component:	A,</span><br><span class="line">                meta : &#123;                      <span class="comment">//加一个自定义obj</span></span><br><span class="line">                    requireAuth:<span class="literal">true</span>      <span class="comment">//这个参数 true 代表需要登录才能进入A</span></span><br><span class="line">                &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>然后假设我们的全局vuex里面有一个userid</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">@/assets/store.js</span><br><span class="line"><span class="comment">//使用vuex三步走</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"><span class="comment">//这个理论来说</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">	state:&#123;</span><br><span class="line">		userId : <span class="string">''</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure>

<p>我们就可以用这个beforEach方法来写一个拦截判断权限了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">@/main.js</span><br><span class="line">思路：【</span><br><span class="line">	如果（即将进入的这个路由需要权限才能进入）&#123;</span><br><span class="line">	</span><br><span class="line">		如果(能获取到这个老哥的userID)&#123;</span><br><span class="line">			就让这个老哥进入这个路由</span><br><span class="line">		&#125;否则&#123;</span><br><span class="line">			就让这个老哥进入b这个页面</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125; 即将进入的路由不需要权限就能进入 &#123;</span><br><span class="line">	</span><br><span class="line">		就让这个老哥进入这个路由</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">】</span><br><span class="line">对应代码：</span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'@/assets/store'</span>   <span class="comment">//把这个userId获取过来</span></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to,<span class="keyword">from</span>,next</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(to.meta.requireAuth)&#123;</span><br><span class="line">		<span class="keyword">if</span>(store.state.userId)&#123;</span><br><span class="line">			next()</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			next(&#123;<span class="attr">path</span>:<span class="string">'/b'</span>&#125;)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		next()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这个只是基本的用法，结合我们上面所说的，怎么用permission呢</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入项目的 vuex</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'@/store'</span></span><br><span class="line"><span class="comment">// 引入判断是否拥有权限的函数</span></span><br><span class="line"><span class="keyword">import</span> &#123; includePermission &#125; <span class="keyword">from</span> <span class="string">'@/utils/permission'</span></span><br><span class="line"></span><br><span class="line">router.beforeEach(<span class="keyword">async</span> (to, <span class="keyword">from</span>, next) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 这里的to应该是获取路由的对象，next是定向路由</span></span><br><span class="line">    <span class="comment">// 这个form看不懂</span></span><br><span class="line">  <span class="comment">// 先判断是否为登录，登录了才能获取到权限，怎么判断登录就不写了</span></span><br><span class="line">  <span class="keyword">if</span> (!isLogin) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 这里获取 permissionList</span></span><br><span class="line">      <span class="keyword">await</span> store.dispatch(<span class="string">'getPermissionList'</span>) <span class="comment">//这个获取权限的异步写在vuex里面</span></span><br><span class="line">      <span class="comment">// 这里判断当前页面是否有权限</span></span><br><span class="line">      <span class="keyword">const</span> &#123; permissions &#125; = to.meta</span><br><span class="line">      <span class="keyword">if</span> (permissions) &#123;</span><br><span class="line">        <span class="keyword">const</span> hasPermission = includePermission(permissions)</span><br><span class="line">        <span class="keyword">if</span> (!hasPermission) next(&#123; <span class="attr">name</span>: <span class="string">'NoPermission'</span> &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">      next()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    next(&#123; <span class="attr">name</span>: <span class="string">'Login'</span> &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工具函数</span></span><br><span class="line"><span class="comment">// @/utils/permission</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'@/store'</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断是否拥有权限</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Array&lt;string&gt;&#125;</span> <span class="variable">permissions</span></span> - 要判断的权限列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">includePermission</span> (<span class="params">permissions = []</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这里要判断的权限没有设置的话，就等于不需要权限，直接返回 true</span></span><br><span class="line">  <span class="keyword">if</span> (!permissions.length) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  <span class="keyword">const</span> permissionList = store.state.permissionList</span><br><span class="line">  <span class="keyword">return</span> !!permissions.find(<span class="function"><span class="params">permission</span> =&gt;</span> permissionList.includes(permission))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @/store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    state: &#123;</span><br><span class="line">        permissionList: []</span><br><span class="line">    &#125;,</span><br><span class="line">    mutations: &#123;</span><br><span class="line">        updatePermissionList: <span class="function">(<span class="params">state, payload</span>) =&gt;</span> &#123;</span><br><span class="line">            state.permissionList = payload</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    actions: &#123;</span><br><span class="line">        getPermissionList: <span class="keyword">async</span> (&#123; state, commit &#125;) =&gt; &#123;</span><br><span class="line">            <span class="comment">// 这里是为了防止重复获取</span></span><br><span class="line">            <span class="keyword">if</span> (state.permissionList.length) <span class="keyword">return</span></span><br><span class="line">            <span class="comment">// 发送请求方法省略</span></span><br><span class="line">            <span class="keyword">const</span> list = <span class="keyword">await</span> api.getPermissionList()</span><br><span class="line">            commit(<span class="string">'updatePermissionList'</span>, list)  <span class="comment">// 获取返回了一个list</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="重定向问题"><a href="#重定向问题" class="headerlink" title="重定向问题"></a>重定向问题</h3><p>路由自带有一个redirect，但是他做不到动态判断，但是我们可以重写redirect，覆盖他原来的redirect，做到可以动态判断</p>
<blockquote>
<p><a href="https://router.vuejs.org/zh/guide/essentials/redirect-and-alias.html#%E9%87%8D%E5%AE%9A%E5%90%91" target="_blank" rel="noopener">https://router.vuejs.org/zh/guide/essentials/redirect-and-alias.html#%E9%87%8D%E5%AE%9A%E5%90%91</a></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 我们需要引入判断权限方法</span></span><br><span class="line"><span class="keyword">import</span> &#123; includePermission &#125; <span class="keyword">from</span> <span class="string">'@/utils/permission'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> children = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'list'</span>,</span><br><span class="line">    name: <span class="string">'UserList'</span>,</span><br><span class="line">    label: <span class="string">'用户列表'</span>,</span><br><span class="line">    meta: &#123;</span><br><span class="line">      permissions: [<span class="string">'U_1_1'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'group'</span>,</span><br><span class="line">    name: <span class="string">'UserGroup'</span>,</span><br><span class="line">    label: <span class="string">'用户组'</span>,</span><br><span class="line">    meta: &#123;</span><br><span class="line">      permissions: [<span class="string">'U_1_2'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routeDemo = &#123;</span><br><span class="line">  path: <span class="string">'/user'</span>,</span><br><span class="line">  name: <span class="string">'User'</span>,</span><br><span class="line">  label: <span class="string">'用户'</span>,</span><br><span class="line">  redirect: <span class="function">(<span class="params">to</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (includePermission(children[<span class="number">0</span>].meta.permissions)) <span class="keyword">return</span> &#123; <span class="attr">name</span>: children[<span class="number">0</span>].name &#125;</span><br><span class="line">    <span class="keyword">if</span> (includePermission(children[<span class="number">1</span>].meta.permissions)) <span class="keyword">return</span> &#123; <span class="attr">name</span>: children[<span class="number">1</span>].name &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  children</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这样每次都要修改router配置，有点麻烦</p>
<p>可以写一个动态方法生成</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @/utils/permission</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建重定向函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Object&#125;</span> <span class="variable">redirect</span></span> - 重定向对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;string&#125;</span> </span>redirect.name - 重定向的组件名称</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Array&lt;any&gt;&#125;</span> <span class="variable">children</span></span> - 子列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createRedirectFn</span> (<span class="params">redirect = &#123;&#125;, children = []</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 避免缓存太大，只保留 children 的 name 和 permissions</span></span><br><span class="line">  <span class="keyword">const</span> permissionChildren = children.map(<span class="function">(<span class="params">&#123; name = <span class="string">''</span>, meta: &#123; permissions = [] &#125; = &#123;&#125; &#125;</span>) =&gt;</span> (&#123; name, permissions &#125;))</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">to</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这里一定不能在 return 的函数外面筛选，因为权限是异步获取的</span></span><br><span class="line">    <span class="keyword">const</span> hasPermissionChildren = permissionChildren.filter(<span class="function"><span class="params">item</span> =&gt;</span> includePermission(item.permissions))</span><br><span class="line">    <span class="comment">// 默认填写的重定向的 name</span></span><br><span class="line">    <span class="keyword">const</span> defaultName = redirect.name || <span class="string">''</span></span><br><span class="line">    <span class="comment">// 如果默认重定向没有权限，则从 children 中选择第一个有权限的路由做重定向</span></span><br><span class="line">    <span class="keyword">const</span> firstPermissionName = (hasPermissionChildren[<span class="number">0</span>] || &#123; <span class="attr">name</span>: <span class="string">''</span> &#125;).name</span><br><span class="line">    <span class="comment">// 判断是否需要修改默认的重定向</span></span><br><span class="line">    <span class="keyword">const</span> saveDefaultName = !!hasPermissionChildren.find(<span class="function"><span class="params">item</span> =&gt;</span> item.name === defaultName &amp;&amp; defaultName)</span><br><span class="line">    <span class="keyword">if</span> (saveDefaultName) <span class="keyword">return</span> &#123; <span class="attr">name</span>: defaultName &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> firstPermissionName ? &#123; <span class="attr">name</span>: firstPermissionName &#125; : redirect</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后上面可以改成</span></span><br><span class="line"><span class="keyword">const</span> routeDemo = &#123;</span><br><span class="line">  path: <span class="string">'/user'</span>,</span><br><span class="line">  name: <span class="string">'User'</span>,</span><br><span class="line">  label: <span class="string">'用户'</span>,</span><br><span class="line">  redirect: createRedirectFn(&#123; <span class="attr">name</span>: <span class="string">'UserList'</span> &#125;, children),</span><br><span class="line">  children</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这样还是不够简单，每个路由都要配置name</p>
<p>写一个递归的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @/utils/permission</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建有权限的路由配置（多级）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Object&#125;</span> <span class="variable">config</span></span> - 路由配置对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Object&#125;</span> </span>config.redirect - 必须是 children 中的一个，并且使用 name</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPermissionRouter</span> (<span class="params">&#123; redirect, children = [], ...others &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> needRecursion = !!children.length</span><br><span class="line">  <span class="keyword">if</span> (needRecursion) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      ...others,</span><br><span class="line">      redirect: createRedirectFn(redirect, children),</span><br><span class="line">      children: children.map(<span class="function"><span class="params">item</span> =&gt;</span> createPermissionRouter(item))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      ...others,</span><br><span class="line">      redirect</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后我们把路由对象放进来递归就可以啦</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> routes = routesConfig.map(<span class="function"><span class="params">item</span> =&gt;</span> createPermissionRouter(item))</span><br></pre></td></tr></table></figure>

<p>重定向也是自定定向到children的第一个有权限的路由，省事了</p>
<h3 id="侧边栏问题"><a href="#侧边栏问题" class="headerlink" title="侧边栏问题"></a>侧边栏问题</h3><p>每个用户的侧边栏都不同，可以放到vuex里面动态生成</p>
<p>这个文章这里没有例子</p>
<h3 id="具体到元素的权限设置"><a href="#具体到元素的权限设置" class="headerlink" title="具体到元素的权限设置"></a>具体到元素的权限设置</h3><p>自定义指令咯，这里自定义了一个permission</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @/directive/permission</span></span><br><span class="line"><span class="keyword">import</span> &#123; includePermission &#125; <span class="keyword">from</span> <span class="string">'@/utils/permission'</span></span><br><span class="line"><span class="keyword">const</span> permissionHandle = <span class="function">(<span class="params">el, binding</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> permissions = binding.value</span><br><span class="line">  <span class="keyword">if</span> (!includePermission(permissions)) &#123;</span><br><span class="line">    el.classList.add(<span class="string">'hide'</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    el.classList.remove(<span class="string">'hide'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  inserted: permissionHandle,</span><br><span class="line">  update: permissionHandle</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里控制是否显示隐藏式通过类hide控制的</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-permission</span>=<span class="string">"['U_1']"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>再写一个全局方法这个判断他有没有权限，有的权限不是通过模板的嘛</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写全局方法是因为有的权限不在页面元素上</span></span><br><span class="line">&#123;</span><br><span class="line">  hasPermission () &#123;</span><br><span class="line">    <span class="comment">// 通过方法 $permission 判断是否拥有权限</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.$permission([<span class="string">'U_1_1'</span>, <span class="string">'U_1_2'</span>])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用的时候就是this.$permission</span></span><br></pre></td></tr></table></figure>

<p>要检测permission的返回值，所以在sotre中写判断</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @/utils/permission</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否拥有权限</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;Array&lt;string|number&gt;&#125;</span> <span class="variable">permissions</span></span> - 要判断的权限列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param <span class="type">&#123;Object&#125;</span> <span class="variable">permissionList</span></span> - 传入 store 中的权限列表以实现数据可监测</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">includePermissionWithStore</span> (<span class="params">permissions = [], permissionList = []</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!permissions.length) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">return</span> !!permissions.find(<span class="function"><span class="params">permission</span> =&gt;</span> permissionList.includes(permission))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// store中</span></span><br><span class="line"><span class="keyword">import</span> &#123; includePermissionWithStore &#125; <span class="keyword">from</span> <span class="string">'@/utils/permission'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  install (Vue, options) &#123;</span><br><span class="line">    Vue.prototype.$permission = <span class="function"><span class="keyword">function</span> (<span class="params">permissions</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> permissionList = <span class="keyword">this</span>.$store.state.permissionList</span><br><span class="line">      <span class="keyword">return</span> includePermissionWithStore(permissions, permissionList)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为没具体用，还是有点小懵逼</p>
<p>这里等于给全局实例挂了一个$permissionList方法，然后再套一个has判断</p>
<p>留个全文</p>
<blockquote>
<p><a href="https://mp.weixin.qq.com/s/B-XbG_qvzqj4jt3jDEBLQA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/B-XbG_qvzqj4jt3jDEBLQA</a></p>
</blockquote>
<p>补充一个自定义权限的例子,结合理解</p>
<p>不过他没有放在vuex里面</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line">Vue.directive(<span class="string">'btnlimit'</span>, &#123;</span><br><span class="line">    <span class="comment">// 当被绑定的元素插入到 DOM 中时……</span></span><br><span class="line">    inserted: <span class="function">(<span class="params">el, binding</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// el 当前绑定的元素 binding.value指令的绑定值</span></span><br><span class="line">        <span class="keyword">let</span> permissionList = sessionStorage.getItem(<span class="string">'permission_button'</span>);</span><br><span class="line">        <span class="comment">// 判断一下是否包含这个元素，如果不包含的话，那就让他爸爸元素把子元素扔进垃圾堆</span></span><br><span class="line">        <span class="keyword">if</span> (!permissionList.includes(binding.value)) &#123;</span><br><span class="line">            el.parentNode.removeChild(el)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 大家可以把自己定义的指令写在一个directive.js文件中，在main.js总入口引入下就可以了，简单而不失优雅</span></span><br><span class="line"></span><br><span class="line">&lt;el-button v-btnlimit=<span class="string">"'edit'"</span>&gt;修改&lt;<span class="regexp">/el-button&gt;</span></span><br></pre></td></tr></table></figure>

<p>几个自定义属性的钩子函数</p>
<ul>
<li>bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</li>
<li>inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。</li>
<li>update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>sass总结</title>
    <url>/2020/05/14/css/sass%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>sass这个东西吧，其实常用的就那几个，但是仔细说起来还是有一点门道的，所以还是过一遍文档吧</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>canvas图片模糊问题</title>
    <url>/2020/05/07/%E8%B8%A9%E5%9D%91/canvas%E7%9A%84%E5%9B%BE%E7%89%87%E6%A8%A1%E7%B3%8A%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>网上冲浪看了一下，说这个问题还是挺普遍的</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>babel</tag>
        <tag>工作</tag>
        <tag>踩坑</tag>
      </tags>
  </entry>
  <entry>
    <title>UDP与TCP</title>
    <url>/2020/05/06/%E9%9D%A2%E8%AF%95/yck-UDP%E4%B8%8ETCP/</url>
    <content><![CDATA[<p>说是网络工程师，其实最弱的也是这部分，不过因为平常工作中不用，那也是没有办法滴</p>
<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>udp的特点</p>
<ul>
<li>面向无连接的，传输数据前双方不用建立连接</li>
<li>只是数据搬运，不能保证数据有序不丢失传输到</li>
<li>没有让控制流量的算法</li>
</ul>
<h3 id="面向无连接"><a href="#面向无连接" class="headerlink" title="面向无连接"></a>面向无连接</h3><p>这个特点使得udp很轻便，不用建立连接，想发就发的</p>
<p>同时也只是搬运数据，不会对报文做任何的处理</p>
<ul>
<li>在发送端，应用层将数据传递给传输层的UDP协议，UDP协议只会增加一个UDP的标识头，然后就给网络层了</li>
<li>接收端，网络层将数据给传输层，UDP只是去除ip报文头然后就会给应用层，不会做任何操作</li>
</ul>
<h3 id="不可靠性"><a href="#不可靠性" class="headerlink" title="不可靠性"></a>不可靠性</h3><p>这是无连接带来的，啥都管乱发肯定出事</p>
<p>对于发送方，我想什么时候发就发，也不会备份数据，也不关心对方会不会接受到</p>
<p>在传输的过程来说，udp没有拥塞机制，会以恒定的速度发送数据，即使网络条件不好，也不会调整发送速的，所以可能会丢数据</p>
<h3 id="高效"><a href="#高效" class="headerlink" title="高效"></a>高效</h3><p>这也是无连接带来的，因为没有连接建立，所以如果网络良好，传输数据会十分快，因此某些实时性要求高的场景例如直播、会议等都是用的udp</p>
<p>除了无连接，还有一个是因为udp头的开销小，只有八字节，也会提高传输速度</p>
<p><img src="http://zezeze-note.oss-cn-hongkong.aliyuncs.com/%E7%AC%94%E8%AE%B0%E6%88%AA%E5%9B%BE/%E9%9D%A2%E8%AF%95/yck-udptcp/Snipaste_2020-05-06_21-07-21.png?OSSAccessKeyId=LTAI4GCeVHegRoadhkK6mc12&Expires=1588774059&Signature=GZf3Bi2xNA5ZXvhJbcoMkT6d9ok%3D" alt=""></p>
<p>udp头部包含的数据</p>
<ul>
<li>两个十六位的端口号，分为源端口与目标端口</li>
<li>整个数据报文的长度</li>
<li>整个数据报文的检验和ipv4的可选字段</li>
</ul>
<h3 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a>传输方式</h3><p>不止一对一，可以一对多，多对多，多对一</p>
<h3 id="适合应用的场景"><a href="#适合应用的场景" class="headerlink" title="适合应用的场景"></a>适合应用的场景</h3><p>前面说的，直播视频，电话会议，有一些低延迟要求的游戏都是用的udp</p>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>tcp与udp最大的区别就是我tcp是要握手建立连接的，并且通过各种算法保证我tcp数据的可靠性，当然就慢啦</p>
<p>tcp保证这些是通过几个方面的</p>
<h3 id="头部"><a href="#头部" class="headerlink" title="头部"></a>头部</h3><p>他的头部有几个字段</p>
<p><img src="http://zezeze-note.oss-cn-hongkong.aliyuncs.com/%E7%AC%94%E8%AE%B0%E6%88%AA%E5%9B%BE/%E9%9D%A2%E8%AF%95/yck-udptcp/Snipaste_2020-05-06_21-07-10.png?OSSAccessKeyId=LTAI4GCeVHegRoadhkK6mc12&Expires=1588774152&Signature=xil8vzc2c%2FPuSErnhELbUUwuLXs%3D" alt=""></p>
<p>只写重要的哈</p>
<ul>
<li>sequence number：保证tcp传输报文的有序</li>
<li>Acknowlwdgement Number：表示期望接受的下一个字节的编号是多少，有时候也会表示上一个序号的数据已经收到</li>
<li>Window Size：窗口大小，用于流量控制</li>
<li>标识符<ul>
<li>URG=1：表示本数据报的数据部分包含紧急信息，是一个高优先级的数据报文</li>
<li>ACK=1：表示确认字段有序，建立连接后的所有报文的ACK都是一</li>
<li>PSH=1：表示接收端接收到这段数据后应该立马push给应用层，而不是等到缓冲区满了再提交</li>
<li>RST=1：表示当前TCP连接出现严重问题，需要重新建立TCP连接，也可以用来拒绝非法的报文，或者表示我拒绝连接请求</li>
<li>SYN=1：这个为1且ACK=0时，表示当前报文是一个连接请求报文，当这个为1ACK=1时候，表示当前报文是一个同意建立连接的应答报文</li>
<li>FIN=1：表示该报文字段是一个释放连接的请求报文</li>
</ul>
</li>
</ul>
<h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><p>接下来是重头戏，三次握手，还有一个指标RTT，表示发送端发送数据到接收到对端数据的往返时间</p>
<p>首页要明确tcp是全双工的（就是建立连接后客户端与服务端是可以互相发数据的</p>
<p>握手中是有几个状态的，一开始大家都是closed状态，然后建立tcb，建立tcb然后进入listen状态，等待客户端发送数据</p>
<h4 id="第一次握手"><a href="#第一次握手" class="headerlink" title="第一次握手"></a>第一次握手</h4><p>客服端想服务器发送请求报文段，包含客户端的数据通讯序列初始序号，发送玩客户端进入syn-received状态</p>
<h4 id="第二次握手"><a href="#第二次握手" class="headerlink" title="第二次握手"></a>第二次握手</h4><p>服务端向客户端发送同意连接，客户端收到后发送应答，应答找包含自身数据通信初始序号，发送完成进入syn-received状态</p>
<h4 id="第三次握手"><a href="#第三次握手" class="headerlink" title="第三次握手"></a>第三次握手</h4><p>服务端又回了一个同意应答，然后再发一个确认报文，发送完就进入established状态，服务端收到应答也会进入同一状态，然后连接已经建立</p>
<p>这个第三次握手可以发一点数据，一般通过TFO（快速打开）实现，一般这种情况是发cookie，有cookiekey减少RTT</p>
<h3 id="为什么要三次握手"><a href="#为什么要三次握手" class="headerlink" title="为什么要三次握手"></a>为什么要三次握手</h3><p>这么麻烦本质都是为了连接的时候不出错嘛</p>
<p>假设客户端发送了一个请求a，因为网络原因造成了超时，这是tcp会启动重传机制发送一个请求b，结果a其实发出了，但是b先去了，因为a卡住了，b建立了连接，连接完他们释放了，这个时候卡这的a又出来了，服务器接到a以为客户端来了，他就会启动等待状态，结果客服端这时候已经close了，服务器空等</p>
<p>第三次握手可以避免这种情况，只有我接到两个确认我服务器才认为你是真的想建立连接</p>
<p>同时在连接中任何一方掉线，tcp都会尝试五次重发syn包</p>
<h2 id="断开连接的四次握手"><a href="#断开连接的四次握手" class="headerlink" title="断开连接的四次握手"></a>断开连接的四次握手</h2><p>断开连接也要四次握手，没想到吧</p>
<h3 id="第一次握手-1"><a href="#第一次握手-1" class="headerlink" title="第一次握手"></a>第一次握手</h3><p>客户端a认为我已经收到数据啦，向服务端b发送链接释放请求</p>
<h3 id="第二次握手-1"><a href="#第二次握手-1" class="headerlink" title="第二次握手"></a>第二次握手</h3><p>b收到释放请求，告诉应用端释放tcp，发送ack包，自己进入closewait状态，我不收a的数据了，但是b还是可以发数据给a，a没断嘛</p>
<h3 id="第三次握手-1"><a href="#第三次握手-1" class="headerlink" title="第三次握手"></a>第三次握手</h3><p>这个时候服务端还是可以发数据的，他会继续发完，b发完了，会向a发释放请求，b自己进入last-ack状态</p>
<h3 id="第四次握手"><a href="#第四次握手" class="headerlink" title="第四次握手"></a>第四次握手</h3><p>a收到释放请求，向b发送确认应答，自己进入time-wait状态（一般等2msl），会持续xmsl，如过b都没用相应的话，进入closed，b自己收到确认应答，也会进入clsoe</p>
<h3 id="为什么要等一会再close"><a href="#为什么要等一会再close" class="headerlink" title="为什么要等一会再close"></a>为什么要等一会再close</h3><p>我们等了2msl，2msl是一个报文在网络中的生存最大时间，超过这个时间这个报文在网络中是没有的了（为什么没有，别问我，我也不知道），怕的是关闭的确认应答卡住了，b一直不能关闭，所以等一会b收到，再自己close</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>手写promise</title>
    <url>/2020/05/03/%E9%9D%A2%E8%AF%95/yck-%E6%89%8B%E5%86%99promise/</url>
    <content><![CDATA[<p>留坑，大坑</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>输入url到页面渲染出来的整个柳橙</title>
    <url>/2020/05/04/%E9%9D%A2%E8%AF%95/yck-%E8%BE%93%E5%85%A5url%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%95%B4%E4%B8%AA%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p>这是道经典面试题，还是可以看看的</p>
<p>首先我在浏览器中输入了域名，我们从这里开始</p>
<h2 id="DNS查询"><a href="#DNS查询" class="headerlink" title="DNS查询"></a>DNS查询</h2><p>dns查询的作用是从具体的域名到ip，这一步是在tcp握手之前的但是这其实也是有具体过程的</p>
<ul>
<li>操作系统先查询本地缓存有没有这个ip</li>
<li>没有去系统配置的dns服务器中查询</li>
<li>还没有的画去DNS根服务器查询，会找到负责com的一级域名</li>
<li>然后会去服务器查询二级域名</li>
<li>然后一级级查询，直到找到ip</li>
</ul>
<p>这是系统负责的迭代查询的过程，还有客户端负责的递归查询</p>
<p>注意这里是用的udp</p>
<h2 id="TCP握手"><a href="#TCP握手" class="headerlink" title="TCP握手"></a>TCP握手</h2><p>握手之后应用层下发数据给传输层，tcp协议会指明两端的端口号，然后下发给网络层，网络层的ip协议会确定ip地址，并且指定数据传输中如何跳转路由器，然后将数据封装通过物理层传输</p>
<p>这个部分重要的是tcp握手的过程</p>
<h2 id="TLS握手"><a href="#TLS握手" class="headerlink" title="TLS握手"></a>TLS握手</h2><p>这部分说的两种加密方式的内容</p>
<h2 id="均衡服务器"><a href="#均衡服务器" class="headerlink" title="均衡服务器"></a>均衡服务器</h2><p>数据发送到服务器之前可能会经过均衡服务器，将请求合理分发，服务器会返回数据</p>
<h2 id="根据状态码判断"><a href="#根据状态码判断" class="headerlink" title="根据状态码判断"></a>根据状态码判断</h2><p>浏览器获取状态码，是200继续解析，400或500就会报错，如果300就重定向</p>
<h2 id="浏览器解析渲染"><a href="#浏览器解析渲染" class="headerlink" title="浏览器解析渲染"></a>浏览器解析渲染</h2><p>就是我们之前说的浏览器如何解析一个文件，解析完之后会开始渲染流程，就是我们之前说的啦，解析dom树与cssom树，有js 就加载js，都搞完就合成render树，再调用gpu解析合成韶关，显示到页面中</p>
<p>这个只是大概流程，要仔细的话还是要去看细节，难顶</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>数组生成树结构</title>
    <url>/2020/05/07/%E9%9D%A2%E8%AF%95/%E6%95%B0%E7%BB%84%E7%94%9F%E6%88%90%E6%A0%91%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>原数据</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">parentId</span>: <span class="number">0</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">parentId</span>: <span class="number">1</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">parentId</span>: <span class="number">2</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">4</span>, <span class="attr">parentId</span>: <span class="number">3</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">5</span>, <span class="attr">parentId</span>: <span class="number">2</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">6</span>, <span class="attr">parentId</span>: <span class="number">4</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">7</span>, <span class="attr">parentId</span>: <span class="number">0</span> &#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>期望结果</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    id: <span class="number">1</span>,</span><br><span class="line">    parentId: <span class="number">0</span>,</span><br><span class="line">    children: [</span><br><span class="line">      &#123;</span><br><span class="line">        id: <span class="number">2</span>,</span><br><span class="line">        parentId: <span class="number">1</span>,</span><br><span class="line">        children: [</span><br><span class="line">          &#123;</span><br><span class="line">            id: <span class="number">3</span>,</span><br><span class="line">            parentId: <span class="number">2</span>,</span><br><span class="line">            children: [</span><br><span class="line">              &#123; <span class="attr">id</span>: <span class="number">4</span>, <span class="attr">parentId</span>: <span class="number">3</span>, <span class="attr">children</span>: [&#123; <span class="attr">id</span>: <span class="number">6</span>, <span class="attr">parentId</span>: <span class="number">4</span> &#125;] &#125;,</span><br><span class="line">            ],</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123; <span class="attr">id</span>: <span class="number">5</span>, <span class="attr">parentId</span>: <span class="number">2</span>, <span class="attr">children</span>: [] &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="number">7</span>, <span class="attr">parentId</span>: <span class="number">0</span> &#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>递归那个比较好理解，对象引用那个头皮发麻 看的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sortNewArr = sortArr(arr, [], <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sortNewArr);</span><br><span class="line"><span class="comment">// 创建一个排序函数，包含三个参数</span></span><br><span class="line"><span class="comment">// arr: 需要处理的数据</span></span><br><span class="line"><span class="comment">// newArr: 用于存放处理后的数据</span></span><br><span class="line"><span class="comment">// parentId: 当前需要处理的 parentId</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortArr</span>(<span class="params">arr, newArr, parentId</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个临时数据用于存放数据</span></span><br><span class="line">  <span class="keyword">var</span> tempArr = [];</span><br><span class="line">  <span class="comment">// 遍历数据，符合当前parentId的数据存放在临时数组tempArr</span></span><br><span class="line">  arr.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (item.parentId === parentId) &#123;</span><br><span class="line">      tempArr.push(item);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 当newArr中无数据时，说明使第一次执行递归函数，newArr直接复制临时数组的数据</span></span><br><span class="line">  <span class="keyword">if</span> (newArr.length === <span class="number">0</span>) &#123;</span><br><span class="line">    newArr = tempArr;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 非第一次递归，遍历存储数据的newArr</span></span><br><span class="line">    newArr.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 当数据中数据含有children，执行子递归。</span></span><br><span class="line">      <span class="keyword">if</span> (item.children) &#123;</span><br><span class="line">        sortArr(arr, item.children, parentId);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 当数据id和当前parentId一致，为数据添加子元素</span></span><br><span class="line">      <span class="keyword">if</span> (item.id === parentId) &#123;</span><br><span class="line">        item.children = tempArr;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  递归条件parentId自增</span><br><span class="line">  parentId++;</span><br><span class="line">  满足条件停止递归</span><br><span class="line">  <span class="keyword">if</span> (parentId &gt; <span class="number">6</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 递归调用</span></span><br><span class="line">  sortArr(arr, newArr, parentId);</span><br><span class="line">  <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析一下这个递归条件 前面还好处理</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
</search>
